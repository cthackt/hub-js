import { __awaiter, __generator } from "tslib";
import { ItemType } from "../../types";
import { Logger } from "../../utils";
var FEATURE_SERVICE_URL_REGEX = /(feature)server(\/|\/(\d+))?$/i;
var SERVICE_URL_REGEX = /\/[a-zA-Z]+server(\/|\/(\d+))?$/i;
/**
 * Feature service / Doc Links Should not have data urls. Let"s exclude them from that.
 *
 * @export
 * @param {string} itemType What type of item is it?
 * @return {*}  {boolean}
 */
export function shouldHaveDataUrl(itemType) {
    // Specifically we want to avoid FS / DL from having a data url.
    return !["Feature Service", "Document Link"].includes(itemType);
}
/**
 * Get the file name out of a url. Will return either the
 * hostname, or the pathname if it exists
 *
 * @export
 * @param {string} url Url to get a file name out of
 * @return {*}  {string}
 */
export function getFileName(url) {
    var filename;
    try {
        var parsed = new URL(url);
        // If the URL pathname exists, return its last segment,
        // otherwise return the hostname
        filename =
            parsed.pathname !== "/"
                ? parsed.pathname.split("/").pop()
                : parsed.hostname;
    }
    catch (e) {
        throw new Error("Error getting file name from data url");
    }
    return filename;
}
/**
 * Is this a valid url?
 *
 * @param {string} url Url to validate
 * @return {*}  {boolean}
 */
export function isUrl(url) {
    // Use try / catch as a simple string "test" will cause new URL() to throw an error.
    try {
        var result = new URL(url);
        // Cast to bool.
        return !!result;
    }
    catch (e) {
        Logger.error("Error parsing data url");
        return false;
    }
}
/**
 * Tests if url string is a feature service / layer.
 *
 * @param {string} url URL to test
 * @return {*}  {boolean}
 */
export function isFeatureService(url) {
    return FEATURE_SERVICE_URL_REGEX.test(url);
}
/**
 * Tests if url string is a service (map, feature, image, etc)
 *
 * @param {string} url Url to test
 * @return {*}  {boolean}
 */
export function isService(url) {
    return SERVICE_URL_REGEX.test(url);
}
/**
 * Is the service a feature service AND is it a layer specifically
 *
 * @param {string} url
 * @return {*}  {boolean}
 */
export function isFeatureLayer(url) {
    var results = url.match(FEATURE_SERVICE_URL_REGEX);
    return results && !!results[3];
}
/**
 * Gets item title from url as a fall back
 *
 * @param {string} url item url
 * @return {*}  {string}
 */
export function getFeatureServiceTitle(url) {
    return url.match(/\/services\/(.+)\/(feature|map|image)server/i)[1];
}
/**
 * Gets item info out of a feature layer item.
 *
 * @export
 * @param {string} url Item URL
 * @param {{
 *     name: string,
 *     description: string,
 *     extent: any
 *   }} body Item body.
 * @return {*}  {{
 *   title: string,
 *   description: string,
 *   extent: any,
 *   url: string
 * }}
 */
export function getFeatureLayerItem(url, body) {
    return {
        title: body.name,
        description: body.description,
        extent: body.extent,
        url: url,
    };
}
/**
 * Gets item info out of a feature service response (which is not a specific layer)
 *
 * @export
 * @param {*} url
 * @param {*} body
 * @return {*}
 */
export function getFeatureServiceItem(url, body) {
    var description = body.serviceDescription || body.description;
    var title = getFeatureServiceTitle(url);
    var extent = body.fullExtent || body.initialExtent;
    return { title: title, description: description, extent: extent, url: url };
}
/**
 * Ping a non FS url and return response status && headers
 *
 * @export
 * @param {string} url Non FS URL
 * @return {*}  {Promise<{ ok: boolean, headers: Headers }>}
 */
export function pingUrl(url) {
    return __awaiter(this, void 0, void 0, function () {
        var response;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, fetch(url, { method: "HEAD" })];
                case 1:
                    response = _a.sent();
                    return [2 /*return*/, {
                            ok: response.ok,
                            headers: response.headers,
                        }];
            }
        });
    });
}
/**
 * Ping a FS URL and handle matters such as "hidden" success failures.
 *
 * @export
 * @param {string} url
 * @return {*}  {Promise<{ ok: boolean, item?: any }>}
 */
export function pingFeatureService(url) {
    return __awaiter(this, void 0, void 0, function () {
        var parsed, response, body, getItem, item;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    parsed = new URL(url);
                    parsed.searchParams.set("f", "json");
                    return [4 /*yield*/, fetch(parsed.href)];
                case 1:
                    response = _a.sent();
                    if (!response.ok) {
                        return [2 /*return*/, { ok: false }];
                    }
                    return [4 /*yield*/, response.json()];
                case 2:
                    body = _a.sent();
                    // Exit if the request returns an error
                    if (body.error) {
                        return [2 /*return*/, { ok: false }];
                    }
                    getItem = isFeatureLayer(url)
                        ? getFeatureLayerItem
                        : getFeatureServiceItem;
                    item = getItem(url, body);
                    return [2 /*return*/, {
                            ok: true,
                            item: item,
                        }];
            }
        });
    });
}
export function detectDataTypeFromHeader(headers) {
    var contentType = headers.get("Content-Type");
    var dataType;
    if (!contentType) {
        return;
    }
    // Only get the "media-type"
    contentType = contentType.split(";").shift();
    if (contentType === "text/csv") {
        dataType = ItemType.CSV;
    }
    else if (contentType === "application/vnd.ms-excel" ||
        contentType ===
            "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet") {
        dataType = ItemType["Microsoft Excel"];
    }
    else if (contentType === "application/pdf") {
        dataType = ItemType.PDF;
    }
    else if (contentType === "image/jpeg" ||
        contentType === "image/jpg" ||
        contentType === "image/png") {
        dataType = ItemType.Image;
    }
    else if (contentType === "application/geo+json") {
        dataType = ItemType.GeoJson;
    }
    return dataType;
}
export function detectDataTypeFromExtension(url) {
    var contentType = url.toLowerCase().split(".").pop();
    var dataType;
    if (contentType === "csv") {
        dataType = ItemType.CSV;
    }
    else if (contentType === "xls" || contentType === "xlsx") {
        dataType = ItemType["Microsoft Excel"];
    }
    else if (contentType === "pdf") {
        dataType = ItemType.PDF;
    }
    else if (contentType === "jpeg" ||
        contentType === "jpg" ||
        contentType === "png") {
        dataType = ItemType.Image;
    }
    else if (contentType === "geojson") {
        dataType = ItemType.GeoJson;
    }
    return dataType;
}
//# sourceMappingURL=_validate-url-helpers.js.map