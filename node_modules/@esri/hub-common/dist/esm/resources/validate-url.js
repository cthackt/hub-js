import { __awaiter, __generator } from "tslib";
import { ItemType } from "../types";
import { Logger } from "../utils";
import { isUrl, isFeatureService, isService, pingFeatureService, pingUrl, detectDataTypeFromHeader, getFileName, detectDataTypeFromExtension, shouldHaveDataUrl, } from "./_internal/_validate-url-helpers";
/**
 * Takes in a URL and validates it based on valid url, type of item, etc
 *
 * @export
 * @param {string} url
 * @return {*}  {Promise<any>}
 */
export function validateUrl(url) {
    return __awaiter(this, void 0, void 0, function () {
        var isFeatureServiceUrl, isServiceUrl, type, item, pingResult, _a, e_1;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    // If URL doesn't pass then exit out immediately.
                    if (!isUrl(url)) {
                        return [2 /*return*/, {
                                pass: false,
                                error: "invalidFormat",
                            }];
                    }
                    isFeatureServiceUrl = isFeatureService(url);
                    isServiceUrl = isService(url);
                    if (isServiceUrl && !isFeatureServiceUrl) {
                        return [2 /*return*/, {
                                pass: false,
                                error: "invalidFormat",
                            }];
                    }
                    pingResult = {};
                    _b.label = 1;
                case 1:
                    _b.trys.push([1, 6, , 7]);
                    if (!isFeatureServiceUrl) return [3 /*break*/, 3];
                    return [4 /*yield*/, pingFeatureService(url)];
                case 2:
                    _a = _b.sent();
                    return [3 /*break*/, 5];
                case 3: return [4 /*yield*/, pingUrl(url)];
                case 4:
                    _a = _b.sent();
                    _b.label = 5;
                case 5:
                    pingResult = _a;
                    // return an error if the response is not okay
                    if (!pingResult.ok) {
                        return [2 /*return*/, {
                                pass: false,
                                error: "invalidUrl",
                            }];
                    }
                    return [3 /*break*/, 7];
                case 6:
                    e_1 = _b.sent();
                    // TODO: This is tricky. The fetch() API rejects when a network error
                    // happens. This error can be a CORS error, or a 404 error, or a timeout
                    // error. While an error like 404 does suggest a bad URL, the CORS occurs
                    // because this is a front-end request and the file is likely accessible by
                    // the server. Unfortunately, the error doesn't have any information about
                    // underline failure type. For now, the network failure is ignored, so the
                    // user can paste a URL from any domain and avoid the CORS issue.
                    Logger.error("error requesting url");
                    return [3 /*break*/, 7];
                case 7:
                    // Use the metadata from the ping response if exists, otherwise guess the file
                    // name from the URL
                    if (pingResult.item) {
                        item = pingResult.item;
                    }
                    else {
                        item = { title: getFileName(url), url: url };
                    }
                    if (pingResult.headers) {
                        type = detectDataTypeFromHeader(pingResult.headers);
                    }
                    if (isFeatureServiceUrl) {
                        type = ItemType["Feature Service"];
                    }
                    else if (!type) {
                        // Guess the data type from the extension
                        type = detectDataTypeFromExtension(url);
                    }
                    if (type) {
                        item.type = type;
                    }
                    if (item.type && shouldHaveDataUrl(item.type)) {
                        item.dataUrl = item.url;
                    }
                    return [2 /*return*/, {
                            pass: true,
                            // The type may or may not be true
                            type: type,
                            // fetched / calculated item
                            item: item,
                        }];
            }
        });
    });
}
//# sourceMappingURL=validate-url.js.map