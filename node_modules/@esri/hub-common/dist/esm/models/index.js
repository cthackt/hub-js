import { __assign, __awaiter, __generator } from "tslib";
export * from "./serializeModel";
import { createItem, getItem, getItemData, updateItem, } from "@esri/arcgis-rest-portal";
import { cloneObject, getItemBySlug } from "..";
/**
 * Gets the full item/data model for an item id
 * @param {string} id
 * @param {Object} requestOptions
 */
export function getModel(id, requestOptions) {
    return Promise.all([
        getItem(id, requestOptions),
        getItemData(id, requestOptions),
    ]).then(function (result) {
        // shape this into a model
        return {
            item: result[0],
            data: result[1],
        };
    });
}
/**
 * Get a model by it's slug
 *
 * This uses the [Filter](https://developers.arcgis.com/rest/users-groups-and-items/search-reference.htm) option of the
 * to search for an item that has a typekeyword of `slug|{slug-value}`
 *
 * This is useful for applications that want to use human-readable urls instead
 * of using item ids.
 *
 * @param slug
 * @param requestOptions
 * @returns
 */
export function getModelBySlug(slug, requestOptions) {
    return getItemBySlug(slug, requestOptions)
        .then(function (item) {
        var prms = [Promise.resolve(item)];
        if (item) {
            prms.push(getItemData(item.id, requestOptions));
        }
        else {
            prms.push(Promise.resolve(null));
        }
        return Promise.all(prms);
    })
        .then(function (result) {
        if (result[0]) {
            return {
                item: result[0],
                data: result[1],
            };
        }
        else {
            return null;
        }
    });
}
/**
 * Create an item to back and IModel.
 *
 * @param {IModel}
 * @param {IRequestOptions} requestOptions
 * @returns {Promise<IModel>}
 */
export function createModel(model, requestOptions) {
    var clone = cloneObject(model);
    var item = cloneObject(model.item);
    item.data = cloneObject(model.data);
    var opts = __assign({ item: item }, requestOptions);
    return createItem(opts).then(function (response) {
        clone.item.id = response.id;
        clone.item.created = new Date().getTime();
        clone.item.modified = clone.item.created;
        return clone;
    });
}
/**
 * Update an IModel. Generic function that will be used across all
 * type-specific update functions
 *
 * @export
 * @param {IModel} "model" object (i.e. `{item:{...}, data:{...}}`)
 * @param {IRequestOptions} requestOptions
 * @returns {Promise<IModel>}
 */
export function updateModel(model, requestOptions) {
    var clone = cloneObject(model);
    var item = cloneObject(model.item);
    item.data = cloneObject(model.data);
    var opts = __assign({ item: item }, requestOptions);
    return updateItem(opts).then(function () {
        // update the modified prop
        // this won't be exact, but it will be very close
        clone.item.modified = new Date().getTime();
        return clone;
    });
}
/**
 * Given an Item, fetch the data json and return an IModel
 * @param item
 * @param requestOptions
 * @returns
 */
export function fetchModelFromItem(item, requestOptions) {
    return __awaiter(this, void 0, void 0, function () {
        var data;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, getItemData(item.id, requestOptions)];
                case 1:
                    data = _a.sent();
                    return [2 /*return*/, {
                            item: item,
                            data: data,
                        }];
            }
        });
    });
}
//# sourceMappingURL=index.js.map