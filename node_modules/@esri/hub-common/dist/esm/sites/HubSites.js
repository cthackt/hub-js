import { __assign, __awaiter, __generator } from "tslib";
import { removeItem } from "@esri/arcgis-rest-portal";
import { addSiteDomains, cloneObject, constructSlug, createModel, ensureUniqueDomainName, fetchModelFromItem, fetchSiteModel, getHubApiUrl, getItemThumbnailUrl, getModel, getOrgDefaultTheme, getProp, mergeContentFilter, registerSiteAsApplication, removeDomainsBySiteId, setProp, setSlugKeyword, slugify, stripProtocol, updateModel, } from "..";
import { PropertyMapper } from "../core/_internal/PropertyMapper";
import { handleDomainChanges } from "./_internal";
import { searchContentEntities } from "../search/_internal/searchContentEntities";
export var HUB_SITE_ITEM_TYPE = "Hub Site Application";
export var ENTERPRISE_SITE_ITEM_TYPE = "Site Application";
/**
 * Default values of a IHubSite
 */
var DEFAULT_SITE = {
    name: "No title provided",
    tags: [],
    typeKeywords: ["Hub Site", "hubSite", "DELETEMESITE"],
    capabilities: [
        "api_explorer",
        "pages",
        "my_data",
        "social_logins",
        "json_chart_card",
        "document_iframes",
        "items_view",
        "app_page",
        "underlinedLinks",
        "globalNav",
        "socialSharing",
    ],
    catalog: {
        groups: [],
    },
    subdomain: "",
    defaultHostname: "",
    customHostname: "",
    clientId: "",
    map: null,
    feeds: {},
    pages: [],
    theme: null,
    contentViews: {
        sidePanelOpen: {
            app: true,
            map: true,
            dataset: true,
            document: true,
            feedback: true,
        },
    },
};
/**
 * Default values for a new HubSite Model
 */
var DEFAULT_SITE_MODEL = {
    item: {
        // type: intentionally left out as we need to
        // set that based on portal/enterprise
        title: "No Title Provided",
        description: "No Description Provided",
        snippet: "",
        tags: [],
        typeKeywords: ["Hub Site", "hubSite", "DELETEMESITE"],
        properties: {
            slug: "",
            orgUrlKey: "",
            defaultHostname: "",
            customHostname: "",
            clientId: "",
            subdomain: "",
            schemaVersion: 1.5,
        },
        url: "",
    },
    data: {
        catalog: {
            groups: [],
        },
        feeds: {},
        values: {
            title: "",
            defaultHostname: "",
            customHostname: "",
            subdomain: "",
            faviconUrl: "",
            uiVersion: "2.4",
            clientId: "",
            map: {
                basemaps: {},
            },
            defaultExtent: {},
            pages: [],
            theme: {},
            layout: {
                sections: [],
                header: {
                    component: {
                        name: "site-header",
                        settings: {
                            fullWidth: false,
                            iframeHeight: "150px",
                            iframeUrl: "",
                            links: [],
                            logoUrl: "",
                            title: "default site",
                            markdown: "",
                            headerType: "default",
                            schemaVersion: 3,
                            showLogo: true,
                            showTitle: true,
                            logo: {
                                display: {},
                                state: "valid",
                            },
                            shortTitle: "",
                            menuLinks: [],
                            socialLinks: {
                                facebook: {},
                                twitter: {},
                                instagram: {},
                                youtube: {},
                            },
                        },
                    },
                    showEditor: false,
                },
                footer: {
                    component: {
                        name: "site-footer",
                        settings: {
                            footerType: "none",
                            markdown: "",
                            schemaVersion: 2.1,
                        },
                    },
                    showEditor: false,
                },
            },
            contentViews: {
                sidePanelOpen: {
                    app: true,
                    map: true,
                    dataset: true,
                    document: true,
                    feedback: true,
                },
            },
        },
    },
};
/**
 * Returns an Array of IPropertyMap objects
 * We could define these directly, but since the
 * properties of IHubSite map directly to properties
 * on item or data, it's slightly less verbose to
 * generate the structure.
 * @returns
 */
function getSitePropertyMap() {
    var itemProps = [
        "created",
        "culture",
        "description",
        "extent",
        "id",
        "modified",
        "owner",
        "snippet",
        "tags",
        "typeKeywords",
        "url",
        "type",
    ];
    var map = [];
    itemProps.forEach(function (entry) {
        map.push({ objectKey: entry, modelKey: "item." + entry });
    });
    var dataProps = ["catalog", "feeds"];
    dataProps.forEach(function (entry) {
        map.push({ objectKey: entry, modelKey: "data." + entry });
    });
    var valueProps = [
        "pages",
        "theme",
        "capabilities",
        "subdomain",
        "defaultHostname",
        "customHostname",
        "clientId",
        "defaultExtent",
        "map",
        "telemetry",
        "headerSass",
    ];
    valueProps.forEach(function (entry) {
        map.push({ objectKey: entry, modelKey: "data.values." + entry });
    });
    // Deeper/Indirect mappings
    map.push({
        objectKey: "slug",
        modelKey: "item.properties.slug",
    });
    map.push({
        objectKey: "orgUrlKey",
        modelKey: "item.properties.orgUrlKey",
    });
    map.push({
        objectKey: "name",
        modelKey: "item.title",
    });
    return map;
}
// TODO: Add OperationStack & Error Handling
/**
 * Create a new Hub Site
 *
 * Minimum properties are `name` and `org`
 * @param partialSite
 * @param requestOptions
 */
export function createSite(partialSite, requestOptions) {
    return __awaiter(this, void 0, void 0, function () {
        var site, portal, _a, mapper, model, registration, updatedModel;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    site = __assign(__assign({}, DEFAULT_SITE), partialSite);
                    portal = requestOptions.portalSelf;
                    // Set the type based on the environment we are working in
                    site.type = requestOptions.isPortal
                        ? ENTERPRISE_SITE_ITEM_TYPE
                        : HUB_SITE_ITEM_TYPE;
                    // Create a slug from the title if one is not passed in
                    if (!site.slug) {
                        site.slug = constructSlug(site.name, site.orgUrlKey);
                    }
                    // Ensure slug is  unique
                    // site.slug = await getUniqueSlug({ slug: site.slug }, requestOptions);
                    // add slug to keywords
                    site.typeKeywords = setSlugKeyword(site.typeKeywords, site.slug);
                    if (!site.subdomain) {
                        site.subdomain = slugify(site.name);
                    }
                    _a = site;
                    return [4 /*yield*/, ensureUniqueDomainName(site.subdomain, requestOptions)];
                case 1:
                    _a.subdomain = _b.sent();
                    // Domains
                    if (!requestOptions.isPortal) {
                        // now that we know the subdomain is available, set the defaultHostname
                        site.defaultHostname = site.subdomain + "-" + portal.urlKey + "." + stripProtocol(getHubApiUrl(requestOptions));
                        // set the url
                        site.url = "https://" + (site.customHostname ? site.customHostname : site.defaultHostname);
                    }
                    else {
                        // Portal Sites use subdomain in hash based router
                        site.typeKeywords.push(("hubsubdomain|" + site.subdomain).toLowerCase());
                        site.url = requestOptions.authentication.portal.replace("/sharing/rest", "/apps/sites") + "/#/" + site.subdomain;
                    }
                    // Note:  We used to use adlib for this, but it's much harder to
                    // use templates with typescript. i.e. you can't assign a string template
                    // to a property defined as `IExtent` without using `as unknown as ...`
                    // which basically removes typechecking
                    site.orgUrlKey = portal.urlKey;
                    // override only if not set...
                    if (!site.theme) {
                        site.theme = getOrgDefaultTheme(portal);
                    }
                    if (!site.defaultExtent) {
                        site.defaultExtent = portal.defaultExtent;
                    }
                    if (!site.culture) {
                        site.culture = portal.culture;
                    }
                    // pull the basemap from portalSelf
                    if (!getProp(site, "map.basemaps.primary")) {
                        setProp("map.basemaps.primary", portal.defaultBasemap, site);
                    }
                    // Put the title into the header
                    if (!getProp(site, "layout.header.component.settings.title")) {
                        setProp("layout.header.component.settings.title", site.name, site);
                    }
                    mapper = new PropertyMapper(getSitePropertyMap());
                    model = mapper.objectToModel(site, cloneObject(DEFAULT_SITE_MODEL));
                    return [4 /*yield*/, createModel(model, requestOptions)];
                case 2:
                    // create the backing item
                    model = _b.sent();
                    return [4 /*yield*/, registerSiteAsApplication(model, requestOptions)];
                case 3:
                    registration = _b.sent();
                    model.data.values.clientId = registration.client_id;
                    // Register domains
                    return [4 /*yield*/, addSiteDomains(model, requestOptions)];
                case 4:
                    // Register domains
                    _b.sent();
                    return [4 /*yield*/, updateModel(model, requestOptions)];
                case 5:
                    updatedModel = _b.sent();
                    // convert the model into a IHubSite and return
                    return [2 /*return*/, mapper.modelToObject(updatedModel, {})];
            }
        });
    });
}
/**
 * Update a Hub Site
 *
 * This checks for and applies domain changes
 * @param site
 * @param requestOptions
 * @returns
 */
export function updateSite(site, requestOptions) {
    return __awaiter(this, void 0, void 0, function () {
        var mapper, updatedModel, currentModel, modelToStore, updatedSiteModel, updatedSite;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    mapper = new PropertyMapper(getSitePropertyMap());
                    updatedModel = mapper.objectToModel(site, cloneObject(DEFAULT_SITE_MODEL));
                    return [4 /*yield*/, getModel(site.id, requestOptions)];
                case 1:
                    currentModel = _a.sent();
                    // handle any domain changes
                    return [4 /*yield*/, handleDomainChanges(updatedModel, currentModel, requestOptions)];
                case 2:
                    // handle any domain changes
                    _a.sent();
                    if (updatedModel.item.properties.slug !== currentModel.item.properties.slug) {
                        // ensure slug to keywords
                        updatedModel.item.typeKeywords = setSlugKeyword(updatedModel.item.typeKeywords, updatedModel.item.properties.slug);
                    }
                    modelToStore = mapper.objectToModel(site, currentModel);
                    return [4 /*yield*/, updateModel(modelToStore, requestOptions)];
                case 3:
                    updatedSiteModel = _a.sent();
                    updatedSite = mapper.modelToObject(updatedSiteModel, site);
                    return [2 /*return*/, updatedSite];
            }
        });
    });
}
/**
 * Remove a Hub Site
 *
 * This simply removes the Site item, and it's associated domain records.
 * This does not remove any Teams/Groups or content associated with the
 * Site
 * @param id
 * @param requestOptions
 * @returns
 */
export function destroySite(id, requestOptions) {
    return __awaiter(this, void 0, void 0, function () {
        var ro;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!!requestOptions.isPortal) return [3 /*break*/, 2];
                    return [4 /*yield*/, removeDomainsBySiteId(id, requestOptions)];
                case 1:
                    _a.sent();
                    _a.label = 2;
                case 2:
                    ro = __assign(__assign({}, requestOptions), { id: id });
                    return [4 /*yield*/, removeItem(ro)];
                case 3:
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    });
}
/**
 * Returns site model given various kinds of identifier
 *
 * @param identifier - a site item ID, site hostname, enterprise site slug, or full site URL
 * @param requestOptions
 * @private // remove when we remove existing fetchSite function
 */
export function _fetchSite(identifier, requestOptions) {
    return __awaiter(this, void 0, void 0, function () {
        var model, mapper, site, token, us;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, fetchSiteModel(identifier, requestOptions)];
                case 1:
                    model = _a.sent();
                    mapper = new PropertyMapper(getSitePropertyMap());
                    site = mapper.modelToObject(model, {});
                    if (requestOptions.authentication) {
                        us = requestOptions.authentication;
                        token = us.token;
                    }
                    site.thumbnailUrl = getItemThumbnailUrl(model.item, requestOptions, token);
                    return [2 /*return*/, site];
            }
        });
    });
}
/**
 * Convert a Hub Site Application item into a Hub Site, fetching any
 * additional information that may be required
 * @param item
 * @param auth
 * @returns
 */
export function convertItemToSite(item, requestOptions) {
    return __awaiter(this, void 0, void 0, function () {
        var model, mapper, token, session, prj;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, fetchModelFromItem(item, requestOptions)];
                case 1:
                    model = _a.sent();
                    mapper = new PropertyMapper(getSitePropertyMap());
                    if (requestOptions.authentication) {
                        session = requestOptions.authentication;
                        token = session.token;
                    }
                    prj = mapper.modelToObject(model, {});
                    prj.thumbnailUrl = getItemThumbnailUrl(model.item, requestOptions, token);
                    return [2 /*return*/, prj];
            }
        });
    });
}
/**
 * Search for Sites and get IHubSite results
 * @param filter
 * @param options
 * @returns
 */
export function searchSites(filter, options) {
    return __awaiter(this, void 0, void 0, function () {
        var scopingFilter, sitesFilter;
        return __generator(this, function (_a) {
            scopingFilter = {
                filterType: "content",
                type: "$site",
            };
            sitesFilter = mergeContentFilter([scopingFilter, filter]);
            // delegate
            return [2 /*return*/, searchContentEntities(sitesFilter, convertItemToSite, options)];
        });
    });
}
//# sourceMappingURL=HubSites.js.map