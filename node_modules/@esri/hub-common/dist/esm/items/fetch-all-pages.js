import { __assign, __spreadArrays } from "tslib";
import { batch } from "../utils/batch";
var MAX_NUM = 100;
/**
 * Fetches all the pages in a search request
 * @param {SearchFunction} searchFunc
 * @param {ISearchOptions} opts
 * @param {number} limit
 * @param {batchSize} number of concurrent requests at a time
 * @returns {Promise<SearchableType[]>}
 */
export function fetchAllPages(searchFunc, opts, limit, batchSize) {
    if (limit === void 0) { limit = -1; }
    var pageSize = opts.num || MAX_NUM;
    var firstStart = opts.start || 1;
    // If a limit is provided, we don't have to use the first request to get the
    // total count before sending things off to batch(). So instead we fake the first
    // response just to set things up.
    var promise = limit === -1
        ? searchFunc(__assign(__assign({}, opts), { num: pageSize, start: firstStart }))
        : Promise.resolve({
            nextStart: firstStart,
            total: limit,
            results: [],
            num: pageSize
        });
    return promise
        .then(function (firstResponse) {
        // no more requests needed, return the first response
        if (firstResponse.nextStart === -1)
            return [firstResponse];
        // generate batch requests for the remaining pages to fetch
        var starts = [];
        for (var i = firstResponse.nextStart; i <= firstResponse.total; i += pageSize) {
            starts.push(i);
        }
        var batchSearchFunc = function (start) {
            return searchFunc(__assign(__assign({}, opts), { start: start, num: pageSize }));
        };
        return batch(starts, batchSearchFunc, batchSize).then(function (responses) { return __spreadArrays([
            firstResponse
        ], responses); });
    })
        .then(function (responses) {
        // merge all the search results into a single array
        var results = responses.reduce(function (acc, response) { return __spreadArrays(acc, response.results); }, []);
        // discard results beyond the limit if applicable
        var clipLimit = limit === -1 ? results.length : limit;
        return results.slice(0, clipLimit);
    });
}
//# sourceMappingURL=fetch-all-pages.js.map