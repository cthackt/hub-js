import { __assign, __spreadArrays } from "tslib";
import { getItemData, getItemGroups, getUser, } from "@esri/arcgis-rest-portal";
import { getAllLayersAndTables, getService, parseServiceUrl, } from "@esri/arcgis-rest-feature-layer";
import { createOperationPipeline } from "../utils";
import OperationStack from "../OperationStack";
// TODO: move these functions here under /items
import { getItemMetadata } from "@esri/arcgis-rest-portal";
import { parse } from "fast-xml-parser";
function parseMetadataXml(metadataXml) {
    var opts = {
        // options for fastXmlParser to read tag attrs
        ignoreAttributes: false,
        attributeNamePrefix: "@_",
        textNodeName: "#value",
    };
    return parse(metadataXml, opts);
}
/**
 * Fetch an [item's metadata](https://doc.arcgis.com/en/arcgis-online/manage-data/metadata.htm) from a portal
 * and parse and return it as JSON
 * @param id item id
 * @param requestOptions
 */
function fetchContentMetadata(id, requestOptions) {
    return getItemMetadata(id, requestOptions)
        .then(function (metadataXml) { return parseMetadataXml(metadataXml); })
        .catch(function () {
        // many items don't have metadata and the request will 404
        // in these cases we don't want to treat it as an error
        // content.metadata === null signals to consumers that
        // we attempted to fetch the metadata, but it doesn't exist
        // TODO: we should probably still throw the error if it's not a 404
        return null;
    });
}
var enrichGroupIds = function (input) {
    var data = input.data, stack = input.stack, requestOptions = input.requestOptions;
    var opId = stack.start("enrichGroupIds");
    return getItemGroups(data.item.id, requestOptions)
        .then(function (response) {
        var admin = response.admin, member = response.member, other = response.other;
        var groupIds = __spreadArrays(admin, member, other).map(function (group) { return group.id; });
        stack.finish(opId);
        return {
            data: __assign(__assign({}, data), { groupIds: groupIds }),
            stack: stack,
            requestOptions: requestOptions,
        };
    })
        .catch(function (error) { return handleEnrichmentError(error, input, opId); });
};
var enrichMetadata = function (input) {
    var data = input.data, stack = input.stack, requestOptions = input.requestOptions;
    var opId = stack.start("enrichMetadata");
    return fetchContentMetadata(data.item.id, requestOptions).then(function (metadata) {
        stack.finish(opId);
        return {
            data: __assign(__assign({}, data), { metadata: metadata }),
            stack: stack,
            requestOptions: requestOptions,
        };
    });
    // TODO: currently fetchContentMetadata will never throw, but
    // if we update it to throw for non-404 errors, need to uncomment this:
    // .catch((error) => handleEnrichmentError(error, input, opId));
};
var enrichOwnerUser = function (input) {
    var data = input.data, stack = input.stack, requestOptions = input.requestOptions;
    var opId = stack.start("enrichOwner");
    // w/o the : any here, I get a compile error about
    // .authentication being incompatible w/ UserSession
    var options = __assign({ username: data.item.owner }, requestOptions);
    return getUser(options)
        .then(function (ownerUser) {
        stack.finish(opId);
        return {
            data: __assign(__assign({}, data), { ownerUser: ownerUser }),
            stack: stack,
            requestOptions: requestOptions,
        };
    })
        .catch(function (error) { return handleEnrichmentError(error, input, opId); });
};
var enrichData = function (input) {
    var data = input.data, stack = input.stack, requestOptions = input.requestOptions;
    var opId = stack.start("enrichData");
    return getItemData(data.item.id, requestOptions)
        .then(function (itemData) {
        stack.finish(opId);
        return { data: __assign(__assign({}, data), { data: itemData }), stack: stack, requestOptions: requestOptions };
    })
        .catch(function (error) { return handleEnrichmentError(error, input, opId); });
};
var enrichServer = function (input) {
    var data = input.data, stack = input.stack, requestOptions = input.requestOptions;
    var opId = stack.start("enrichServer");
    var url = parseServiceUrl(data.item.url);
    var options = __assign(__assign({}, requestOptions), { url: url });
    return getService(options)
        .then(function (server) {
        stack.finish(opId);
        return { data: __assign(__assign({}, data), { server: server }), stack: stack, requestOptions: requestOptions };
    })
        .catch(function (error) { return handleEnrichmentError(error, input, opId); });
};
var enrichLayers = function (input) {
    var data = input.data, stack = input.stack, requestOptions = input.requestOptions;
    var opId = stack.start("enrichLayers");
    var url = data.item.url;
    var options = __assign(__assign({}, requestOptions), { url: url });
    return (getAllLayersAndTables(options)
        // merge layers and tables into a single array
        // and filter out any group layers
        .then(function (response) {
        var merged = __spreadArrays(response.layers, response.tables);
        return merged.filter(function (layer) { return layer.type !== "Group Layer"; });
    })
        .then(function (layers) {
        stack.finish(opId);
        return { data: __assign(__assign({}, data), { layers: layers }), stack: stack, requestOptions: requestOptions };
    })
        .catch(function (error) { return handleEnrichmentError(error, input, opId); }));
};
// add the error to the content.errors,
// log current stack operation as finished with an error
// and return output that can be piped into the next operation
var handleEnrichmentError = function (error, input, opId) {
    var data = input.data, stack = input.stack, requestOptions = input.requestOptions;
    stack.finish(opId, { error: error });
    return {
        data: __assign(__assign({}, data), { errors: getEnrichmentErrors(error, data.errors) }),
        stack: stack,
        requestOptions: requestOptions,
    };
};
var enrichmentOperations = {
    groupIds: enrichGroupIds,
    metadata: enrichMetadata,
    ownerUser: enrichOwnerUser,
    data: enrichData,
    server: enrichServer,
    layers: enrichLayers,
};
/**
 * convert an error to an enrichment error info format
 * and optionally append it to an existing array of those
 * @param error
 * @param errors an array of existing enrichment error info
 * @returns a new array of enrichment error info
 * @private
 */
export var getEnrichmentErrors = function (error, errors) {
    if (errors === void 0) { errors = []; }
    var message = typeof error === "string"
        ? /* istanbul ignore next our tests only throw Error objects */
            error
        : error.message;
    return __spreadArrays(errors, [
        {
            // NOTE: for now we just return the message and type "Other"
            // but we could later introspect for HTTP or AGO errors
            // and/or return the status code if available
            type: "Other",
            message: message,
        },
    ]);
};
/**
 * Fetch enrichments for an item
 * @param item
 * @param enrichments the list of enrichments to fetch
 * @param requestOptions
 * @returns an object with the item and enrichments
 * @private
 */
export var fetchItemEnrichments = function (item, enrichments, requestOptions) {
    // create a pipeline of enrichment operations
    var operations = enrichments.reduce(function (ops, enrichment) {
        var operation = enrichmentOperations[enrichment];
        // only include the enrichments that we know how to fetch
        operation && ops.push(operation);
        return ops;
    }, []);
    var pipeline = createOperationPipeline(operations);
    // execute pipeline and return the item and enrichments
    return pipeline({
        data: { item: item },
        stack: new OperationStack(),
        requestOptions: requestOptions,
    }).then(function (output) { return output.data; });
};
//# sourceMappingURL=_enrichments.js.map