import { __assign, __awaiter, __generator } from "tslib";
import { addItemPart, cancelItemUpload, commitItemUpload, createItem, } from "@esri/arcgis-rest-portal";
import { batch } from "../utils";
import { _prepareUploadRequests } from "./_internal/_prepare-upload-requests";
/**
 * Creates an item in online from a local file/item.
 * Upload is multithreaded as the item is chunked up.
 *
 * @export
 * @param {IItemAdd} item Item to be uploaded into online.
 * @param {IUserRequestOptions} requestOptions
 * @return {*}  {Promise<string>} Newly created item id
 */
export function createItemFromFile(item, requestOptions) {
    return __awaiter(this, void 0, void 0, function () {
        var file, createResult, itemId, sizeLimit, uploadQueue, e_1;
        var _this = this;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    file = item.file;
                    // make a shadow copy of the item parameter and remove the file object
                    // so that it won't trigger the direct upload at the createContent
                    // request
                    item = Object.assign({}, item);
                    delete item.file;
                    return [4 /*yield*/, createItem(__assign({ item: item, filename: file.name, async: true, multipart: true, overwrite: true }, requestOptions))];
                case 1:
                    createResult = _a.sent();
                    itemId = createResult.id;
                    _a.label = 2;
                case 2:
                    _a.trys.push([2, 5, , 7]);
                    sizeLimit = 6 * 1000 * 1000;
                    uploadQueue = _prepareUploadRequests(file, item.owner, itemId, sizeLimit, requestOptions);
                    // execute up to 5 concurrent requests
                    return [4 /*yield*/, batch(uploadQueue, 
                        // We are doing this to catch individual response failures
                        // and throwing them to stop further xhr's
                        function (opts) { return __awaiter(_this, void 0, void 0, function () {
                            var resp;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4 /*yield*/, addItemPart(opts)];
                                    case 1:
                                        resp = _a.sent();
                                        // If the response did not return with success then throw an error
                                        if (!resp.success) {
                                            throw new Error("addItemPart failed");
                                        }
                                        return [2 /*return*/];
                                }
                            });
                        }); }, 5)];
                case 3:
                    // execute up to 5 concurrent requests
                    _a.sent();
                    // Commit is called once all parts are uploaded during a multipart add item or update item operation.
                    return [4 /*yield*/, commitItemUpload(__assign({ id: itemId, item: item, owner: item.owner }, requestOptions))];
                case 4:
                    // Commit is called once all parts are uploaded during a multipart add item or update item operation.
                    _a.sent();
                    return [3 /*break*/, 7];
                case 5:
                    e_1 = _a.sent();
                    // If an error is thrown then cancel item upload
                    return [4 /*yield*/, cancelItemUpload(__assign({ id: itemId, owner: item.owner }, requestOptions))];
                case 6:
                    // If an error is thrown then cancel item upload
                    _a.sent();
                    throw e_1;
                case 7: return [2 /*return*/, createResult];
            }
        });
    });
}
//# sourceMappingURL=create-item-from-file.js.map