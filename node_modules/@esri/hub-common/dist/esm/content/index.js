import { __assign } from "tslib";
import { getCollection } from "../collections";
import { categories as allCategories } from "../categories";
import { includes } from "../utils";
import { getProp } from "../objects";
import { getServiceTypeFromUrl } from "../urls";
import { getHubRelativeUrl, isPageType } from "./_internal";
import { camelize } from "../util";
import { normalizeItemType, getContentTypeIcon, composeContent, } from "./compose";
import { getFamily } from "./get-family";
import { parseDatasetId, removeContextFromSlug } from "./slugs";
// re-export functions used in this file
export * from "./compose";
export * from "./get-family";
export * from "./slugs";
export * from "./fetch";
export * from "./types";
// TODO: remove this at next breaking version
/**
 * ```js
 * import { getCategory } from "@esri/hub-common";
 * //
 * getCategory('Feature Layer')
 * > 'dataset'
 * ```
 * **DEPRECATED: Use getCollection() instead**
 * returns the Hub category for a given item type
 * @param itemType The ArcGIS [item type](https://developers.arcgis.com/rest/users-groups-and-items/items-and-item-types.htm).
 * @returns the category of a given item type.
 */
export function getCategory(itemType) {
    if (itemType === void 0) { itemType = ""; }
    /* tslint:disable no-console */
    console.warn("DEPRECATED: Use getCollection() instead. getCategory will be removed at v10.0.0");
    /* tslint:enable no-console */
    var collection = getCollection(itemType);
    // for backwards compatibility
    return collection === "feedback" ? "app" : collection;
}
/**
 * ```js
 * import { getTypes } from "@esri/hub-common";
 * //
 * getTypes('site')
 * > [ 'hub site application' ]
 * ```
 * To do.
 * @param category The ArcGIS Hub category.
 * @returns all the item types for the given category.
 *
 */
export function getTypes(category) {
    if (category === void 0) { category = ""; }
    return allCategories[category.toLowerCase()];
}
/**
 * ```js
 * import { getTypeCategories } from "@esri/hub-common";
 * //
 * getTypeCategories(item)
 * > [ 'Hub Site Application' ]
 * ```
 * @param item Item object.
 * @returns typeCategory of the input item.
 *
 */
export function getTypeCategories(item) {
    if (item === void 0) { item = {}; }
    var type = normalizeItemType(item);
    var category = getCategory(type);
    if (category) {
        // upper case first letter and return as element in array for backwards compatibility
        var chars = Array.from(category);
        chars[0] = chars[0].toUpperCase();
        return [chars.join("")];
    }
    else {
        return ["Other"];
    }
}
/**
 * ```js
 * import { getContentIdentifier } from "@esri/hub-common";
 * //
 * getContentIdentifier(content, site)
 * > 'f12hhjk32' // id
 * // OR
 * > 'content-slug' // human-readable slug
 * ```
 * Returns the preferred identifier for a piece of content (determined by content type):
 * - Content from the 'template' and 'feedback' families return the standard id field
 * - Pages that are linked to the site parameter will return the slug defined by the site. Otherwise, the page id will be returned
 * - All other content will return the highest available item in the following hierarchy:
 *   1. slug - includes org prefix if the site parameter is a portal or has an orgKey different from the slug prefix
 *   2. hubId
 *   3. id
 * @param content The IHubContent item
 * @param site The site to compare content against
 * @returns the preferred id for the given content.
 */
export function getContentIdentifier(content, site) {
    // We don't currently support slugs for hub initiative templates, solutions or surveys
    if (includes(["template", "feedback"], content.family)) {
        return content.id;
    }
    // If it is a hub page linked to a site, return the page slug at the
    // site data instead. Because this one is the original one that was used
    // to create the page url (not mutable once created) and the slug (below)
    // generated by the hub-indexer could simply change with page name.
    if (isPageType(content.type)) {
        // check if the page is linked to the current site
        var pages = getProp(site, "data.values.pages") || [];
        // if so, return the page slug otherwise the page id
        var page = pages.find(function (p) { return p.id === content.id; });
        return page ? page.slug : content.id;
    }
    // If a slug is present, always return it
    if (content.slug) {
        var slug = void 0;
        var orgKey = getProp(site, "domainInfo.orgKey");
        // Use namespaced slug when on the umbrella site
        if (getProp(site, "data.values.isUmbrella")) {
            slug = content.slug;
        }
        else {
            // Use shortened slug if the slug's namespace is the same as the orgKey
            slug = removeContextFromSlug(content.slug, orgKey);
        }
        return slug;
    }
    return content.hubId || content.id;
}
/**
 * DEPRECATED: Use getFamily() instead.
 *
 * get the HubType for a given item or item type
 *
 * @param itemOrType an item or item.type
 */
export function getItemHubType(itemOrType) {
    /* tslint:disable no-console */
    console.warn("DEPRECATED: Use getFamily() instead. getItemHubType() will be removed at v10.0.0");
    /* tslint:enable no-console */
    if (typeof itemOrType === "string") {
        itemOrType = { type: itemOrType };
    }
    var itemType = normalizeItemType(itemOrType);
    // TODO: not all categories are Hub types, may need to validate
    return getCollection(itemType);
}
/**
 * Convert a Portal item to Hub content
 *
 * @param item Portal Item
 * @returns Hub content
 * @export
 */
export function itemToContent(item) {
    return composeContent(item);
}
/**
 * Convert a Hub API dataset resource to Hub Content
 *
 * @param {DatasetResource} Dataset resource
 * @returns {IHubContent} Hub content object
 * @export
 */
export function datasetToContent(dataset) {
    // extract item from dataset, create content from the item
    var item = datasetToItem(dataset);
    // extract enrichments from attributes
    var _a = dataset.attributes, 
    // item enrichments
    errors = _a.errors, boundary = _a.boundary, metadata = _a.metadata, slug = _a.slug, groupIds = _a.groupIds, orgId = _a.orgId, orgName = _a.orgName, organization = _a.organization, orgExtent = _a.orgExtent, 
    // map and feature server enrichments
    server = _a.server, layers = _a.layers, layer = _a.layer, recordCount = _a.recordCount, statistics = _a.statistics, 
    // additional attributes needed
    extent = _a.extent, searchDescription = _a.searchDescription;
    // get the layerId from the layer
    var layerId = layer && layer.id;
    // re-assemble the org as an enrichment
    var org = orgId && {
        id: orgId,
        name: orgName || organization,
        extent: orgExtent,
    };
    // compose a content out of the above
    return composeContent(item, {
        layerId: layerId,
        slug: slug,
        errors: errors,
        // setting this to null signals to enrichMetadata to skip this
        metadata: metadata || null,
        groupIds: groupIds,
        org: org,
        server: server,
        layers: layers,
        recordCount: recordCount,
        boundary: boundary,
        extent: extent,
        searchDescription: searchDescription,
        statistics: statistics,
    });
}
/**
 * Convert a Hub API dataset resource to a portal item
 *
 * @param {DatasetResource} Dataset resource
 * @returns {IItem} portal item
 * @export
 */
export function datasetToItem(dataset) {
    if (!dataset) {
        return;
    }
    var id = dataset.id, attributes = dataset.attributes;
    if (!attributes) {
        return;
    }
    // parse item id
    var itemId = parseDatasetId(id).itemId;
    // read item properties from attributes
    // NOTE: we attempt to read all item properties
    // even though some may not be currently returned
    var 
    // start w/ item properties from
    // https://developers.arcgis.com/rest/users-groups-and-items/item.htm
    owner = attributes.owner, orgId = attributes.orgId, created = attributes.created, 
    // the Hub API returns item.modified in attributes.itemModified (below)
    modified = attributes.modified, 
    // NOTE: we use attributes.name to store the title or the service/layer name
    // but in Portal name is only used for file types to store the file name (read only)
    name = attributes.name, title = attributes.title, type = attributes.type, typeKeywords = attributes.typeKeywords, description = attributes.description, snippet = attributes.snippet, tags = attributes.tags, thumbnail = attributes.thumbnail, 
    // the Hub API returns item.extent in attributes.itemExtent (below)
    // extent,
    categories = attributes.categories, contentStatus = attributes.contentStatus, 
    // the Hub API doesn't currently return spatialReference
    spatialReference = attributes.spatialReference, 
    // the Hub API doesn't currently return accessInformation
    accessInformation = attributes.accessInformation, licenseInfo = attributes.licenseInfo, culture = attributes.culture, url = attributes.url, access = attributes.access, 
    // the Hub API doesn't currently return proxyFilter
    proxyFilter = attributes.proxyFilter, properties = attributes.properties, 
    // the Hub API doesn't currently return appCategories, industries,
    // languages, largeThumbnail, banner, screenshots, listed, ownerFolder
    appCategories = attributes.appCategories, industries = attributes.industries, languages = attributes.languages, largeThumbnail = attributes.largeThumbnail, banner = attributes.banner, screenshots = attributes.screenshots, listed = attributes.listed, ownerFolder = attributes.ownerFolder, size = attributes.size, 
    // the Hub API doesn't currently return protected
    isProtected = attributes.protected, commentsEnabled = attributes.commentsEnabled, 
    // the Hub API doesn't currently return numComments, numRatings,
    // avgRating, numViews, itemControl, scoreCompleteness
    numComments = attributes.numComments, numRatings = attributes.numRatings, avgRating = attributes.avgRating, numViews = attributes.numViews, itemControl = attributes.itemControl, scoreCompleteness = attributes.scoreCompleteness, 
    // additional attributes we'll need
    // to derive the above values when missing
    itemExtent = attributes.itemExtent, itemModified = attributes.itemModified, modifiedProvenance = attributes.modifiedProvenance, serviceSpatialReference = attributes.serviceSpatialReference;
    // layer datasets will get their type from the layer
    // so we will need to derive the item type from the URL
    var serviceType = url && getServiceTypeFromUrl(url);
    // build and return an item from properties
    // NOTE: we currently do NOT provide default values
    // (i.e. null for scalar attributes, [] for arrays, etc)
    // for attributes that are not returned by the Hub API
    // this helps distinguish an item that comes from the API
    // but forces all consumers to do handle missing properties
    return {
        id: itemId,
        owner: owner,
        orgId: orgId,
        created: created,
        // for feature layers, modified will usually come from the layer so
        // we prefer itemModified, but fall back to modified if it came from the item
        modified: (itemModified ||
            (modifiedProvenance === "item.modified" && modified)),
        title: (title || name),
        type: serviceType || type,
        typeKeywords: typeKeywords,
        description: description,
        tags: tags,
        snippet: snippet,
        thumbnail: thumbnail,
        extent: itemExtent ||
            /* istanbul ignore next: API should always return itemExtent, but we default to [] just in case */ [],
        categories: categories,
        contentStatus: contentStatus,
        spatialReference: spatialReference || serviceSpatialReference,
        accessInformation: accessInformation,
        licenseInfo: licenseInfo,
        culture: culture,
        url: url,
        access: access,
        size: size,
        protected: isProtected,
        proxyFilter: proxyFilter,
        properties: properties,
        appCategories: appCategories,
        industries: industries,
        languages: languages,
        largeThumbnail: largeThumbnail,
        banner: banner,
        screenshots: screenshots,
        listed: listed,
        ownerFolder: ownerFolder,
        commentsEnabled: commentsEnabled,
        numComments: numComments,
        numRatings: numRatings,
        avgRating: avgRating,
        numViews: numViews,
        itemControl: itemControl,
        scoreCompleteness: scoreCompleteness,
    };
}
/**
 * returns a new content that has the specified type and
 * and updated related properties like, family, etc
 * @param content orignal content
 * @param type new type
 * @returns new content
 */
export var setContentType = function (content, type) {
    // get family and normalized type based on new type
    var normalizedType = normalizeItemType(__assign(__assign({}, content.item), { type: type }));
    var family = getFamily(normalizedType);
    var contentTypeIcon = getContentTypeIcon(normalizedType);
    var contentTypeLabel = getContentTypeLabel(normalizedType, content.isProxied);
    var updated = __assign(__assign({}, content), { type: normalizedType, family: family,
        // TODO: remove this at next breaking change now that it has been deprecated
        normalizedType: normalizedType,
        contentTypeIcon: contentTypeIcon,
        contentTypeLabel: contentTypeLabel });
    // update the relative URL to the content
    // which is based on type and family
    return appendContentUrls(updated, {
        relative: getContentRelativeUrl(updated),
    });
};
/**
 * Compute the content type label
 * @param contentType
 * @param isProxied
 * @returns content type label
 */
export var getContentTypeLabel = function (contentType, isProxied) {
    return isProxied ? "CSV" : camelize(contentType || "");
};
/**
 * DEPRECATED returns a new content that has the specified hubId and updated identifier
 * @param content orignal content
 * @param hubId new hubId
 * @returns new content
 */
/* istanbul ignore next DEPRECATED and no longer in use */
export var setContentHubId = function (content, hubId) {
    var id = content.id, slug = content.slug;
    // get the identifier which is based on hubId
    var identifier = slug || hubId || id;
    var updated = __assign(__assign({}, content), { hubId: hubId, identifier: identifier });
    // update the relative URL to the content
    // which is based on identifier
    return appendContentUrls(updated, {
        relative: getContentRelativeUrl(updated),
    });
};
/**
 * DEPRECATED: Calculates the relative and absolute urls for a given content on a specific site
 *
 * @param content
 * @param siteModel
 * @returns relative and absolute urls
 */
export var getContentSiteUrls = function (content, siteModel) {
    // compute relative URL using a site specific identifier
    var siteIdentifier = getContentIdentifier(content, siteModel);
    var relative = getContentRelativeUrl(content, siteIdentifier);
    // get the absolute URL to this content on the site
    var siteUrl = getProp(siteModel, "item.url").replace(/\/$/, "");
    var absolute = "" + siteUrl + relative;
    return { relative: relative, absolute: absolute };
};
/**
 * append the absolute URL to the content on the site
 * also updates the relative URL in case the
 * @param content
 * @param siteModel
 * @returns
 */
export var setContentSiteUrls = function (content, siteModel) {
    var _a = getContentSiteUrls(content, siteModel), relative = _a.relative, site = _a.absolute;
    // append the updated URLs to a new content
    return appendContentUrls(content, {
        relative: relative,
        site: site,
    });
};
// URL helpers
var appendContentUrls = function (content, newUrls) {
    // merge new urls into existing ones and return a new content
    var urls = __assign(__assign({}, content.urls), newUrls);
    return __assign(__assign({}, content), { urls: urls });
};
var getContentRelativeUrl = function (content, siteIdentifier) {
    return getHubRelativeUrl(content.type, siteIdentifier || content.identifier, content.typeKeywords);
};
//# sourceMappingURL=index.js.map