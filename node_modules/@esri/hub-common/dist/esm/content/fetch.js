import { __assign, __awaiter, __generator, __rest } from "tslib";
import { getLayer, parseServiceUrl, queryFeatures, } from "@esri/arcgis-rest-feature-layer";
import { getItem } from "@esri/arcgis-rest-portal";
import { fetchItemEnrichments, } from "../items/_enrichments";
import { isNil } from "../util";
import { maybeConcat } from "../utils/_array";
import { addContextToSlug, isSlug, parseDatasetId } from "./slugs";
import { fetchHubEnrichmentsById, fetchHubEnrichmentsBySlug, getContentEnrichments, } from "./_fetch";
import { canUseHubApiForItem } from "./_internal";
import { composeContent, getItemLayer, getProxyUrl, isLayerView, } from "./compose";
var hasFeatures = function (contentType) {
    return ["Feature Layer", "Table"].includes(contentType);
};
var maybeFetchLayerEnrichments = function (itemAndEnrichments, options) { return __awaiter(void 0, void 0, void 0, function () {
    var item, data, layers, layer, layerUrl, getLayerOptions, layerEnrichments, _a;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0:
                item = itemAndEnrichments.item, data = itemAndEnrichments.data;
                layers = itemAndEnrichments.layers;
                layer = layers && getItemLayer(item, layers, options && options.layerId);
                if (!(layer && !layer.type)) return [3 /*break*/, 2];
                layerUrl = parseServiceUrl(item.url) + "/" + layer.id;
                getLayerOptions = Object.assign({ url: layerUrl }, options);
                return [4 /*yield*/, getLayer(getLayerOptions)];
            case 1:
                layer = _b.sent();
                layers = layers.map(function (unhydratedLayer) {
                    return unhydratedLayer.id === layer.id ? layer : unhydratedLayer;
                });
                _b.label = 2;
            case 2:
                if (!(layer && isLayerView(layer) && !data)) return [3 /*break*/, 4];
                // to store (at least part of) it's view definition in item data
                // it seems that most do not, but until we have a reliable signal
                // we just fetch the item data for all layer views
                return [4 /*yield*/, fetchItemEnrichments(item, ["data"], options)];
            case 3:
                // to store (at least part of) it's view definition in item data
                // it seems that most do not, but until we have a reliable signal
                // we just fetch the item data for all layer views
                _a = _b.sent();
                return [3 /*break*/, 5];
            case 4:
                _a = undefined;
                _b.label = 5;
            case 5:
                layerEnrichments = _a;
                return [2 /*return*/, __assign(__assign(__assign({}, itemAndEnrichments), layerEnrichments), { 
                        // merge error arrays
                        errors: maybeConcat([itemAndEnrichments.errors, layerEnrichments === null || layerEnrichments === void 0 ? void 0 : layerEnrichments.errors]), 
                        // Also remove once we stop supporting ArcGIS Servers below version 10.5
                        layers: layers })];
        }
    });
}); };
var fetchItemAndEnrichments = function (itemId, options) { return __awaiter(void 0, void 0, void 0, function () {
    var item, enrichmentsToFetch, enrichments;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, getItem(itemId, options)];
            case 1:
                item = _a.sent();
                // The Hub Application expects the item url of proxied CSVs to point to the
                // proxying feature service. Stabbing it on here maintains that consistency
                // and also helps us fetch and calculate the correct reference layer
                item.url = getProxyUrl(item, options) || item.url;
                enrichmentsToFetch = (options === null || options === void 0 ? void 0 : options.enrichments) || getContentEnrichments(item);
                return [4 /*yield*/, fetchItemEnrichments(item, enrichmentsToFetch, options)];
            case 2:
                enrichments = _a.sent();
                return [2 /*return*/, maybeFetchLayerEnrichments(__assign(__assign({}, enrichments), { item: item }), options)];
        }
    });
}); };
var fetchContentById = function (hubId, options) { return __awaiter(void 0, void 0, void 0, function () {
    var itemId, _a, item, itemEnrichments, specifiedLayerId, hubEnrichments, _b, layerId;
    return __generator(this, function (_c) {
        switch (_c.label) {
            case 0:
                itemId = parseDatasetId(hubId).itemId;
                return [4 /*yield*/, fetchItemAndEnrichments(itemId, options)];
            case 1:
                _a = _c.sent(), item = _a.item, itemEnrichments = __rest(_a, ["item"]);
                specifiedLayerId = options && options.layerId;
                if (!canUseHubApiForItem(item, options)) return [3 /*break*/, 3];
                return [4 /*yield*/, fetchHubEnrichmentsById(hubId, options)];
            case 2:
                _b = _c.sent();
                return [3 /*break*/, 4];
            case 3:
                _b = {};
                _c.label = 4;
            case 4:
                hubEnrichments = _b;
                layerId = hubEnrichments.layerId;
                // return a new content object composed from the item and enrichments we fetched
                return [2 /*return*/, composeContent(item, __assign(__assign(__assign({ requestOptions: options }, itemEnrichments), hubEnrichments), { 
                        // prefer specified layer id if any
                        layerId: isNil(specifiedLayerId) ? layerId : specifiedLayerId, 
                        // merge error arrays
                        errors: maybeConcat([itemEnrichments.errors, hubEnrichments.errors]) }))];
        }
    });
}); };
var fetchContentBySlug = function (fullyQualifiedSlug, options) { return __awaiter(void 0, void 0, void 0, function () {
    var hubEnrichments, itemId, layerId, _a, item, itemEnrichments, specifiedLayerId, _b;
    return __generator(this, function (_c) {
        switch (_c.label) {
            case 0: return [4 /*yield*/, fetchHubEnrichmentsBySlug(fullyQualifiedSlug, options)];
            case 1:
                hubEnrichments = _c.sent();
                itemId = hubEnrichments.itemId;
                layerId = hubEnrichments.layerId;
                return [4 /*yield*/, fetchItemAndEnrichments(itemId, options)];
            case 2:
                _a = _c.sent(), item = _a.item, itemEnrichments = __rest(_a, ["item"]);
                specifiedLayerId = options && options.layerId;
                if (!(!isNil(specifiedLayerId) && specifiedLayerId !== layerId)) return [3 /*break*/, 4];
                // we fetched Hub enrichments by slug for another record,
                // most likely the record for the parent service of this layer,
                // so we need to fetch them for the specified layer instead
                layerId = specifiedLayerId;
                _b = [__assign({}, hubEnrichments)];
                return [4 /*yield*/, fetchHubEnrichmentsById(itemId + "_" + layerId, options)];
            case 3:
                hubEnrichments = __assign.apply(void 0, _b.concat([(_c.sent())]));
                _c.label = 4;
            case 4: return [2 /*return*/, composeContent(item, __assign(__assign(__assign({ requestOptions: options }, itemEnrichments), hubEnrichments), { layerId: layerId, 
                    // Note that we are not extracting the slug for the specified layer.
                    // It seems that the old client composer code always populated the slug
                    // field with the slug that was passed into the function (typically the
                    // slug of the parent service). To maintain parity, we do the same here.
                    //
                    // TODO: should we prefer the slug of the fetched layer instead?
                    // return a new content object composed from the item and enrichments we fetched
                    slug: fullyQualifiedSlug, 
                    // merge error arrays
                    errors: maybeConcat([itemEnrichments.errors, hubEnrichments.errors]) }))];
        }
    });
}); };
var fetchContentRecordCount = function (content, requestOptions) { return __awaiter(void 0, void 0, void 0, function () {
    var url, viewDefinition, where, response, _a;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0:
                url = content.url, viewDefinition = content.viewDefinition;
                where = viewDefinition === null || viewDefinition === void 0 ? void 0 : viewDefinition.definitionExpression;
                _b.label = 1;
            case 1:
                _b.trys.push([1, 3, , 4]);
                return [4 /*yield*/, queryFeatures(__assign(__assign({}, requestOptions), { url: url,
                        where: where, returnCountOnly: true }))];
            case 2:
                response = _b.sent();
                return [2 /*return*/, response.count];
            case 3:
                _a = _b.sent();
                // swallow the error and return Infinity as a flag that the caller can act on
                // NOTE: this is what the -ui app currently expects, see:
                // https://github.com/ArcGIS/opendata-ui/blob/300601918eb2dee79a89314880541ecd60f21e68/packages/opendata-ui/app/utils/composer.js#L273-L279
                // however, we should probably push the error message into content.errors instead
                return [2 /*return*/, Infinity];
            case 4: return [2 /*return*/];
        }
    });
}); };
/**
 * Fetch enriched content from the Portal and Hub APIs.
 * @param identifier content slug or id
 * @param options Request options with additional options to control how the content or enrichments are fetched
 * @returns A content object composed of the backing item and enrichments
 *
 * ```js
 * import { fetchContent } from '@esri/hub-common'
 * // fetch content by slug
 * const content = await fetchContent('my-org::item-name')
 * ```
 */
export var fetchContent = function (identifier, options) { return __awaiter(void 0, void 0, void 0, function () {
    var content, _a, layer, type, _b, _c;
    return __generator(this, function (_d) {
        switch (_d.label) {
            case 0:
                if (!isSlug(identifier)) return [3 /*break*/, 2];
                return [4 /*yield*/, fetchContentBySlug(addContextToSlug(identifier, options === null || options === void 0 ? void 0 : options.siteOrgKey), options)];
            case 1:
                _a = _d.sent();
                return [3 /*break*/, 4];
            case 2: return [4 /*yield*/, fetchContentById(identifier, options)];
            case 3:
                _a = _d.sent();
                _d.label = 4;
            case 4:
                content = _a;
                layer = content.layer, type = content.type;
                _b = content;
                if (!(!!layer && hasFeatures(type))) return [3 /*break*/, 6];
                return [4 /*yield*/, fetchContentRecordCount(content, options)];
            case 5:
                _c = _d.sent();
                return [3 /*break*/, 7];
            case 6:
                _c = undefined;
                _d.label = 7;
            case 7:
                _b.recordCount = _c;
                return [2 /*return*/, content];
        }
    });
}); };
//# sourceMappingURL=fetch.js.map