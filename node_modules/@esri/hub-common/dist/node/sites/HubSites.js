"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.searchSites = exports.convertItemToSite = exports._fetchSite = exports.destroySite = exports.updateSite = exports.createSite = exports.ENTERPRISE_SITE_ITEM_TYPE = exports.HUB_SITE_ITEM_TYPE = void 0;
const arcgis_rest_portal_1 = require("@esri/arcgis-rest-portal");
const __1 = require("..");
const PropertyMapper_1 = require("../core/_internal/PropertyMapper");
const _internal_1 = require("./_internal");
const searchContentEntities_1 = require("../search/_internal/searchContentEntities");
exports.HUB_SITE_ITEM_TYPE = "Hub Site Application";
exports.ENTERPRISE_SITE_ITEM_TYPE = "Site Application";
/**
 * Default values of a IHubSite
 */
const DEFAULT_SITE = {
    name: "No title provided",
    tags: [],
    typeKeywords: ["Hub Site", "hubSite", "DELETEMESITE"],
    capabilities: [
        "api_explorer",
        "pages",
        "my_data",
        "social_logins",
        "json_chart_card",
        "document_iframes",
        "items_view",
        "app_page",
        "underlinedLinks",
        "globalNav",
        "socialSharing",
    ],
    catalog: {
        groups: [],
    },
    subdomain: "",
    defaultHostname: "",
    customHostname: "",
    clientId: "",
    map: null,
    feeds: {},
    pages: [],
    theme: null,
    contentViews: {
        sidePanelOpen: {
            app: true,
            map: true,
            dataset: true,
            document: true,
            feedback: true,
        },
    },
};
/**
 * Default values for a new HubSite Model
 */
const DEFAULT_SITE_MODEL = {
    item: {
        // type: intentionally left out as we need to
        // set that based on portal/enterprise
        title: "No Title Provided",
        description: "No Description Provided",
        snippet: "",
        tags: [],
        typeKeywords: ["Hub Site", "hubSite", "DELETEMESITE"],
        properties: {
            slug: "",
            orgUrlKey: "",
            defaultHostname: "",
            customHostname: "",
            clientId: "",
            subdomain: "",
            schemaVersion: 1.5,
        },
        url: "",
    },
    data: {
        catalog: {
            groups: [],
        },
        feeds: {},
        values: {
            title: "",
            defaultHostname: "",
            customHostname: "",
            subdomain: "",
            faviconUrl: "",
            uiVersion: "2.4",
            clientId: "",
            map: {
                basemaps: {},
            },
            defaultExtent: {},
            pages: [],
            theme: {},
            layout: {
                sections: [],
                header: {
                    component: {
                        name: "site-header",
                        settings: {
                            fullWidth: false,
                            iframeHeight: "150px",
                            iframeUrl: "",
                            links: [],
                            logoUrl: "",
                            title: "default site",
                            markdown: "",
                            headerType: "default",
                            schemaVersion: 3,
                            showLogo: true,
                            showTitle: true,
                            logo: {
                                display: {},
                                state: "valid",
                            },
                            shortTitle: "",
                            menuLinks: [],
                            socialLinks: {
                                facebook: {},
                                twitter: {},
                                instagram: {},
                                youtube: {},
                            },
                        },
                    },
                    showEditor: false,
                },
                footer: {
                    component: {
                        name: "site-footer",
                        settings: {
                            footerType: "none",
                            markdown: "",
                            schemaVersion: 2.1,
                        },
                    },
                    showEditor: false,
                },
            },
            contentViews: {
                sidePanelOpen: {
                    app: true,
                    map: true,
                    dataset: true,
                    document: true,
                    feedback: true,
                },
            },
        },
    },
};
/**
 * Returns an Array of IPropertyMap objects
 * We could define these directly, but since the
 * properties of IHubSite map directly to properties
 * on item or data, it's slightly less verbose to
 * generate the structure.
 * @returns
 */
function getSitePropertyMap() {
    const itemProps = [
        "created",
        "culture",
        "description",
        "extent",
        "id",
        "modified",
        "owner",
        "snippet",
        "tags",
        "typeKeywords",
        "url",
        "type",
    ];
    const map = [];
    itemProps.forEach((entry) => {
        map.push({ objectKey: entry, modelKey: `item.${entry}` });
    });
    const dataProps = ["catalog", "feeds"];
    dataProps.forEach((entry) => {
        map.push({ objectKey: entry, modelKey: `data.${entry}` });
    });
    const valueProps = [
        "pages",
        "theme",
        "capabilities",
        "subdomain",
        "defaultHostname",
        "customHostname",
        "clientId",
        "defaultExtent",
        "map",
        "telemetry",
        "headerSass",
    ];
    valueProps.forEach((entry) => {
        map.push({ objectKey: entry, modelKey: `data.values.${entry}` });
    });
    // Deeper/Indirect mappings
    map.push({
        objectKey: "slug",
        modelKey: "item.properties.slug",
    });
    map.push({
        objectKey: "orgUrlKey",
        modelKey: "item.properties.orgUrlKey",
    });
    map.push({
        objectKey: "name",
        modelKey: "item.title",
    });
    return map;
}
// TODO: Add OperationStack & Error Handling
/**
 * Create a new Hub Site
 *
 * Minimum properties are `name` and `org`
 * @param partialSite
 * @param requestOptions
 */
async function createSite(partialSite, requestOptions) {
    const site = Object.assign(Object.assign({}, DEFAULT_SITE), partialSite);
    const portal = requestOptions.portalSelf;
    // Set the type based on the environment we are working in
    site.type = requestOptions.isPortal
        ? exports.ENTERPRISE_SITE_ITEM_TYPE
        : exports.HUB_SITE_ITEM_TYPE;
    // Create a slug from the title if one is not passed in
    if (!site.slug) {
        site.slug = __1.constructSlug(site.name, site.orgUrlKey);
    }
    // Ensure slug is  unique
    // site.slug = await getUniqueSlug({ slug: site.slug }, requestOptions);
    // add slug to keywords
    site.typeKeywords = __1.setSlugKeyword(site.typeKeywords, site.slug);
    if (!site.subdomain) {
        site.subdomain = __1.slugify(site.name);
    }
    site.subdomain = await __1.ensureUniqueDomainName(site.subdomain, requestOptions);
    // Domains
    if (!requestOptions.isPortal) {
        // now that we know the subdomain is available, set the defaultHostname
        site.defaultHostname = `${site.subdomain}-${portal.urlKey}.${__1.stripProtocol(__1.getHubApiUrl(requestOptions))}`;
        // set the url
        site.url = `https://${site.customHostname ? site.customHostname : site.defaultHostname}`;
    }
    else {
        // Portal Sites use subdomain in hash based router
        site.typeKeywords.push(`hubsubdomain|${site.subdomain}`.toLowerCase());
        site.url = `${requestOptions.authentication.portal.replace(`/sharing/rest`, `/apps/sites`)}/#/${site.subdomain}`;
    }
    // Note:  We used to use adlib for this, but it's much harder to
    // use templates with typescript. i.e. you can't assign a string template
    // to a property defined as `IExtent` without using `as unknown as ...`
    // which basically removes typechecking
    site.orgUrlKey = portal.urlKey;
    // override only if not set...
    if (!site.theme) {
        site.theme = __1.getOrgDefaultTheme(portal);
    }
    if (!site.defaultExtent) {
        site.defaultExtent = portal.defaultExtent;
    }
    if (!site.culture) {
        site.culture = portal.culture;
    }
    // pull the basemap from portalSelf
    if (!__1.getProp(site, "map.basemaps.primary")) {
        __1.setProp("map.basemaps.primary", portal.defaultBasemap, site);
    }
    // Put the title into the header
    if (!__1.getProp(site, "layout.header.component.settings.title")) {
        __1.setProp("layout.header.component.settings.title", site.name, site);
    }
    // Now convert the IHubSite into an IModel
    const mapper = new PropertyMapper_1.PropertyMapper(getSitePropertyMap());
    let model = mapper.objectToModel(site, __1.cloneObject(DEFAULT_SITE_MODEL));
    // create the backing item
    model = await __1.createModel(model, requestOptions);
    // Register as an app
    const registration = await __1.registerSiteAsApplication(model, requestOptions);
    model.data.values.clientId = registration.client_id;
    // Register domains
    await __1.addSiteDomains(model, requestOptions);
    // update the model
    const updatedModel = await __1.updateModel(model, requestOptions);
    // convert the model into a IHubSite and return
    return mapper.modelToObject(updatedModel, {});
}
exports.createSite = createSite;
/**
 * Update a Hub Site
 *
 * This checks for and applies domain changes
 * @param site
 * @param requestOptions
 * @returns
 */
async function updateSite(site, requestOptions) {
    // Most of this work is done with an IModel, so first thing it to
    // convert IHubSite to model
    const mapper = new PropertyMapper_1.PropertyMapper(getSitePropertyMap());
    // applying the site onto the default model ensures that a minimum
    // set of properties exist, regardless what may have been done to
    // the site pojo
    const updatedModel = mapper.objectToModel(site, __1.cloneObject(DEFAULT_SITE_MODEL));
    // Fetch backing model from the portal
    const currentModel = await __1.getModel(site.id, requestOptions);
    // handle any domain changes
    await _internal_1.handleDomainChanges(updatedModel, currentModel, requestOptions);
    if (updatedModel.item.properties.slug !== currentModel.item.properties.slug) {
        // ensure slug to keywords
        updatedModel.item.typeKeywords = __1.setSlugKeyword(updatedModel.item.typeKeywords, updatedModel.item.properties.slug);
    }
    // merge the updated site onto the current model
    const modelToStore = mapper.objectToModel(site, currentModel);
    // update the model
    const updatedSiteModel = await __1.updateModel(modelToStore, requestOptions);
    // fetch updated model
    const updatedSite = mapper.modelToObject(updatedSiteModel, site);
    return updatedSite;
}
exports.updateSite = updateSite;
/**
 * Remove a Hub Site
 *
 * This simply removes the Site item, and it's associated domain records.
 * This does not remove any Teams/Groups or content associated with the
 * Site
 * @param id
 * @param requestOptions
 * @returns
 */
async function destroySite(id, requestOptions) {
    // For AGO we need to remove the domain records for the site
    if (!requestOptions.isPortal) {
        await __1.removeDomainsBySiteId(id, requestOptions);
    }
    // now we can remove the item
    const ro = Object.assign(Object.assign({}, requestOptions), { id });
    await arcgis_rest_portal_1.removeItem(ro);
    return;
}
exports.destroySite = destroySite;
/**
 * Returns site model given various kinds of identifier
 *
 * @param identifier - a site item ID, site hostname, enterprise site slug, or full site URL
 * @param requestOptions
 * @private // remove when we remove existing fetchSite function
 */
async function _fetchSite(identifier, requestOptions) {
    // get the model
    const model = await __1.fetchSiteModel(identifier, requestOptions);
    // convert to site
    const mapper = new PropertyMapper_1.PropertyMapper(getSitePropertyMap());
    const site = mapper.modelToObject(model, {});
    let token;
    if (requestOptions.authentication) {
        const us = requestOptions.authentication;
        token = us.token;
    }
    site.thumbnailUrl = __1.getItemThumbnailUrl(model.item, requestOptions, token);
    return site;
}
exports._fetchSite = _fetchSite;
/**
 * Convert a Hub Site Application item into a Hub Site, fetching any
 * additional information that may be required
 * @param item
 * @param auth
 * @returns
 */
async function convertItemToSite(item, requestOptions) {
    const model = await __1.fetchModelFromItem(item, requestOptions);
    const mapper = new PropertyMapper_1.PropertyMapper(getSitePropertyMap());
    let token;
    if (requestOptions.authentication) {
        const session = requestOptions.authentication;
        token = session.token;
    }
    const prj = mapper.modelToObject(model, {});
    prj.thumbnailUrl = __1.getItemThumbnailUrl(model.item, requestOptions, token);
    return prj;
}
exports.convertItemToSite = convertItemToSite;
/**
 * Search for Sites and get IHubSite results
 * @param filter
 * @param options
 * @returns
 */
async function searchSites(filter, options) {
    // Scope to Hub Sites
    const scopingFilter = {
        filterType: "content",
        type: "$site",
    };
    // merge filters
    const sitesFilter = __1.mergeContentFilter([scopingFilter, filter]);
    // delegate
    return searchContentEntities_1.searchContentEntities(sitesFilter, convertItemToSite, options);
}
exports.searchSites = searchSites;
//# sourceMappingURL=HubSites.js.map