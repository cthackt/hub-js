/**
 * The default merge function for merging aggregations. Simply sums the aggregations
 * @param valueOne the value of one aggregatiom
 * @param valueTwo the value of the second aggregation
 * @returns the sum of the two values
 */
const sumAggregations = (valueOne, valueTwo) => {
    return valueOne + valueTwo;
};
/**
 * Function to merge multiple aggregations results from different result sets. Explicitly assumed
 * that sets can contain overlapping aggregations that should be merged. Also explicitly assumed
 * that they can contain aggregation values that are undefined or null (0 is valid),
 * and/or contain entire aggregation result sets that are empty or falsey
 *
 * @param aggs a list of aggregation result sets from different requests/sources
 * @param mergeFunction a merge function used to merge aggregation values across result sets
 * @returns a list of merged aggregations
 */
export function mergeAggregations(aggs = [], mergeFunction = sumAggregations) {
    if (!Array.isArray(aggs) || aggs.length === 0) {
        return [];
    }
    const aggResultMapList = aggs.map((aggResultList) => _combineAggResultsToMap(aggResultList));
    const mergedMap = _createMergedMap(aggResultMapList, mergeFunction);
    return _convertMapToResult(mergedMap);
}
function _combineAggResultsToMap(aggResultList) {
    return aggResultList.reduce((aggResultMap, aggResult) => {
        const aggMap = _createAggMap(aggResult);
        if (Object.keys(aggMap).length > 0) {
            const lowercasedFieldName = aggResult.fieldName.toLowerCase();
            aggResultMap[lowercasedFieldName] = aggMap;
        }
        return aggResultMap;
    }, {});
}
function _createAggMap(aggResult) {
    const aggregations = aggResult.aggregations || [];
    return aggregations.reduce((map, agg) => {
        if (agg.value !== undefined && agg.value !== null) {
            const lowercasedLabel = agg.label.toLowerCase();
            map[lowercasedLabel] = agg.value;
        }
        return map;
    }, {});
}
function _createMergedMap(aggResultMapList, mergeFunction) {
    return aggResultMapList.reduce((mergedMap, map) => {
        Object.keys(map).forEach((fieldName) => {
            if (!mergedMap[fieldName]) {
                mergedMap[fieldName] = map[fieldName];
            }
            else {
                mergedMap[fieldName] = _mergeMaps(mergedMap[fieldName], map[fieldName], mergeFunction);
            }
        });
        return mergedMap;
    }, {});
}
function _mergeMaps(existingMap, newMap, mergeFunction) {
    const mergedMap = Object.assign(existingMap);
    Object.keys(newMap).forEach((label) => {
        if (!mergedMap[label]) {
            mergedMap[label] = newMap[label];
        }
        else {
            mergedMap[label] = mergeFunction(existingMap[label], newMap[label]);
        }
    });
    return mergedMap;
}
function _convertMapToResult(mergedMap) {
    return Object.keys(mergedMap).map(fieldName => {
        const aggregations = Object.keys(mergedMap[fieldName]).map((name) => {
            return {
                label: name,
                value: mergedMap[fieldName][name]
            };
        });
        return {
            fieldName,
            aggregations
        };
    });
}
//# sourceMappingURL=merge-aggregations.js.map