"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertToHubParams = void 0;
const content_1 = require("../../types/content");
const common_1 = require("./common");
const TERM_FIELD = "terms";
const VALID_CATALOG_PROPS = ["id", "orgid", "group", "initiativeid"];
// Necessary to map Portal API-supported properties to Hub Indexer Search API properties
const PROP_MAP = {
    group: "groupIds",
    title: "name",
    typekeywords: "typeKeywords",
    orgid: "orgId",
    initiativeid: "initiativeId",
};
// Necessary to map Portal API-supported values of properties to Hub Indexer Search API properties
const VALUE_MAP = {
    access: {
        org: "organization",
        shared: "team",
        private: "myself",
    },
};
/**
 * Converts the common request format of contentSearch to a format specific to the Hub V3 Search API
 * @param request - the IContentSearchRequest instance for searching
 */
function convertToHubParams(request) {
    const { termField, filterFields, catalogFields } = splitFilterTerms(request);
    const filter = Object.keys(filterFields).length
        ? processFilter(filterFields)
        : undefined;
    const catalog = Object.keys(catalogFields).length
        ? processCatalog(catalogFields)
        : undefined;
    const paging = processPage(request);
    return createSearchOptions({
        termField,
        filter,
        catalog,
        paging,
        options: request.options,
    });
}
exports.convertToHubParams = convertToHubParams;
function splitFilterTerms(request) {
    const filter = request.filter || {};
    return Object.keys(filter).reduce((filterObj, key) => {
        const hubKey = PROP_MAP[key] ? PROP_MAP[key] : key;
        if (isFilterATerm(key)) {
            filterObj.termField = filter[key];
        }
        else if (isFilterACatalogFilter(key)) {
            filterObj.catalogFields[hubKey] = filter[key];
        }
        else {
            filterObj.filterFields[hubKey] = filter[key];
        }
        return filterObj;
    }, { termField: undefined, filterFields: {}, catalogFields: {} });
}
function processFilter(filterFields) {
    return Object.keys(filterFields).reduce((filterObj, key) => {
        const clause = convertToHubFilterClause(key, filterFields[key]);
        if (clause) {
            filterObj[key] = clause;
        }
        return filterObj;
    }, {});
}
function processCatalog(catalogFields) {
    return Object.keys(catalogFields).reduce((catalogObj, key) => {
        const clause = convertToHubFilterClause(key, catalogFields[key]);
        if (clause) {
            catalogObj[key] = clause;
        }
        return catalogObj;
    }, {});
}
function processPage(request) {
    const options = request.options || {};
    return options.page;
}
function createSearchOptions(params) {
    const options = params.options || {};
    const sort = createSort(options.sortField, options.sortOrder);
    const agg = getAggregations(options.aggregations);
    const fields = getFields(options.fields);
    const searchParams = {
        q: params.termField || undefined,
        sort,
        filter: params.filter,
        catalog: params.catalog,
        page: params.paging && { key: params.paging },
        agg,
        fields,
    };
    return searchParams;
}
function convertToHubFilterClause(filterField, filterValue) {
    if (common_1.isFilterANonEmptyString(filterValue)) {
        return processArrayFilter(filterField, [filterValue]);
    }
    else if (common_1.isFilterAnArrayWithData(filterValue)) {
        return processArrayFilter(filterField, filterValue);
    }
    else if (common_1.isFilterFieldADateRange(filterField, filterValue)) {
        return processDateField(filterValue);
    }
    else {
        return processFieldFilter(filterValue);
    }
}
function processArrayFilter(field, filterArray) {
    const modifiedFilterValues = filterArray.map((filter) => {
        if (VALUE_MAP[field] && VALUE_MAP[field][filter]) {
            return VALUE_MAP[field][filter];
        }
        return filter;
    });
    return `any(${modifiedFilterValues.join(",")})`;
}
function processDateField(dateFilterValue) {
    const from = dateFilterValue.from || 0;
    const to = dateFilterValue.to || new Date().getTime();
    return `between(${convertDateEpochToString(from)},${convertDateEpochToString(to)})`;
}
function processFieldFilter(contentFilter) {
    if (!contentFilter || !common_1.isFilterAnArrayWithData(contentFilter.value)) {
        return undefined;
    }
    const operator = contentFilter.bool || content_1.IBooleanOperator.OR;
    const hubOperator = convertToHubOperator(operator);
    const filters = contentFilter.value;
    return `${hubOperator}(${filters.join(",")})`;
}
function convertDateEpochToString(epoch) {
    const date = new Date(epoch).toISOString();
    return date.substring(0, 10);
}
function convertToHubOperator(operator) {
    if (operator === content_1.IBooleanOperator.NOT) {
        return "not";
    }
    else if (operator === content_1.IBooleanOperator.AND) {
        return "all";
    }
    return "any";
}
function isFilterATerm(filterField) {
    return TERM_FIELD === filterField;
}
function isFilterACatalogFilter(filterField) {
    return VALID_CATALOG_PROPS.indexOf(filterField) >= 0;
}
function createSort(sortField, sortOrder) {
    if (!sortField || sortField.toLowerCase() === "relevance") {
        return undefined;
    }
    const hubSortField = PROP_MAP[sortField] ? PROP_MAP[sortField] : sortField;
    const order = sortOrder && sortOrder.toLowerCase() === "desc" ? "-" : "";
    return `${order}${hubSortField}`;
}
function getAggregations(aggregations) {
    return aggregations
        ? {
            fields: aggregations,
        }
        : undefined;
}
function getFields(fields) {
    return fields
        ? {
            datasets: fields,
        }
        : undefined;
}
//# sourceMappingURL=convert-request-to-hub-params.js.map