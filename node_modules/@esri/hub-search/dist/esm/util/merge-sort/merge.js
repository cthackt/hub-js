/**
 * k-way merge implementation that merges (and potentially sorts) k individually sorted arrays
 * based on the k-way merge algorithm (https://en.wikipedia.org/wiki/K-way_merge_algorithm)
 *
 * If a comparator function used to compare data is provided, a k-way merge sort is performed using
 * a Binary Heap implementation. Otherwise data from each input array is merged incrementally
 *
 * The returned object contains merged (and potentially sorted) data, as well as key-value
 * pairs that represent the index of a result set in the "data" parameter (the key) tied to how
 * many results (the value) of that result set were added to the final merged data array.
 * For example, if "data" represents an array of two result sets, with 3 and 5 results added to the final
 * result set, respectively, the returned object would be { data: [...], "0": 3, "1": 5 }
 *
 * @param data An array of result sets, each an array of type T
 * @param resultLimit the maximum number of merged results to return, defaults to 10
 * @param cmptr comparator function that takes in two instances of type T and returns a negative number if a is less than b, a positive if a is greater than b, 0 if equal
 * @param direction specifies whether data should be ordered ascending or descending
 * @returns list of results and key-value pairs indicating how many from each were added to returned data
 */
export function kMerge(data, resultLimit, cmptr, direction) {
    if (resultLimit === void 0) { resultLimit = 10; }
    var results = cmptr
        ? kMergeSort(data, cmptr, direction, resultLimit)
        : kMergeDefault(data, resultLimit);
    // Zero-fill any result set that did not have any results added to final
    for (var i = 0; i < data.length; i++) {
        if (!results[i.toString()]) {
            results[i.toString()] = 0;
        }
    }
    return results;
}
function kMergeDefault(data, resultLimit) {
    var results = {
        data: []
    };
    var totalDataRemaining = _getRemainingResults(data);
    var _loop_1 = function () {
        var _a;
        var dataToAdd = [];
        data.forEach(function (dataArr, index) {
            if (dataArr.length > 0 &&
                _canDataBeAdded(dataToAdd, results.data, resultLimit)) {
                results[index.toString()] = results[index.toString()]
                    ? results[index.toString()] + 1
                    : 1;
                dataToAdd.push(dataArr.splice(0, 1)[0]);
            }
        });
        (_a = results.data).push.apply(_a, dataToAdd);
        totalDataRemaining = _getRemainingResults(data);
    };
    while (!_hasReachedLimit(results.data.length, resultLimit) &&
        totalDataRemaining > 0) {
        _loop_1();
    }
    return results;
}
function kMergeSort(data, cmptr, direction, resultLimit) {
    var nodes = data.map(function (datum, index) { return ({ data: datum, label: index.toString() }); });
    var heap = new BinaryHeap(nodes, cmptr, direction);
    var results = {
        data: []
    };
    while (results.data.length < resultLimit && heap.length() > 0) {
        var node = heap.remove();
        if (node.data.length > 0) {
            results[node.label] = results[node.label] ? results[node.label] + 1 : 1;
            results.data.push(node.data.splice(0, 1)[0]);
            heap.insert(node);
        }
    }
    return results;
}
function _getRemainingResults(data) {
    return data.reduce(function (length, arr) {
        return length + arr.length;
    }, 0);
}
function _hasReachedLimit(results, resultLimit) {
    return results - resultLimit >= 0;
}
function _canDataBeAdded(dataToAdd, resultsAdded, resultLimit) {
    return resultsAdded.length + dataToAdd.length < resultLimit;
}
/**
 * Binary Heap Implementation that implements the 'insert' and 'remove' methods
 * of the IBinaryHeap interface. Example use is for k-way merge sorting of k sorted arrays.
 * Performance is O(n log n) for initialization (could be further optimized), O(log n) for insertion and O(log n) for deletion
 *
 * @param nodes An array of INode objects of type T. If undefined or null are explicitly provided it defaults to empty array
 * @param cmptr comparator function that takes in two instances of type T and returns a number to determine sorting order
 * @param direction A HeapDirection that determines if heap should be min ("ASC") or max ("DESC") implementation
 */
var BinaryHeap = /** @class */ (function () {
    function BinaryHeap(nodes, cmptr, direction) {
        if (direction === void 0) { direction = "ASC"; }
        this._validate({ cmptr: cmptr, direction: direction });
        this._comparator = cmptr;
        this._direction = direction;
        this._initialize(nodes);
    }
    /**
     * Inserts node into binary heap
     * @param node
     */
    BinaryHeap.prototype.insert = function (node) {
        if (!this._hasData(node)) {
            return;
        }
        this._nodes.push(node);
        var currIndex = this.length() - 1;
        var parentIndex = this._getParentIndex(currIndex);
        while (this._shouldSwap(parentIndex, currIndex)) {
            this._swap(parentIndex, currIndex);
            currIndex = parentIndex;
            parentIndex = this._getParentIndex(currIndex);
        }
    };
    /**
     * Removes either the minimum or the maximum node, depending on heap implementation
     * @returns the min/max node or null if heap is empty.
     */
    BinaryHeap.prototype.remove = function () {
        if (this.length() === 0)
            return null;
        this._swap(0, this.length() - 1);
        var node = this._nodes.pop();
        this._siftDown(0);
        return node;
    };
    /**
     * Returns number of nodes in heap
     * @returns number of nodes
     */
    BinaryHeap.prototype.length = function () {
        return this._nodes.length;
    };
    /**
     * Returns a readonly version of the heap as an array
     * @returns Readonly array representation of the heap
     */
    BinaryHeap.prototype.heap = function () {
        return this._nodes;
    };
    BinaryHeap.prototype._initialize = function (nodes) {
        this._nodes = [];
        if (!nodes || nodes.length === 0) {
            return;
        }
        for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
            var node = nodes_1[_i];
            this.insert(node);
        }
    };
    BinaryHeap.prototype._siftDown = function (index) {
        var _a;
        var _b = this._getChildIndices(index), childOne = _b[0], childTwo = _b[1];
        var childIndexToSwap = this._shouldSwap(childOne, childTwo)
            ? childTwo
            : childOne;
        while (!this._isInvalidIndex(childIndexToSwap) &&
            this._shouldSwap(index, childIndexToSwap)) {
            this._swap(index, childIndexToSwap);
            index = childIndexToSwap;
            _a = this._getChildIndices(index), childOne = _a[0], childTwo = _a[1];
            childIndexToSwap = this._shouldSwap(childOne, childTwo)
                ? childTwo
                : childOne;
        }
    };
    BinaryHeap.prototype._getParentIndex = function (index) {
        return Math.trunc((index - 1) / 2);
    };
    BinaryHeap.prototype._getChildIndices = function (index) {
        return [index * 2 + 1, index * 2 + 2];
    };
    BinaryHeap.prototype._shouldSwap = function (lowerIndex, higherIndex) {
        if (this._isInvalidIndex(lowerIndex) || this._isInvalidIndex(higherIndex)) {
            return false;
        }
        return ((this._greaterThan(lowerIndex, higherIndex) &&
            this._direction === "ASC") ||
            (this._lessThan(lowerIndex, higherIndex) && this._direction === "DESC"));
    };
    BinaryHeap.prototype._isInvalidIndex = function (index) {
        return index < 0 || index >= this.length();
    };
    BinaryHeap.prototype._lessThan = function (lowerIndex, higherIndex) {
        return (this._comparator(this._nodes[lowerIndex].data, this._nodes[higherIndex].data) < 0);
    };
    BinaryHeap.prototype._greaterThan = function (lowerIndex, higherIndex) {
        return (this._comparator(this._nodes[lowerIndex].data, this._nodes[higherIndex].data) > 0);
    };
    BinaryHeap.prototype._hasData = function (node) {
        return node && node.data !== undefined && node.data !== null;
    };
    BinaryHeap.prototype._swap = function (one, two) {
        if (one === two)
            return;
        var oneCopy = this._nodes[one];
        this._nodes[one] = this._nodes[two];
        this._nodes[two] = oneCopy;
    };
    BinaryHeap.prototype._validate = function (args) {
        if (!args.cmptr) {
            throw new Error("Comparator function must be defined");
        }
        if (!args.direction) {
            throw new Error("Provided heap direction is invalid");
        }
    };
    return BinaryHeap;
}());
export { BinaryHeap };
//# sourceMappingURL=merge.js.map