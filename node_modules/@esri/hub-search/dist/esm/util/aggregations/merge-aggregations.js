/**
 * The default merge function for merging aggregations. Simply sums the aggregations
 * @param valueOne the value of one aggregatiom
 * @param valueTwo the value of the second aggregation
 * @returns the sum of the two values
 */
var sumAggregations = function (valueOne, valueTwo) {
    return valueOne + valueTwo;
};
/**
 * Function to merge multiple aggregations results from different result sets. Explicitly assumed
 * that sets can contain overlapping aggregations that should be merged. Also explicitly assumed
 * that they can contain aggregation values that are undefined or null (0 is valid),
 * and/or contain entire aggregation result sets that are empty or falsey
 *
 * @param aggs a list of aggregation result sets from different requests/sources
 * @param mergeFunction a merge function used to merge aggregation values across result sets
 * @returns a list of merged aggregations
 */
export function mergeAggregations(aggs, mergeFunction) {
    if (aggs === void 0) { aggs = []; }
    if (mergeFunction === void 0) { mergeFunction = sumAggregations; }
    if (!Array.isArray(aggs) || aggs.length === 0) {
        return [];
    }
    var aggResultMapList = aggs.map(function (aggResultList) {
        return _combineAggResultsToMap(aggResultList);
    });
    var mergedMap = _createMergedMap(aggResultMapList, mergeFunction);
    return _convertMapToResult(mergedMap);
}
function _combineAggResultsToMap(aggResultList) {
    return aggResultList.reduce(function (aggResultMap, aggResult) {
        var aggMap = _createAggMap(aggResult);
        if (Object.keys(aggMap).length > 0) {
            var lowercasedFieldName = aggResult.fieldName.toLowerCase();
            aggResultMap[lowercasedFieldName] = aggMap;
        }
        return aggResultMap;
    }, {});
}
function _createAggMap(aggResult) {
    var aggregations = aggResult.aggregations || [];
    return aggregations.reduce(function (map, agg) {
        if (agg.value !== undefined && agg.value !== null) {
            var lowercasedLabel = agg.label.toLowerCase();
            map[lowercasedLabel] = agg.value;
        }
        return map;
    }, {});
}
function _createMergedMap(aggResultMapList, mergeFunction) {
    return aggResultMapList.reduce(function (mergedMap, map) {
        Object.keys(map).forEach(function (fieldName) {
            if (!mergedMap[fieldName]) {
                mergedMap[fieldName] = map[fieldName];
            }
            else {
                mergedMap[fieldName] = _mergeMaps(mergedMap[fieldName], map[fieldName], mergeFunction);
            }
        });
        return mergedMap;
    }, {});
}
function _mergeMaps(existingMap, newMap, mergeFunction) {
    var mergedMap = Object.assign(existingMap);
    Object.keys(newMap).forEach(function (label) {
        if (!mergedMap[label]) {
            mergedMap[label] = newMap[label];
        }
        else {
            mergedMap[label] = mergeFunction(existingMap[label], newMap[label]);
        }
    });
    return mergedMap;
}
function _convertMapToResult(mergedMap) {
    return Object.keys(mergedMap).map(function (fieldName) {
        var aggregations = Object.keys(mergedMap[fieldName]).map(function (name) {
            return {
                label: name,
                value: mergedMap[fieldName][name]
            };
        });
        return {
            fieldName: fieldName,
            aggregations: aggregations
        };
    });
}
//# sourceMappingURL=merge-aggregations.js.map