import { getProp } from "@esri/hub-common";
/**
 * Url-encoding of search params. This function is generic enough to encode a deeply nested object
 * ```
 * Example:
 * Input: { a: { b: 2 }, c: 3 }
 * Output: 'a[b]=2&c=3'
 * ```
 * @param {Any} params (query params from hub indexer)
 * @returns {String}
 */
export function encodeParams(params) {
    if (params === void 0) { params = {}; }
    // get raw paths
    var paths = getPaths(params);
    var flatPaths = paths.filter(function (path) {
        return typeof getProp(params, path.join(".")) !== "object";
    });
    var parts = [];
    // for each nested path, we want to surround it with `[]`
    // i.e. if a path is like ['a', 'b'], we want encoding as 'a[b]=2' given the input object { a: { b: 2 }, c: 3 }
    flatPaths.forEach(function (path) {
        var str = "";
        for (var i = 0; i < path.length; i++) {
            if (i === 0) {
                str += path[i];
            }
            else {
                str += "[" + path[i] + "]";
            }
        }
        var right = encodeURIComponent(getProp(params, path.join(".")) || "");
        var left = encodeURIComponent(str);
        if (right) {
            parts.push(left + "=" + right);
        }
        return str;
    });
    var serialized = parts.join("&");
    return serialized;
}
/**
 * Get all paths to properties of an object as an array of arrays
 * where each array is a path to a property in the nested object
 * ```
 * Example:
 * Input: { a: { b: 2 }, c: 3 }
 * Output: [['a'], ['a', 'b'], ['c']]
 * ```
 * @param {Any} root the input object
 * @returns {String}
 */
export function getPaths(root) {
    if (root === void 0) { root = {}; }
    var paths = [];
    var nodes = [
        {
            obj: root,
            path: []
        }
    ];
    var _loop_1 = function () {
        var n = nodes.pop();
        Object.keys(n.obj).forEach(function (k) {
            if (typeof n.obj[k] === "object") {
                var path = n.path.concat(k);
                paths.push(path);
                nodes.unshift({
                    obj: n.obj[k],
                    path: path
                });
            }
            else {
                paths.push(n.path.concat(k));
            }
        });
    };
    while (nodes.length > 0) {
        _loop_1();
    }
    return paths;
}
//# sourceMappingURL=encode-params.js.map