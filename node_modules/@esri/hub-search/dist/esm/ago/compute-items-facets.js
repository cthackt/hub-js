import { __assign, __awaiter, __generator } from "tslib";
import { getProp } from "@esri/hub-common";
import { format, hasApiAgg, collectionAgg, downloadableAgg, flattenCategories } from "./helpers/aggs";
import { getItems } from "./get-items";
// these custom aggs are based on a field that are not supported by AGO aggregations
var customAggsNotSupportedByAgo = ["downloadable"];
// these custom aggs are based on a field that are supported by AGO aggregations
var customAggsSupportedByAgo = ["hasApi", "collection"];
var customAggsFunctions = {
    downloadable: downloadableAgg,
    hasApi: hasApiAgg,
    collection: collectionAgg
};
/**
 * Calculate item facets based on ago aggregations and/or compute custom aggregations not supported by AGO
 *
 * @param {any} agoAggregations aggregations from AGO
 * @param {ISearchParams} params search params
 * @param {String} token AGO token to make a search if calculating custom aggs like downloadable
 * @param {String} portal AGO portal against which search is being done
 * @param {UserSession} authentication UserSession object
 * @returns {Promise<any>}
 */
export function computeItemsFacets(agoAggregations, // aggregations from ago search that ago supports by default
params, // query params are needed to another search for custom facets
token, portal, authentication) {
    if (agoAggregations === void 0) { agoAggregations = { counts: Array() }; }
    return __awaiter(this, void 0, void 0, function () {
        var aggFields, aggs, customAggs, facets1, paramsCopy, response_1, facets2, facets3, computedFacets;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    aggFields = getProp(params, "agg.fields");
                    aggs = aggFields ? aggFields.split(",") : [];
                    customAggs = intersection(aggs, customAggsNotSupportedByAgo);
                    facets1 = {};
                    if (!(customAggs.length > 0)) return [3 /*break*/, 2];
                    paramsCopy = __assign(__assign({}, params), { start: 1, num: 100 });
                    paramsCopy.agg = {};
                    return [4 /*yield*/, getItems(paramsCopy, token, portal, authentication)];
                case 1:
                    response_1 = _a.sent();
                    customAggs.forEach(function (customAgg) {
                        var rawCounts = customAggsFunctions[customAgg](response_1);
                        facets1 = __assign(__assign({}, facets1), format(rawCounts));
                    });
                    _a.label = 2;
                case 2:
                    facets2 = agoAggregations.counts.reduce(function (formattedAggs, agg) {
                        formattedAggs[agg.fieldName] = agg.fieldValues.map(function (fieldVal) {
                            return {
                                key: fieldVal.value,
                                docCount: fieldVal.count
                            };
                        });
                        return formattedAggs;
                    }, {});
                    // 3. for custom aggs that are based on some field included in ago aggs
                    customAggs = intersection(aggs, customAggsSupportedByAgo);
                    facets3 = {};
                    if (customAggs.length > 0) {
                        customAggs.forEach(function (customAgg) {
                            var rawCounts = __assign({}, customAggsFunctions[customAgg](agoAggregations));
                            facets3 = __assign(__assign({}, facets3), format(rawCounts));
                        });
                    }
                    computedFacets = __assign(__assign(__assign({}, facets1), facets2), facets3);
                    // 4. format categories facet
                    if (computedFacets.categories) {
                        computedFacets.categories = flattenCategories(computedFacets.categories);
                    }
                    return [2 /*return*/, computedFacets];
            }
        });
    });
}
function intersection(arr1, arr2) {
    return arr1.filter(function (val) { return arr2.indexOf(val) !== -1; });
}
//# sourceMappingURL=compute-items-facets.js.map