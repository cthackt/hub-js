import { IBooleanOperator, } from "../../types/content";
import { isFilterAnArrayWithData, isFilterANonEmptyString, isFilterFieldADateRange, } from "./common";
var TERM_FIELD = "terms";
var VALID_CATALOG_PROPS = ["id", "orgid", "group", "initiativeid"];
// Necessary to map Portal API-supported properties to Hub Indexer Search API properties
var PROP_MAP = {
    group: "groupIds",
    title: "name",
    typekeywords: "typeKeywords",
    orgid: "orgId",
    initiativeid: "initiativeId",
};
// Necessary to map Portal API-supported values of properties to Hub Indexer Search API properties
var VALUE_MAP = {
    access: {
        org: "organization",
        shared: "team",
        private: "myself",
    },
};
/**
 * Converts the common request format of contentSearch to a format specific to the Hub V3 Search API
 * @param request - the IContentSearchRequest instance for searching
 */
export function convertToHubParams(request) {
    var _a = splitFilterTerms(request), termField = _a.termField, filterFields = _a.filterFields, catalogFields = _a.catalogFields;
    var filter = Object.keys(filterFields).length
        ? processFilter(filterFields)
        : undefined;
    var catalog = Object.keys(catalogFields).length
        ? processCatalog(catalogFields)
        : undefined;
    var paging = processPage(request);
    return createSearchOptions({
        termField: termField,
        filter: filter,
        catalog: catalog,
        paging: paging,
        options: request.options,
    });
}
function splitFilterTerms(request) {
    var filter = request.filter || {};
    return Object.keys(filter).reduce(function (filterObj, key) {
        var hubKey = PROP_MAP[key] ? PROP_MAP[key] : key;
        if (isFilterATerm(key)) {
            filterObj.termField = filter[key];
        }
        else if (isFilterACatalogFilter(key)) {
            filterObj.catalogFields[hubKey] = filter[key];
        }
        else {
            filterObj.filterFields[hubKey] = filter[key];
        }
        return filterObj;
    }, { termField: undefined, filterFields: {}, catalogFields: {} });
}
function processFilter(filterFields) {
    return Object.keys(filterFields).reduce(function (filterObj, key) {
        var clause = convertToHubFilterClause(key, filterFields[key]);
        if (clause) {
            filterObj[key] = clause;
        }
        return filterObj;
    }, {});
}
function processCatalog(catalogFields) {
    return Object.keys(catalogFields).reduce(function (catalogObj, key) {
        var clause = convertToHubFilterClause(key, catalogFields[key]);
        if (clause) {
            catalogObj[key] = clause;
        }
        return catalogObj;
    }, {});
}
function processPage(request) {
    var options = request.options || {};
    return options.page;
}
function createSearchOptions(params) {
    var options = params.options || {};
    var sort = createSort(options.sortField, options.sortOrder);
    var agg = getAggregations(options.aggregations);
    var fields = getFields(options.fields);
    var searchParams = {
        q: params.termField || undefined,
        sort: sort,
        filter: params.filter,
        catalog: params.catalog,
        page: params.paging && { key: params.paging },
        agg: agg,
        fields: fields,
    };
    return searchParams;
}
function convertToHubFilterClause(filterField, filterValue) {
    if (isFilterANonEmptyString(filterValue)) {
        return processArrayFilter(filterField, [filterValue]);
    }
    else if (isFilterAnArrayWithData(filterValue)) {
        return processArrayFilter(filterField, filterValue);
    }
    else if (isFilterFieldADateRange(filterField, filterValue)) {
        return processDateField(filterValue);
    }
    else {
        return processFieldFilter(filterValue);
    }
}
function processArrayFilter(field, filterArray) {
    var modifiedFilterValues = filterArray.map(function (filter) {
        if (VALUE_MAP[field] && VALUE_MAP[field][filter]) {
            return VALUE_MAP[field][filter];
        }
        return filter;
    });
    return "any(" + modifiedFilterValues.join(",") + ")";
}
function processDateField(dateFilterValue) {
    var from = dateFilterValue.from || 0;
    var to = dateFilterValue.to || new Date().getTime();
    return "between(" + convertDateEpochToString(from) + "," + convertDateEpochToString(to) + ")";
}
function processFieldFilter(contentFilter) {
    if (!contentFilter || !isFilterAnArrayWithData(contentFilter.value)) {
        return undefined;
    }
    var operator = contentFilter.bool || IBooleanOperator.OR;
    var hubOperator = convertToHubOperator(operator);
    var filters = contentFilter.value;
    return hubOperator + "(" + filters.join(",") + ")";
}
function convertDateEpochToString(epoch) {
    var date = new Date(epoch).toISOString();
    return date.substring(0, 10);
}
function convertToHubOperator(operator) {
    if (operator === IBooleanOperator.NOT) {
        return "not";
    }
    else if (operator === IBooleanOperator.AND) {
        return "all";
    }
    return "any";
}
function isFilterATerm(filterField) {
    return TERM_FIELD === filterField;
}
function isFilterACatalogFilter(filterField) {
    return VALID_CATALOG_PROPS.indexOf(filterField) >= 0;
}
function createSort(sortField, sortOrder) {
    if (!sortField || sortField.toLowerCase() === "relevance") {
        return undefined;
    }
    var hubSortField = PROP_MAP[sortField] ? PROP_MAP[sortField] : sortField;
    var order = sortOrder && sortOrder.toLowerCase() === "desc" ? "-" : "";
    return "" + order + hubSortField;
}
function getAggregations(aggregations) {
    return aggregations
        ? {
            fields: aggregations,
        }
        : undefined;
}
function getFields(fields) {
    return fields
        ? {
            datasets: fields,
        }
        : undefined;
}
//# sourceMappingURL=convert-request-to-hub-params.js.map