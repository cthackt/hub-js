/* @preserve
 * @esri/hub-search - v9.32.0 - Wed May 18 2022 18:25:56 GMT+0000 (Coordinated Universal Time)
 * Copyright (c) 2022 Environmental Systems Research Institute, Inc.
 * Apache-2.0
 */

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@esri/hub-common')) :
    typeof define === 'function' && define.amd ? define(['exports', '@esri/hub-common'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.arcgisHub = global.arcgisHub || {}, global.arcgisHub));
})(this, (function (exports, hubCommon) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    /* Copyright (c) 2017 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * Checks parameters to see if we should use FormData to send the request
     * @param params The object whose keys will be encoded.
     * @return A boolean indicating if FormData will be required.
     */
    function requiresFormData(params) {
        return Object.keys(params).some(function (key) {
            var value = params[key];
            if (!value) {
                return false;
            }
            if (value && value.toParam) {
                value = value.toParam();
            }
            var type = value.constructor.name;
            switch (type) {
                case "Array":
                    return false;
                case "Object":
                    return false;
                case "Date":
                    return false;
                case "Function":
                    return false;
                case "Boolean":
                    return false;
                case "String":
                    return false;
                case "Number":
                    return false;
                default:
                    return true;
            }
        });
    }
    /**
     * Converts parameters to the proper representation to send to the ArcGIS REST API.
     * @param params The object whose keys will be encoded.
     * @return A new object with properly encoded values.
     */
    function processParams(params) {
        var newParams = {};
        Object.keys(params).forEach(function (key) {
            var _a, _b;
            var param = params[key];
            if (param && param.toParam) {
                param = param.toParam();
            }
            if (!param &&
                param !== 0 &&
                typeof param !== "boolean" &&
                typeof param !== "string") {
                return;
            }
            var type = param.constructor.name;
            var value;
            // properly encodes objects, arrays and dates for arcgis.com and other services.
            // ported from https://github.com/Esri/esri-leaflet/blob/master/src/Request.js#L22-L30
            // also see https://github.com/Esri/arcgis-rest-js/issues/18:
            // null, undefined, function are excluded. If you want to send an empty key you need to send an empty string "".
            switch (type) {
                case "Array":
                    // Based on the first element of the array, classify array as an array of arrays, an array of objects
                    // to be stringified, or an array of non-objects to be comma-separated
                    // eslint-disable-next-line no-case-declarations
                    var firstElementType = (_b = (_a = param[0]) === null || _a === void 0 ? void 0 : _a.constructor) === null || _b === void 0 ? void 0 : _b.name;
                    value =
                        firstElementType === "Array" ? param : // pass thru array of arrays
                            firstElementType === "Object" ? JSON.stringify(param) : // stringify array of objects
                                param.join(","); // join other types of array elements
                    break;
                case "Object":
                    value = JSON.stringify(param);
                    break;
                case "Date":
                    value = param.valueOf();
                    break;
                case "Function":
                    value = null;
                    break;
                case "Boolean":
                    value = param + "";
                    break;
                default:
                    value = param;
                    break;
            }
            if (value || value === 0 || typeof value === "string" || Array.isArray(value)) {
                newParams[key] = value;
            }
        });
        return newParams;
    }

    /* Copyright (c) 2017 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * Encodes keys and parameters for use in a URL's query string.
     *
     * @param key Parameter's key
     * @param value Parameter's value
     * @returns Query string with key and value pairs separated by "&"
     */
    function encodeParam(key, value) {
        // For array of arrays, repeat key=value for each element of containing array
        if (Array.isArray(value) && value[0] && Array.isArray(value[0])) {
            return value.map(function (arrayElem) { return encodeParam(key, arrayElem); }).join("&");
        }
        return encodeURIComponent(key) + "=" + encodeURIComponent(value);
    }
    /**
     * Encodes the passed object as a query string.
     *
     * @param params An object to be encoded.
     * @returns An encoded query string.
     */
    function encodeQueryString(params) {
        var newParams = processParams(params);
        return Object.keys(newParams)
            .map(function (key) {
            return encodeParam(key, newParams[key]);
        })
            .join("&");
    }

    /* Copyright (c) 2017 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * Encodes parameters in a [FormData](https://developer.mozilla.org/en-US/docs/Web/API/FormData) object in browsers or in a [FormData](https://github.com/form-data/form-data) in Node.js
     *
     * @param params An object to be encoded.
     * @returns The complete [FormData](https://developer.mozilla.org/en-US/docs/Web/API/FormData) object.
     */
    function encodeFormData(params, forceFormData) {
        // see https://github.com/Esri/arcgis-rest-js/issues/499 for more info.
        var useFormData = requiresFormData(params) || forceFormData;
        var newParams = processParams(params);
        if (useFormData) {
            var formData_1 = new FormData();
            Object.keys(newParams).forEach(function (key) {
                if (typeof Blob !== "undefined" && newParams[key] instanceof Blob) {
                    /* To name the Blob:
                     1. look to an alternate request parameter called 'fileName'
                     2. see if 'name' has been tacked onto the Blob manually
                     3. if all else fails, use the request parameter
                    */
                    var filename = newParams["fileName"] || newParams[key].name || key;
                    formData_1.append(key, newParams[key], filename);
                }
                else {
                    formData_1.append(key, newParams[key]);
                }
            });
            return formData_1;
        }
        else {
            return encodeQueryString(params);
        }
    }

    /* Copyright (c) 2017 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    // TypeScript 2.1 no longer allows you to extend built in types. See https://github.com/Microsoft/TypeScript/issues/12790#issuecomment-265981442
    // and https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work
    //
    // This code is from MDN https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Custom_Error_Types.
    var ArcGISRequestError = /** @class */ (function () {
        /**
         * Create a new `ArcGISRequestError`  object.
         *
         * @param message - The error message from the API
         * @param code - The error code from the API
         * @param response - The original response from the API that caused the error
         * @param url - The original url of the request
         * @param options - The original options and parameters of the request
         */
        function ArcGISRequestError(message, code, response, url, options) {
            message = message || "UNKNOWN_ERROR";
            code = code || "UNKNOWN_ERROR_CODE";
            this.name = "ArcGISRequestError";
            this.message =
                code === "UNKNOWN_ERROR_CODE" ? message : code + ": " + message;
            this.originalMessage = message;
            this.code = code;
            this.response = response;
            this.url = url;
            this.options = options;
        }
        return ArcGISRequestError;
    }());
    ArcGISRequestError.prototype = Object.create(Error.prototype);
    ArcGISRequestError.prototype.constructor = ArcGISRequestError;

    /* Copyright (c) 2017-2018 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * Method used internally to surface messages to developers.
     */
    function warn(message) {
        if (console && console.warn) {
            console.warn.apply(console, [message]);
        }
    }

    /* Copyright (c) 2017-2018 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    var NODEJS_DEFAULT_REFERER_HEADER = "@esri/arcgis-rest-js";
    var DEFAULT_ARCGIS_REQUEST_OPTIONS = {
        httpMethod: "POST",
        params: {
            f: "json",
        },
    };
    var ArcGISAuthError = /** @class */ (function (_super) {
        __extends(ArcGISAuthError, _super);
        /**
         * Create a new `ArcGISAuthError`  object.
         *
         * @param message - The error message from the API
         * @param code - The error code from the API
         * @param response - The original response from the API that caused the error
         * @param url - The original url of the request
         * @param options - The original options of the request
         */
        function ArcGISAuthError(message, code, response, url, options) {
            if (message === void 0) { message = "AUTHENTICATION_ERROR"; }
            if (code === void 0) { code = "AUTHENTICATION_ERROR_CODE"; }
            var _this = _super.call(this, message, code, response, url, options) || this;
            _this.name = "ArcGISAuthError";
            _this.message =
                code === "AUTHENTICATION_ERROR_CODE" ? message : code + ": " + message;
            return _this;
        }
        ArcGISAuthError.prototype.retry = function (getSession, retryLimit) {
            var _this = this;
            if (retryLimit === void 0) { retryLimit = 3; }
            var tries = 0;
            var retryRequest = function (resolve, reject) {
                getSession(_this.url, _this.options)
                    .then(function (session) {
                    var newOptions = __assign(__assign({}, _this.options), { authentication: session });
                    tries = tries + 1;
                    return request(_this.url, newOptions);
                })
                    .then(function (response) {
                    resolve(response);
                })
                    .catch(function (e) {
                    if (e.name === "ArcGISAuthError" && tries < retryLimit) {
                        retryRequest(resolve, reject);
                    }
                    else if (e.name === "ArcGISAuthError" && tries >= retryLimit) {
                        reject(_this);
                    }
                    else {
                        reject(e);
                    }
                });
            };
            return new Promise(function (resolve, reject) {
                retryRequest(resolve, reject);
            });
        };
        return ArcGISAuthError;
    }(ArcGISRequestError));
    /**
     * Checks for errors in a JSON response from the ArcGIS REST API. If there are no errors, it will return the `data` passed in. If there is an error, it will throw an `ArcGISRequestError` or `ArcGISAuthError`.
     *
     * @param data The response JSON to check for errors.
     * @param url The url of the original request
     * @param params The parameters of the original request
     * @param options The options of the original request
     * @returns The data that was passed in the `data` parameter
     */
    function checkForErrors(response, url, params, options, originalAuthError) {
        // this is an error message from billing.arcgis.com backend
        if (response.code >= 400) {
            var message = response.message, code = response.code;
            throw new ArcGISRequestError(message, code, response, url, options);
        }
        // error from ArcGIS Online or an ArcGIS Portal or server instance.
        if (response.error) {
            var _a = response.error, message = _a.message, code = _a.code, messageCode = _a.messageCode;
            var errorCode = messageCode || code || "UNKNOWN_ERROR_CODE";
            if (code === 498 ||
                code === 499 ||
                messageCode === "GWM_0003" ||
                (code === 400 && message === "Unable to generate token.")) {
                if (originalAuthError) {
                    throw originalAuthError;
                }
                else {
                    throw new ArcGISAuthError(message, errorCode, response, url, options);
                }
            }
            throw new ArcGISRequestError(message, errorCode, response, url, options);
        }
        // error from a status check
        if (response.status === "failed" || response.status === "failure") {
            var message = void 0;
            var code = "UNKNOWN_ERROR_CODE";
            try {
                message = JSON.parse(response.statusMessage).message;
                code = JSON.parse(response.statusMessage).code;
            }
            catch (e) {
                message = response.statusMessage || response.message;
            }
            throw new ArcGISRequestError(message, code, response, url, options);
        }
        return response;
    }
    /**
     * ```js
     * import { request } from '@esri/arcgis-rest-request';
     * //
     * request('https://www.arcgis.com/sharing/rest')
     *   .then(response) // response.currentVersion === 5.2
     * //
     * request('https://www.arcgis.com/sharing/rest', {
     *   httpMethod: "GET"
     * })
     * //
     * request('https://www.arcgis.com/sharing/rest/search', {
     *   params: { q: 'parks' }
     * })
     *   .then(response) // response.total => 78379
     * ```
     * Generic method for making HTTP requests to ArcGIS REST API endpoints.
     *
     * @param url - The URL of the ArcGIS REST API endpoint.
     * @param requestOptions - Options for the request, including parameters relevant to the endpoint.
     * @returns A Promise that will resolve with the data from the response.
     */
    function request(url, requestOptions) {
        if (requestOptions === void 0) { requestOptions = { params: { f: "json" } }; }
        var options = __assign(__assign(__assign({ httpMethod: "POST" }, DEFAULT_ARCGIS_REQUEST_OPTIONS), requestOptions), {
            params: __assign(__assign({}, DEFAULT_ARCGIS_REQUEST_OPTIONS.params), requestOptions.params),
            headers: __assign(__assign({}, DEFAULT_ARCGIS_REQUEST_OPTIONS.headers), requestOptions.headers),
        });
        var missingGlobals = [];
        var recommendedPackages = [];
        // don't check for a global fetch if a custom implementation was passed through
        if (!options.fetch && typeof fetch !== "undefined") {
            options.fetch = fetch.bind(Function("return this")());
        }
        else {
            missingGlobals.push("`fetch`");
            recommendedPackages.push("`node-fetch`");
        }
        if (typeof Promise === "undefined") {
            missingGlobals.push("`Promise`");
            recommendedPackages.push("`es6-promise`");
        }
        if (typeof FormData === "undefined") {
            missingGlobals.push("`FormData`");
            recommendedPackages.push("`isomorphic-form-data`");
        }
        if (!options.fetch ||
            typeof Promise === "undefined" ||
            typeof FormData === "undefined") {
            throw new Error("`arcgis-rest-request` requires a `fetch` implementation and global variables for `Promise` and `FormData` to be present in the global scope. You are missing " + missingGlobals.join(", ") + ". We recommend installing the " + recommendedPackages.join(", ") + " modules at the root of your application to add these to the global scope. See https://bit.ly/2KNwWaJ for more info.");
        }
        var httpMethod = options.httpMethod, authentication = options.authentication, rawResponse = options.rawResponse;
        var params = __assign({ f: "json" }, options.params);
        var originalAuthError = null;
        var fetchOptions = {
            method: httpMethod,
            /* ensures behavior mimics XMLHttpRequest.
            needed to support sending IWA cookies */
            credentials: options.credentials || "same-origin",
        };
        // the /oauth2/platformSelf route will add X-Esri-Auth-Client-Id header
        // and that request needs to send cookies cross domain
        // so we need to set the credentials to "include"
        if (options.headers &&
            options.headers["X-Esri-Auth-Client-Id"] &&
            url.indexOf("/oauth2/platformSelf") > -1) {
            fetchOptions.credentials = "include";
        }
        return (authentication
            ? authentication.getToken(url, { fetch: options.fetch }).catch(function (err) {
                /**
                 * append original request url and requestOptions
                 * to the error thrown by getToken()
                 * to assist with retrying
                 */
                err.url = url;
                err.options = options;
                /**
                 * if an attempt is made to talk to an unfederated server
                 * first try the request anonymously. if a 'token required'
                 * error is thrown, throw the UNFEDERATED error then.
                 */
                originalAuthError = err;
                return Promise.resolve("");
            })
            : Promise.resolve(""))
            .then(function (token) {
            if (token.length) {
                params.token = token;
            }
            if (authentication && authentication.getDomainCredentials) {
                fetchOptions.credentials = authentication.getDomainCredentials(url);
            }
            // Custom headers to add to request. IRequestOptions.headers with merge over requestHeaders.
            var requestHeaders = {};
            if (fetchOptions.method === "GET") {
                // Prevents token from being passed in query params when hideToken option is used.
                /* istanbul ignore if - window is always defined in a browser. Test case is covered by Jasmine in node test */
                if (params.token &&
                    options.hideToken &&
                    // Sharing API does not support preflight check required by modern browsers https://developer.mozilla.org/en-US/docs/Glossary/Preflight_request
                    typeof window === "undefined") {
                    requestHeaders["X-Esri-Authorization"] = "Bearer " + params.token;
                    delete params.token;
                }
                // encode the parameters into the query string
                var queryParams = encodeQueryString(params);
                // dont append a '?' unless parameters are actually present
                var urlWithQueryString = queryParams === "" ? url : url + "?" + encodeQueryString(params);
                if (
                // This would exceed the maximum length for URLs specified by the consumer and requires POST
                (options.maxUrlLength &&
                    urlWithQueryString.length > options.maxUrlLength) ||
                    // Or if the customer requires the token to be hidden and it has not already been hidden in the header (for browsers)
                    (params.token && options.hideToken)) {
                    // the consumer specified a maximum length for URLs
                    // and this would exceed it, so use post instead
                    fetchOptions.method = "POST";
                    // If the token was already added as a Auth header, add the token back to body with other params instead of header
                    if (token.length && options.hideToken) {
                        params.token = token;
                        // Remove existing header that was added before url query length was checked
                        delete requestHeaders["X-Esri-Authorization"];
                    }
                }
                else {
                    // just use GET
                    url = urlWithQueryString;
                }
            }
            /* updateResources currently requires FormData even when the input parameters dont warrant it.
        https://developers.arcgis.com/rest/users-groups-and-items/update-resources.htm
            see https://github.com/Esri/arcgis-rest-js/pull/500 for more info. */
            var forceFormData = new RegExp("/items/.+/updateResources").test(url);
            if (fetchOptions.method === "POST") {
                fetchOptions.body = encodeFormData(params, forceFormData);
            }
            // Mixin headers from request options
            fetchOptions.headers = __assign(__assign({}, requestHeaders), options.headers);
            /* istanbul ignore next - karma reports coverage on browser tests only */
            if (typeof window === "undefined" && !fetchOptions.headers.referer) {
                fetchOptions.headers.referer = NODEJS_DEFAULT_REFERER_HEADER;
            }
            /* istanbul ignore else blob responses are difficult to make cross platform we will just have to trust the isomorphic fetch will do its job */
            if (!requiresFormData(params) && !forceFormData) {
                fetchOptions.headers["Content-Type"] =
                    "application/x-www-form-urlencoded";
            }
            return options.fetch(url, fetchOptions);
        })
            .then(function (response) {
            if (!response.ok) {
                // server responded w/ an actual error (404, 500, etc)
                var status_1 = response.status, statusText = response.statusText;
                throw new ArcGISRequestError(statusText, "HTTP " + status_1, response, url, options);
            }
            if (rawResponse) {
                return response;
            }
            switch (params.f) {
                case "json":
                    return response.json();
                case "geojson":
                    return response.json();
                case "html":
                    return response.text();
                case "text":
                    return response.text();
                /* istanbul ignore next blob responses are difficult to make cross platform we will just have to trust that isomorphic fetch will do its job */
                default:
                    return response.blob();
            }
        })
            .then(function (data) {
            if ((params.f === "json" || params.f === "geojson") && !rawResponse) {
                var response = checkForErrors(data, url, params, options, originalAuthError);
                if (originalAuthError) {
                    /* If the request was made to an unfederated service that
                    didn't require authentication, add the base url and a dummy token
                    to the list of trusted servers to avoid another federation check
                    in the event of a repeat request */
                    var truncatedUrl = url
                        .toLowerCase()
                        .split(/\/rest(\/admin)?\/services\//)[0];
                    options.authentication.federatedServers[truncatedUrl] = {
                        token: [],
                        // default to 24 hours
                        expires: new Date(Date.now() + 86400 * 1000),
                    };
                    originalAuthError = null;
                }
                return response;
            }
            else {
                return data;
            }
        });
    }

    /* Copyright (c) 2017-2018 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * Helper for methods with lots of first order request options to pass through as request parameters.
     */
    function appendCustomParams(customOptions, keys, baseOptions) {
        var requestOptionsKeys = [
            "params",
            "httpMethod",
            "rawResponse",
            "authentication",
            "portal",
            "fetch",
            "maxUrlLength",
            "headers"
        ];
        var options = __assign(__assign({ params: {} }, baseOptions), customOptions);
        // merge all keys in customOptions into options.params
        options.params = keys.reduce(function (value, key) {
            if (customOptions[key] || typeof customOptions[key] === "boolean") {
                value[key] = customOptions[key];
            }
            return value;
        }, options.params);
        // now remove all properties in options that don't exist in IRequestOptions
        return requestOptionsKeys.reduce(function (value, key) {
            if (options[key]) {
                value[key] = options[key];
            }
            return value;
        }, {});
    }

    /* Copyright (c) 2018 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * Helper method to ensure that user supplied urls don't include whitespace or a trailing slash.
     */
    function cleanUrl(url) {
        // Guard so we don't try to trim something that's not a string
        if (typeof url !== "string") {
            return url;
        }
        // trim leading and trailing spaces, but not spaces inside the url
        url = url.trim();
        // remove the trailing slash to the url if one was included
        if (url[url.length - 1] === "/") {
            url = url.slice(0, -1);
        }
        return url;
    }

    /* Copyright (c) 2017 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * Helper that returns the appropriate portal url for a given request. `requestOptions.portal` is given
     * precedence over `authentication.portal`. If neither `portal` nor `authentication` is present,
     * `www.arcgis.com/sharing/rest` is returned.
     *
     * @param requestOptions - Request options that may have authentication manager
     * @returns Portal url to be used in API requests
     */
    function getPortalUrl(requestOptions) {
        if (requestOptions === void 0) { requestOptions = {}; }
        // use portal in options if specified
        if (requestOptions.portal) {
            return cleanUrl(requestOptions.portal);
        }
        // if auth was passed, use that portal
        if (requestOptions.authentication) {
            // the portal url is already scrubbed in the auth package
            return requestOptions.authentication.portal;
        }
        // default to arcgis.com
        return "https://www.arcgis.com/sharing/rest";
    }

    /* Copyright (c) 2018-2021 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * `SearchQueryBuilder` can be used to construct the `q` param for
     * [`searchItems`](/arcgis-rest-js/api/portal/searchItems#searchItems-search) or
     * [`searchGroups`](/arcgis-rest-js/api/portal/searchGroups#searchGroups-search).
     * By chaining methods, it helps build complex search queries.
     *
     * ```js
     * const startDate = new Date("2020-01-01");
     * const endDate = new Date("2020-09-01");
     * const query = new SearchQueryBuilder()
     *  .match("Patrick")
     *  .in("owner")
     *  .and()
     *  .from(startDate)
     *  .to(endDate)
     *  .in("created")
     *  .and()
     *  .startGroup()
     *    .match("Web Mapping Application")
     *    .in("type")
     *    .or()
     *    .match("Mobile Application")
     *    .in("type")
     *    .or()
     *    .match("Application")
     *    .in("type")
     *  .endGroup()
     *  .and()
     *  .match("Demo App");
     *
     * searchItems(query).then((res) => {
     *   console.log(res.results);
     * });
     * ```
     *
     * Will search for items matching
     * ```
     * "owner: Patrick AND created:[1577836800000 TO 1598918400000] AND (type:"Web Mapping Application" OR type:"Mobile Application" OR type:Application) AND Demo App"
     * ```
     */
    var SearchQueryBuilder = /** @class */ (function () {
        /**
         * @param q An existing query string to start building from.
         */
        function SearchQueryBuilder(q) {
            if (q === void 0) { q = ""; }
            this.termStack = [];
            this.rangeStack = [];
            this.openGroups = 0;
            this.q = q;
        }
        /**
         * Defines strings to search for.
         *
         * ```js
         * const query = new SearchQueryBuilder()
         *   .match("My Layer")
         * ```
         *
         * @param terms strings to search for.
         */
        SearchQueryBuilder.prototype.match = function () {
            var terms = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                terms[_i] = arguments[_i];
            }
            this.termStack = this.termStack.concat(terms);
            return this;
        };
        /**
         * Defines fields to search in. You can pass `"*"` or call this method without arguments to search a default set of fields
         *
         * ```js
         * const query = new SearchQueryBuilder()
         *   .match("My Layer")
         *   .in("title")
         * ```
         *
         * @param field The field to search for the previous match in.
         */
        SearchQueryBuilder.prototype.in = function (field) {
            var fn = "`in(" + (field ? "\"" + field + "\"" : "") + ")`";
            if (!this.hasRange && !this.hasTerms) {
                warn(
                // apparently-p-rettier-ignore causes some
                fn + " was called with no call to `match(...)` or `from(...)`/`to(...)`. Your query was not modified.");
                return this;
            }
            if (field && field !== "*") {
                this.q += field + ":";
            }
            return this.commit();
        };
        /**
         * Starts a new search group.
         *
         * ```js
         * const query = new SearchQueryBuilder()
         *   .startGroup()
         *     .match("Lakes")
         *     .in("title")
         *   .endGroup()
         *   .or()
         *   .startGroup()
         *     .match("Rivers")
         *     .in("title")
         *   .endGroup()
         * ```
         */
        SearchQueryBuilder.prototype.startGroup = function () {
            this.commit();
            if (this.openGroups > 0) {
                this.q += " ";
            }
            this.openGroups++;
            this.q += "(";
            return this;
        };
        /**
         * Ends a search group.
         *
         * ```js
         * const query = new SearchQueryBuilder()
         *   .startGroup()
         *     .match("Lakes")
         *     .in("title")
         *   .endGroup()
         *   .or()
         *   .startGroup()
         *     .match("Rivers")
         *     .in("title")
         *   .endGroup()
         * ```
         */
        SearchQueryBuilder.prototype.endGroup = function () {
            if (this.openGroups <= 0) {
                warn("`endGroup(...)` was called without calling `startGroup(...)` first. Your query was not modified.");
                return this;
            }
            this.commit();
            this.openGroups--;
            this.q += ")";
            return this;
        };
        /**
         * Joins two sets of queries with an `AND` clause.
         *
         * ```js
         * const query = new SearchQueryBuilder()
         *   .match("Lakes")
         *   .in("title")
         *   .and()
         *   .match("Rivers")
         *   .in("title")
         * ```
         */
        SearchQueryBuilder.prototype.and = function () {
            return this.addModifier("and");
        };
        /**
         * Joins two sets of queries with an `OR` clause.
         *
         * ```js
         * const query = new SearchQueryBuilder()
         *   .match("Lakes")
         *   .in("title")
         *   .or()
         *   .match("Rivers")
         *   .in("title")
         * ```
         */
        SearchQueryBuilder.prototype.or = function () {
            return this.addModifier("or");
        };
        /**
         * Joins two sets of queries with a `NOT` clause. Another option for filtering results is the [prohibit operator '-'](https://developers.arcgis.com/rest/users-groups-and-items/search-reference.htm#ESRI_SECTION1_5C6C35DB9E4A4F4492C5B937BDA2BF67).
         *
         * ```js
         * // omit results with "Rivers" in their title
         * const query = new SearchQueryBuilder()
         *   .not()
         *   .match("Rivers")
         *   .in("title")
         *
         * // equivalent
         * const query = new SearchQueryBuilder()
         *   .match("Rivers")
         *   .in("-title")
         * ```
         */
        SearchQueryBuilder.prototype.not = function () {
            return this.addModifier("not");
        };
        /**
         * Begins a new range query.
         *
         * ```js
         *
         * const NEWYEARS = new Date("2020-01-01")
         * const TODAY = new Date()
         *
         * const query = new SearchQueryBuilder()
         *   .from(NEWYEARS)
         *   .to(TODAY)
         *   .in("created")
         * ```
         */
        SearchQueryBuilder.prototype.from = function (term) {
            if (this.hasTerms) {
                warn(
                // apparently-p*rettier-ignore causes prettier to strip *all* comments O_o
                "`from(...)` is not allowed after `match(...)` try using `.from(...).to(...).in(...)`. Optionally, you may see this because dates are incorrectly formatted. Dates should be a primative Date value, aka a number in milliseconds or Date object, ie new Date(\"2020-01-01\").  Your query was not modified.");
                return this;
            }
            this.rangeStack[0] = term;
            return this;
        };
        /**
         * Ends a range query.
         *
         * ```js
         * const query = new SearchQueryBuilder()
         *   .from(yesterdaysDate)
         *   .to(todaysDate)
         *   .in("created")
         * ```
         */
        SearchQueryBuilder.prototype.to = function (term) {
            if (this.hasTerms) {
                warn(
                // apparently-p*rettier-ignore causes prettier to strip *all* comments O_o
                "`to(...)` is not allowed after `match(...)` try using `.from(...).to(...).in(...)`. Optionally, you may see this because dates are incorrectly formatted. Dates should be a primative Date value, aka a number in milliseconds or Date object, ie new Date(\"2020-01-01\"). Your query was not modified.");
                return this;
            }
            this.rangeStack[1] = term;
            return this;
        };
        /**
         * Boosts the previous term to increase its rank in the results.
         *
         * ```js
         * const query = new SearchQueryBuilder()
         *   .match("Lakes")
         *   .in("title")
         *   .or()
         *   .match("Rivers")
         *   .in("title")
         *   .boost(3)
         * ```
         */
        SearchQueryBuilder.prototype.boost = function (num) {
            this.commit();
            this.q += "^" + num;
            return this;
        };
        /**
         * Returns the current query string. Called internally when the request is made.
         */
        SearchQueryBuilder.prototype.toParam = function () {
            this.commit();
            this.cleanup();
            return this.q;
        };
        /**
         * Returns a new instance of `SearchQueryBuilder` based on the current instance.
         */
        SearchQueryBuilder.prototype.clone = function () {
            this.commit();
            this.cleanup();
            return new SearchQueryBuilder(this.q + "");
        };
        SearchQueryBuilder.prototype.addModifier = function (modifier) {
            if (this.currentModifer) {
                warn(
                // apparently-p*rettier-ignore causes prettier to strip *all* comments O_o
                "You have called `" + this.currentModifer + "()` after `" + modifier + "()`. Your current query was not modified.");
                return this;
            }
            this.commit();
            if (this.q === "" && modifier !== "not") {
                warn("You have called `" + modifier + "()` without calling another method to modify your query first. Try calling `match()` first.");
                return this;
            }
            this.currentModifer = modifier;
            this.q += this.q === "" ? "" : " ";
            this.q += modifier.toUpperCase() + " ";
            return this;
        };
        SearchQueryBuilder.prototype.needsQuotes = function (s) {
            return /\s|:/g.test(s);
        };
        SearchQueryBuilder.prototype.formatTerm = function (term) {
            if (term instanceof Date) {
                return term.getTime();
            }
            if (typeof term === "string" && this.needsQuotes(term)) {
                return "\"" + term + "\"";
            }
            return term;
        };
        SearchQueryBuilder.prototype.commit = function () {
            var _this = this;
            this.currentModifer = undefined;
            if (this.hasRange) {
                this.q += "[" + this.formatTerm(this.rangeStack[0]) + " TO " + this.formatTerm(this.rangeStack[1]) + "]";
                this.rangeStack = [undefined, undefined];
            }
            if (this.hasTerms) {
                this.q += this.termStack
                    .map(function (term) {
                    return _this.formatTerm(term);
                })
                    .join(" ");
                this.termStack = [];
            }
            return this;
        };
        Object.defineProperty(SearchQueryBuilder.prototype, "hasTerms", {
            get: function () {
                return this.termStack.length > 0;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SearchQueryBuilder.prototype, "hasRange", {
            get: function () {
                return this.rangeStack.length && this.rangeStack[0] && this.rangeStack[1];
            },
            enumerable: false,
            configurable: true
        });
        SearchQueryBuilder.prototype.cleanup = function () {
            // end a group if we have started one
            if (this.openGroups > 0) {
                warn(
                // apparently-p*rettier-ignore causes prettier to strip *all* comments O_o
                "Automatically closing " + this.openGroups + " group(s). You can use `endGroup(...)` to remove this warning.");
                while (this.openGroups > 0) {
                    this.q += ")";
                    this.openGroups--;
                }
            }
            var oldQ = this.q;
            this.q = oldQ.replace(/( AND ?| NOT ?| OR ?)*$/, "");
            if (oldQ !== this.q) {
                warn("`startGroup(...)` was called without calling `endGroup(...)` first. Your query was not modified.");
            }
            // clear empty groups
            this.q = this.q.replace(/(\(\))*/, "");
        };
        return SearchQueryBuilder;
    }());

    /* Copyright (c) 2018 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    function genericSearch(search, searchType) {
        var options;
        if (typeof search === "string" || search instanceof SearchQueryBuilder) {
            options = {
                httpMethod: "GET",
                params: {
                    q: search,
                },
            };
        }
        else {
            // searchUserAccess has one (knonw) valid value: "groupMember"
            options = appendCustomParams(search, [
                "q",
                "num",
                "start",
                "sortField",
                "sortOrder",
                "searchUserAccess",
                "searchUserName",
                "filter",
                "countFields",
                "countSize",
                "categories",
                "categoryFilters",
            ], {
                httpMethod: "GET",
            });
        }
        var path;
        switch (searchType) {
            case "item":
                path = "/search";
                break;
            case "group":
                path = "/community/groups";
                break;
            case "groupContent":
                // Need to have groupId property to do group contents search,
                // cso filter out all but ISearchGroupContentOptions
                if (typeof search !== "string" &&
                    !(search instanceof SearchQueryBuilder) &&
                    search.groupId) {
                    path = "/content/groups/" + search.groupId + "/search";
                }
                else {
                    return Promise.reject(new Error("you must pass a `groupId` option to `searchGroupContent`"));
                }
                break;
            default:
                // "users"
                path = "/portals/self/users/search";
                break;
        }
        var url = getPortalUrl(options) + path;
        // send the request
        return request(url, options).then(function (r) {
            if (r.nextStart && r.nextStart !== -1) {
                r.nextPage = function () {
                    var newOptions;
                    if (typeof search === "string" ||
                        search instanceof SearchQueryBuilder) {
                        newOptions = {
                            q: search,
                            start: r.nextStart,
                        };
                    }
                    else {
                        newOptions = search;
                        newOptions.start = r.nextStart;
                    }
                    return genericSearch(newOptions, searchType);
                };
            }
            return r;
        });
    }

    /* Copyright (c) 2018-2019 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * ```js
     * import { searchItems } from "@esri/arcgis-rest-portal";
     * //
     * searchItems('water')
     *   .then(response) // response.total => 355
     * ```
     * Search a portal for items. See the [REST Documentation](https://developers.arcgis.com/rest/users-groups-and-items/search.htm) for more information.
     *
     * @param search - A string or RequestOptions object to pass through to the endpoint.
     * @returns A Promise that will resolve with the data from the response.
     */
    function searchItems(search) {
        return genericSearch(search, "item");
    }

    /**
     * Defines an enum for common booleans used to create a search filter
     */
    exports.IBooleanOperator = void 0;
    (function (IBooleanOperator) {
        IBooleanOperator["AND"] = "AND";
        IBooleanOperator["OR"] = "OR";
        IBooleanOperator["NOT"] = "NOT";
    })(exports.IBooleanOperator || (exports.IBooleanOperator = {}));

    var DATE_FILTER_FIELDS = ["created", "modified"];
    /**
     * Determines if filter value is a non-empty string
     * @param filterValue - a filter value
     */
    function isFilterANonEmptyString(filterValue) {
        return filterValue && typeof filterValue === "string";
    }
    /**
     * Determines if filter value is a non-empty array
     * @param filterValue - a filter value
     */
    function isFilterAnArrayWithData(filterValue) {
        return Array.isArray(filterValue) && filterValue.length > 0;
    }
    /**
     * Determines if filter is non-falsey and corresponds to a date field
     * @param filterValue - a filter's field name
     * @param filterValue - a filter's value
     */
    function isFilterFieldADateRange(filterField, filterValue) {
        return DATE_FILTER_FIELDS.indexOf(filterField) >= 0 && filterValue;
    }

    var TERM_FIELD$1 = "terms";
    var DEFAULT_FILTERS = ['(-type: "code attachment")'];
    var STRING_ENCLOSED_FILTER_FIELDS = [
        "title",
        "type",
        "typekeywords",
        "description",
        "tags",
        "snippet",
        "categories",
    ];
    /**
     * Converts the common request format of contentSearch to a format specific to the Portal API
     * @param request - the IContentSearchRequest instance for searching
     */
    function convertToPortalParams(request, defaultPortal, defaultAuthentication) {
        var q = processFilter$1(request);
        var paging = processPage$1(request) || { start: 1, num: 10 };
        return createSearchOptions$1(q, paging, request.options, defaultPortal, defaultAuthentication);
    }
    function processFilter$1(request) {
        var filter = request.filter || {};
        var filters = Object.keys(filter).reduce(function (arr, key) {
            var clause = convertToPortalFilterClause(key, filter[key]);
            if (clause) {
                arr.push(clause);
            }
            return arr;
        }, []);
        var filtersWithDefaults = addDefaultFilters(filters);
        return filtersWithDefaults.join(" AND ").trim();
    }
    /**
     * Processes the paging parameters provided as part of a search request
     * @param request content search request
     */
    function processPage$1(request) {
        var options = request.options || {};
        var providedPage = options.page || {
            start: 1,
            num: 10,
        };
        return typeof providedPage === "string"
            ? decodePage(providedPage)
            : providedPage;
    }
    function createSearchOptions$1(q, page, options, defaultPortal, defaultAuthentication) {
        if (options === void 0) { options = {}; }
        return {
            q: q,
            sortOrder: options.sortOrder,
            sortField: options.sortField,
            params: {
                countFields: options.aggregations,
                countSize: options.aggregations ? 200 : undefined,
                start: page.start,
                num: page.num,
            },
            bbox: options.bbox,
            portal: options.portal || defaultPortal,
            authentication: options.authentication || defaultAuthentication,
            httpMethod: "POST",
        };
    }
    function convertToPortalFilterClause(filterField, filterValue) {
        if (isFilterANonEmptyString(filterValue)) {
            return processStringFilter(filterField, filterValue);
        }
        else if (isFilterAnArrayWithData(filterValue)) {
            return processArrayFilter$1(filterField, filterValue);
        }
        else if (isFilterFieldADateRange(filterField, filterValue)) {
            return processDateField$1(filterField, filterValue);
        }
        else {
            return processFieldFilter$1(filterField, filterValue);
        }
    }
    function addDefaultFilters(filters) {
        return filters.concat(DEFAULT_FILTERS);
    }
    function processStringFilter(filterField, filterValue) {
        if (filterField === TERM_FIELD$1) {
            return "(" + stringifyFilterValue(filterField, filterValue) + ")";
        }
        return "(" + filterField + ": " + stringifyFilterValue(filterField, filterValue) + ")";
    }
    function processArrayFilter$1(filterField, filterArray) {
        var filters = filterArray.map(function (filter) {
            return stringifyFilterValue(filterField, filter);
        });
        return "(" + filterField + ": " + filters.join(" OR " + filterField + ": ") + ")";
    }
    function processDateField$1(filterField, filterValue) {
        return "(" + filterField + ": [" + (filterValue.from || 0) + " TO " + (filterValue.to || new Date().getTime()) + "])";
    }
    function processFieldFilter$1(filterField, contentFilter) {
        if (!contentFilter || !isFilterAnArrayWithData(contentFilter.value)) {
            return undefined;
        }
        var operator = contentFilter.bool || exports.IBooleanOperator.OR;
        var filters = contentFilter.value.map(function (filter) {
            return stringifyFilterValue(filterField, filter);
        });
        if (operator === exports.IBooleanOperator.NOT) {
            return "(-" + filterField + ": " + filters.join(" AND -" + filterField + ": ") + ")";
        }
        else {
            return "(" + filterField + ": " + filters.join(" " + operator.toString() + " " + filterField + ": ") + ")";
        }
    }
    function stringifyFilterValue(filterField, filterValue) {
        return STRING_ENCLOSED_FILTER_FIELDS.indexOf(filterField) >= 0
            ? "\"" + filterValue + "\""
            : filterValue;
    }
    function decodePage(page) {
        try {
            var decodedPage = hubCommon.atob(page);
            if (decodedPage === null) {
                throw new Error();
            }
            return JSON.parse(decodedPage);
        }
        catch (err) {
            hubCommon.Logger.error("error decoding and parsing the provided page: " + page + ". Defaulting to starting page");
            return undefined;
        }
    }

    var TERM_FIELD = "terms";
    var VALID_CATALOG_PROPS = ["id", "orgid", "group", "initiativeid"];
    // Necessary to map Portal API-supported properties to Hub Indexer Search API properties
    var PROP_MAP = {
        group: "groupIds",
        title: "name",
        typekeywords: "typeKeywords",
        orgid: "orgId",
        initiativeid: "initiativeId",
    };
    // Necessary to map Portal API-supported values of properties to Hub Indexer Search API properties
    var VALUE_MAP = {
        access: {
            org: "organization",
            shared: "team",
            private: "myself",
        },
    };
    /**
     * Converts the common request format of contentSearch to a format specific to the Hub V3 Search API
     * @param request - the IContentSearchRequest instance for searching
     */
    function convertToHubParams(request) {
        var _a = splitFilterTerms(request), termField = _a.termField, filterFields = _a.filterFields, catalogFields = _a.catalogFields;
        var filter = Object.keys(filterFields).length
            ? processFilter(filterFields)
            : undefined;
        var catalog = Object.keys(catalogFields).length
            ? processCatalog(catalogFields)
            : undefined;
        var paging = processPage(request);
        return createSearchOptions({
            termField: termField,
            filter: filter,
            catalog: catalog,
            paging: paging,
            options: request.options,
        });
    }
    function splitFilterTerms(request) {
        var filter = request.filter || {};
        return Object.keys(filter).reduce(function (filterObj, key) {
            var hubKey = PROP_MAP[key] ? PROP_MAP[key] : key;
            if (isFilterATerm(key)) {
                filterObj.termField = filter[key];
            }
            else if (isFilterACatalogFilter(key)) {
                filterObj.catalogFields[hubKey] = filter[key];
            }
            else {
                filterObj.filterFields[hubKey] = filter[key];
            }
            return filterObj;
        }, { termField: undefined, filterFields: {}, catalogFields: {} });
    }
    function processFilter(filterFields) {
        return Object.keys(filterFields).reduce(function (filterObj, key) {
            var clause = convertToHubFilterClause(key, filterFields[key]);
            if (clause) {
                filterObj[key] = clause;
            }
            return filterObj;
        }, {});
    }
    function processCatalog(catalogFields) {
        return Object.keys(catalogFields).reduce(function (catalogObj, key) {
            var clause = convertToHubFilterClause(key, catalogFields[key]);
            if (clause) {
                catalogObj[key] = clause;
            }
            return catalogObj;
        }, {});
    }
    function processPage(request) {
        var options = request.options || {};
        return options.page;
    }
    function createSearchOptions(params) {
        var options = params.options || {};
        var sort = createSort(options.sortField, options.sortOrder);
        var agg = getAggregations(options.aggregations);
        var fields = getFields(options.fields);
        var searchParams = {
            q: params.termField || undefined,
            sort: sort,
            filter: params.filter,
            catalog: params.catalog,
            page: params.paging && { key: params.paging },
            agg: agg,
            fields: fields,
        };
        return searchParams;
    }
    function convertToHubFilterClause(filterField, filterValue) {
        if (isFilterANonEmptyString(filterValue)) {
            return processArrayFilter(filterField, [filterValue]);
        }
        else if (isFilterAnArrayWithData(filterValue)) {
            return processArrayFilter(filterField, filterValue);
        }
        else if (isFilterFieldADateRange(filterField, filterValue)) {
            return processDateField(filterValue);
        }
        else {
            return processFieldFilter(filterValue);
        }
    }
    function processArrayFilter(field, filterArray) {
        var modifiedFilterValues = filterArray.map(function (filter) {
            if (VALUE_MAP[field] && VALUE_MAP[field][filter]) {
                return VALUE_MAP[field][filter];
            }
            return filter;
        });
        return "any(" + modifiedFilterValues.join(",") + ")";
    }
    function processDateField(dateFilterValue) {
        var from = dateFilterValue.from || 0;
        var to = dateFilterValue.to || new Date().getTime();
        return "between(" + convertDateEpochToString(from) + "," + convertDateEpochToString(to) + ")";
    }
    function processFieldFilter(contentFilter) {
        if (!contentFilter || !isFilterAnArrayWithData(contentFilter.value)) {
            return undefined;
        }
        var operator = contentFilter.bool || exports.IBooleanOperator.OR;
        var hubOperator = convertToHubOperator(operator);
        var filters = contentFilter.value;
        return hubOperator + "(" + filters.join(",") + ")";
    }
    function convertDateEpochToString(epoch) {
        var date = new Date(epoch).toISOString();
        return date.substring(0, 10);
    }
    function convertToHubOperator(operator) {
        if (operator === exports.IBooleanOperator.NOT) {
            return "not";
        }
        else if (operator === exports.IBooleanOperator.AND) {
            return "all";
        }
        return "any";
    }
    function isFilterATerm(filterField) {
        return TERM_FIELD === filterField;
    }
    function isFilterACatalogFilter(filterField) {
        return VALID_CATALOG_PROPS.indexOf(filterField) >= 0;
    }
    function createSort(sortField, sortOrder) {
        if (!sortField || sortField.toLowerCase() === "relevance") {
            return undefined;
        }
        var hubSortField = PROP_MAP[sortField] ? PROP_MAP[sortField] : sortField;
        var order = sortOrder && sortOrder.toLowerCase() === "desc" ? "-" : "";
        return "" + order + hubSortField;
    }
    function getAggregations(aggregations) {
        return aggregations
            ? {
                fields: aggregations,
            }
            : undefined;
    }
    function getFields(fields) {
        return fields
            ? {
                datasets: fields,
            }
            : undefined;
    }

    /**
     * Converts the response format returned by the Portal API to a common format
     * @param request - the ISearchOptions instance used to invoke the request
     * @param response - the ISearchResult JSON returned by the Portal API
     */
    function convertPortalResponse(request, response) {
        var results = response.results.map(hubCommon.itemToContent);
        var count = response.num;
        var total = response.total;
        var hasNext = response.nextStart > -1;
        var query = response.query;
        var aggregations = response.aggregations
            ? mapAggregations$1(response.aggregations)
            : undefined;
        var next = getNextFunction$1(request, response.nextStart, response.total);
        return {
            results: results,
            count: count,
            total: total,
            hasNext: hasNext,
            query: query,
            aggregations: aggregations,
            next: next,
        };
    }
    function mapAggregations$1(aggregations) {
        return Object.keys(aggregations).reduce(function (contentAggs, aggType) {
            // Built in as a safety if Portal returns unsupported aggregations
            /* istanbul ignore else */
            if (aggType.toLowerCase() === "counts") {
                contentAggs.counts = mapCountAggregations$1(aggregations[aggType]);
            }
            return contentAggs;
        }, {});
    }
    function mapCountAggregations$1(countAggs) {
        return countAggs.map(function (agg) {
            var mappedAggs = agg.fieldValues.map(function (aggValue) { return ({
                label: aggValue.value,
                value: aggValue.count,
            }); });
            return {
                fieldName: agg.fieldName,
                aggregations: mappedAggs,
            };
        });
    }
    function getNextFunction$1(request, nextStart, total) {
        var clonedRequest = hubCommon.cloneObject(request);
        // Authentication not properly cloned
        clonedRequest.authentication = request.authentication;
        clonedRequest.start = nextStart > -1 ? nextStart : total + 1;
        return function (authentication) {
            if (authentication) {
                clonedRequest.authentication = authentication;
            }
            return searchItems(clonedRequest).then(function (response) {
                return convertPortalResponse(clonedRequest, response);
            });
        };
    }

    /**
     * Converts the response format returned by the Hub Indexer V3 API to a common format
     * @param request - the ISearchParams instance used to invoke the request
     * @param response - the JSON returned by the Hub Indexer V3 API
     * @param defaultAuthentication - a default UserSession instance that can be used for the next() request if none provided
     */
    function convertHubResponse(request, response, defaultAuthentication) {
        if (response === void 0) { response = { data: [], meta: {} }; }
        var results = response.data.map(hubCommon.datasetToContent);
        var _a = getResponseMetadata(response), count = _a.count, total = _a.total, hasNext = _a.hasNext, query = _a.query, aggregations = _a.aggregations;
        var next = getNextFunction(request, response, hasNext, defaultAuthentication);
        return {
            results: results,
            count: count,
            total: total,
            hasNext: hasNext,
            query: query,
            aggregations: aggregations ? mapAggregations(aggregations) : undefined,
            next: next,
        };
    }
    function mapAggregations(aggregations) {
        return {
            counts: mapCountAggregations(aggregations),
        };
    }
    function mapCountAggregations(countAggs) {
        return Object.keys(countAggs).map(function (aggKey) {
            var aggregations = countAggs[aggKey]
                ? countAggs[aggKey].map(function (agg) { return ({
                    label: agg.key.toLowerCase(),
                    value: agg.docCount,
                }); })
                : [];
            return {
                fieldName: aggKey,
                aggregations: aggregations,
            };
        });
    }
    function getNextFunction(request, response, hasNext, defaultAuthentication) {
        return function (auth) {
            var authentication = auth || defaultAuthentication;
            var headers = authentication &&
                authentication.serialize &&
                new Headers({ authentication: authentication.serialize() });
            if (hasNext) {
                // should this use hubRequest instead of fetch?
                return fetch(response.meta.next, {
                    method: "GET",
                    mode: "cors",
                    headers: headers,
                })
                    .then(function (res) { return res.json(); })
                    .then(function (res) { return convertHubResponse(request, res, defaultAuthentication); });
            }
            var metadata = getResponseMetadata(response);
            return Promise.resolve({
                results: [],
                count: 0,
                total: metadata.total,
                hasNext: false,
                query: metadata.query,
                aggregations: metadata.aggregations
                    ? mapAggregations(metadata.aggregations)
                    : undefined,
                next: getNextFunction(request, response, false),
            });
        };
    }
    function getResponseMetadata(response) {
        var respQuery = hubCommon.getProp(response, "meta.queryParameters");
        var query = respQuery ? JSON.stringify(respQuery) : undefined;
        var respAggregations = hubCommon.getProp(response, "meta.stats.aggs") || {};
        var aggregations = Object.keys(respAggregations).length > 0 ? respAggregations : undefined;
        return {
            count: hubCommon.getProp(response, "meta.stats.count") || 0,
            total: hubCommon.getProp(response, "meta.stats.totalCount") || 0,
            hasNext: !!hubCommon.getProp(response, "meta.next"),
            query: query,
            aggregations: aggregations,
        };
    }

    /**
     * A search service for searching content across the Portal API only or Portal API and the
     * Hub Indexer V3 API. Has a single public method for searching.
     *
     * @param portal The Portal Sharing URL of the portal for which content should be searched
     * @param isPortal Flag to determine if content searching should be limited to a Portal API
     * @param authentication Optional User Session instance that can be used for authentication
     *
     * ```js
     * import { ContentSearchService } from '@esri/hub-search'
     *
     * const service = new ContentSearchService({
     *     portal: 'https://hub.arcgis.com/sharing/rest,
     *     isPortal: false
     *     session: new UserSession({ ... })
     * });
     *
     * const searchResults = await service.search({ filters, options })
     * ```
     */
    var ContentSearchService = /** @class */ (function () {
        function ContentSearchService(params) {
            this.portal = params.portal;
            this.isPortal = params.isPortal;
            this.authentication = params.authentication;
        }
        /**
         * Entrypoint for Portal API-only or Portal API and Hub V3 API Search
         * @param request - the IContentSearchRequest instance for searching
         */
        ContentSearchService.prototype.search = function (request) {
            var isPortal = hubCommon.getProp(request, "options.isPortal") || this.isPortal;
            if (isPortal) {
                return this.enterpriseSearch(request);
            }
            return this.onlineSearch(request);
        };
        ContentSearchService.prototype.enterpriseSearch = function (request) {
            if (request === void 0) { request = { filter: {}, options: {} }; }
            return performEnterpriseContentSearch(request, this.portal, this.authentication);
        };
        ContentSearchService.prototype.onlineSearch = function (request) {
            if (request === void 0) { request = { filter: {}, options: {} }; }
            // merge instance's portal and authentication into options
            var _a = this, portal = _a.portal, authentication = _a.authentication;
            var options = __assign({ portal: portal, authentication: authentication }, request.options);
            return performHubContentSearch(__assign(__assign({}, request), { options: options }));
        };
        return ContentSearchService;
    }());
    /**
     * A standalone function for searching Hub content
     *
     * A content search is configured by passing `searchContent` an object of type `IContentSearchRequest`.
     * This configuration object is composed of two important child objects: `filter` and `options`.
     *
     * The `filter` object allows the caller to filter results based on attributes exposed by AGO and
     * the Hub API. A complete list of attributes can be found at the docs for `IContentSearchFilter`,
     * but some examples include:
     * - access
     * - id
     * - group
     * - orgid
     *
     * The `options` object allows the caller to specify more general attributes about the request itself.
     * A complete list of options can be found at the docs for `IContentSearchOptions`, but some examples include:
     * - the authenticated user
     * - whether the call is happening in an enterprise environment
     * - what site catalog to search
     *
     * Combined, both filters and options allow you to create complex queries against AGO / Hub API.
     * Here are examples of some common use cases:
     *
     * ```js
     * import { searchContent, IBooleanOperator } from '@esri/hub-search';
     * ...
     *
     * /////////////////////////////////////////////////////////////////////
     * // Search for all public and private content associated with a site
     * /////////////////////////////////////////////////////////////////////
     * const options: IContentSearchOptions = {
     *    site: 'https://my-site.hub.arcgis.com',
     *    portal: 'https://www.arcgis.com',
     *    // Any private content that the authenticated user can access will be included in the results
     *    authentication: new UserSession(...),
     * }
     * const searchResults = await searchContent({ options });
     * ...
     *
     * ///////////////////////////////////////////////////////////
     * // Search for all public content associated with a site
     * ///////////////////////////////////////////////////////////
     * const options: IContentSearchOptions = {
     *    site: 'https://my-site.hub.arcgis.com',
     *    portal: 'https://www.arcgis.com',
     *    authentication: new UserSession(...),
     * }
     * const filter: IContentSearchFilter = {
     *    access: 'public'
     * }
     * const searchResults = await searchContent({ filter, options });
     * ...
     *
     * //////////////////////////////////////////////////////////
     * // Search for all private content associated with a site
     * ///////////////////////////////////////////////////////////
     *
     * // TODO: As of 8/17/21 the hub api has a bug in which
     * // Any query with a not filter on the access field
     * // (e.g access: not('public')) will return no results
     *
     * const options: IContentSearchOptions = {
     *    site: 'https://my-site.hub.arcgis.com',
     *    portal: 'https://www.arcgis.com',
     *    // Any private content that the authenticated user can access will be included in the results
     *    authentication: new UserSession(...),
     * }
     * const filter: IContentSearchFilter = {
     *    access: {
     *        value: ['public'],
     *        bool: IBooleanOperator.NOT
     *    }
     * }
     * const searchResults = await searchContent({ filter, options });
     *
     * ...
     * /////////////////////////////////
     * // Search for a specific item
     * /////////////////////////////////
     * const options: IContentSearchOptions = {
     *    portal: 'https://www.arcgis.com',
     *    authentication: new UserSession(...),
     * }
     * const filter: IContentSearchFilter = {
     *    id: 'my_item_id'
     * }
     * const searchResults = await searchContent({ filter, options });
     * ```
     * There are a couple gotchas that need to be accounted for:
     *
     * 1) There is no way to specify the number of results per page. If you need to fetch all
     * items that match a given query, you'll need to utilize the `hasNext` flag as well as the
     * `next` function included on the return object and make multiple XHR requests.
     *
     * 2) Results returned from the hub index (i.e. 'public items') will be structured differently than
     * results returned from AGO/Enterprise (i.e. 'private' items). A comprehensive list of differences cannot
     * be given here, but developers should be aware that they exist. Additionally, the structure of 'public'
     * items can change when either the indexing process or schema of the Hub API is modified. To showcase
     * some of the possible differences between 'public' and 'private' items, we've provided examples of both
     * types of results below:
     *
     * ```js
     * ///////////////
     * // Private
     * ///////////////
     * {
     *  access: "myself",
     *  appCategories: [],
     *  avgRating: 0,
     *  categories: [],
     *  collection: ["Map"],
     *  contentOrigin: "self",
     *  created: 1623945553000,
     *  culture: "en-us",
     *  description: “A description",
     *  extent: {
     *    coordinates: [],
     *    type: "envelope"
     *  },
     *  hubType: "map",
     *  id: "06c0cdadc2ec48509576c20da8572bf8",
     *  industries: [],
     *  isOrgItem: true,
     *  languages: [],
     *  listed: false,
     *  modified: 1629220743000,
     *  name: "Traffic Camera Enforcement Locations in Washington DC",
     *  numComments: 0,
     *  numRatings: 0,
     *  numViews: 0,
     *  owner: "juliana_pa",
     *  properties: {...}
     *  protected: false,
     *  scoreCompleteness: 66,
     *  screenshots: [],
     *  searchDescription: “A description”,
     *  size: -1,
     *  subInfo: 0,
     *  tags: ["DC GIS", "police", "speed", "speeding", "ticket", "traffic", "violation"],
     *  thumbnail: "thumbnail/ago_downloaded.png",
     *  title: "Traffic Camera Enforcement Locations in Washington DC",
     *  type: "Web Map",
     *  typeKeywords: ["ArcGIS Online", "Explorer Web Map", "Map", "Online Map", "Web Map"],
     * }
     *
     * /////////////
     * // Public
     * /////////////
     * {
     *  access: "public",
     *  additionalResources: []
     *  boundary: {...}
     *  categories: []
     *  collection: ["Map"]
     *  commentsEnabled: true
     *  composeStatus: {...}
     *  composedAt: 1629220762412
     *  content: "Web Map"
     *  created: 1619446871000
     *  culture: "en-us"
     *  description: "A pretty brief summary"
     *  downloadable: false
     *  enrichCoverage: "global"
     *  enrichQuality: 55
     *  errors: []
     *  extent: {...}
     *  groupIds: []
     *  hasApi: false
     *  hubType: "Web Map"
     *  id: "ebfe6f6712ff4a23b5447f0ce53d65c2"
     *  itemExtent: [...]
     *  itemModified: 1629220760000
     *  license: "none"
     *  modified: 1629220760000
     *  modifiedProvenance: "item.modified"
     *  name: "My map"
     *  openData: false
     *  orgExtent: {...}
     *  orgId: "Xj56SBi2udA78cC9"
     *  orgName: "QA Premium Alpha Hub"
     *  organization: "QA Premium Alpha Hub"
     *  owner: "juliana_pa"
     *  region: "US"
     *  searchDescription: "A pretty brief summary"
     *  server: null
     *  size: 1142
     *  slug: "qa-pre-a-hub::my-map"
     *  snippet: "A pretty brief summary"
     *  source: "QA Premium Alpha Hub"
     *  sourceProvenance: "org.name"
     *  structuredLicense: { type: "none" }
     *  tags: []
     *  thumbnail: "thumbnail/ago_downloaded.png"
     *  thumbnailUrl: "thumbnail/ago_downloaded.png"
     *  title: "My map"type: "Web Map"
     *  typeCategories: ["Map"]
     *  typeKeywords: ["ArcGIS Hub", "ArcGIS Online", "Explorer Web Map", "Map", "Online Map", "Web Map"]
     *  validExtent: true
     * }
     * ```
     *
     * @param request - the IContentSearchRequest instance for searching
     *
     */
    function searchContent(request) {
        var _a;
        if (request === void 0) { request = { filter: {}, options: {} }; }
        return __awaiter(this, void 0, void 0, function () {
            var siteModel, siteCatalog, group, orgid, response, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0: return [4 /*yield*/, getSiteModelFromOptions(request.options)];
                    case 1:
                        siteModel = _c.sent();
                        siteCatalog = (_a = siteModel === null || siteModel === void 0 ? void 0 : siteModel.data) === null || _a === void 0 ? void 0 : _a.catalog;
                        if (siteCatalog) {
                            group = siteCatalog.groups, orgid = siteCatalog.orgId;
                            request.filter = __assign({ group: group, orgid: orgid }, request.filter);
                        }
                        if (!hubCommon.getProp(request, "options.isPortal")) return [3 /*break*/, 3];
                        return [4 /*yield*/, performEnterpriseContentSearch(request)];
                    case 2:
                        _b = _c.sent();
                        return [3 /*break*/, 5];
                    case 3: return [4 /*yield*/, performHubContentSearch(request)];
                    case 4:
                        _b = _c.sent();
                        _c.label = 5;
                    case 5:
                        response = _b;
                        if (siteModel) {
                            // append the absolute URL to the content on the site
                            response.results = response.results.map(function (content) {
                                return hubCommon.setContentSiteUrls(content, siteModel);
                            });
                        }
                        return [2 /*return*/, response];
                }
            });
        });
    }
    function performEnterpriseContentSearch(request, defaultPortal, defaultAuthentication) {
        var requestParams = convertToPortalParams(request, defaultPortal, defaultAuthentication);
        return searchItems(requestParams).then(function (response) {
            return convertPortalResponse(requestParams, response);
        });
    }
    /**
     * Function to search the Hub API (v3)
     * using the same arguments as searchContent()
     *
     * NOTE: this returns the Hub API's raw JSONAPI response
     * and invalid parameters like isPortal will be ignored
     *
     * @param request - see searchContent()
     * @returns Hub API's JSONAPI response
     */
    function searchDatasets(request) {
        var params = convertToHubParams(request);
        var requestOptions = __assign(__assign({}, getHubRequestOptions(request.options)), { params: params });
        return hubCommon.hubApiSearch(requestOptions);
    }
    function performHubContentSearch(request) {
        var authentication = hubCommon.getProp(request, "options.authentication");
        return searchDatasets(request).then(function (response) {
            var requestParams = convertToHubParams(request);
            return convertHubResponse(requestParams, response, authentication);
        });
    }
    function getSiteModelFromOptions(options) {
        if (!options || !options.site)
            return null;
        var ro = getHubRequestOptions(options);
        return hubCommon.fetchSite(options.site, ro);
    }
    // used above
    function getHubRequestOptions(options) {
        return {
            authentication: options.authentication,
            isPortal: options.isPortal,
            hubApiUrl: hubCommon.getHubApiUrl(options.portal),
            portal: hubCommon.getPortalApiUrl(options.portal),
        };
    }

    var apiTypes = hubCommon.categories.apiTypes.map(function (type) { return type.toLowerCase(); });
    // implements the 'hasApi' facet from AGO results. V3 datasets have this property computed
    // during the harvesting process but AGO results need this result computed at runtime
    function hasApiAgg(agoAggregations) {
        if (agoAggregations === void 0) { agoAggregations = {}; }
        var typeAggs = (hubCommon.getProp(agoAggregations, "counts") || []).filter(function (agg) { return agg.fieldName === "type"; })[0];
        if (!typeAggs)
            return { hasApi: {} };
        return typeAggs.fieldValues.reduce(function (formattedAggs, fieldVal) {
            if (apiTypes.indexOf(fieldVal.value) > -1) {
                formattedAggs.hasApi.true += fieldVal.count;
            }
            else {
                formattedAggs.hasApi.false += fieldVal.count;
            }
            return formattedAggs;
        }, { hasApi: { true: 0, false: 0 } });
    }

    // implements the 'downloadable' facet from AGO results. V3 datasets have this property computed
    // during the harvesting process but AGO results need this result computed at runtime
    function downloadableAgg(response) {
        // Get counts of true and false for downloadable facet
        // i.e. { true: 10, false: 15 }
        return response.results.reduce(function (formattedAggs, result) {
            if ((result.typeKeywords || []).indexOf("Data") > -1 ||
                hubCommon.categories.downloadableTypes.indexOf(result.type) > -1) {
                formattedAggs.downloadable.true++;
            }
            else {
                formattedAggs.downloadable.false++;
            }
            return formattedAggs;
        }, { downloadable: { true: 0, false: 0 } });
    }

    // implements the 'collection' facet from AGO results. V3 datasets have this property computed
    // during the harvesting process but AGO results need this result computed at runtime
    /**
     * Calculate raw counts for collection based on AGO type aggregations
     * @param agoAggregations aggregations from ago results
     */
    function collectionAgg(agoAggregations) {
        if (agoAggregations === void 0) { agoAggregations = {}; }
        var typeAggs = (hubCommon.getProp(agoAggregations, "counts") || []).filter(function (agg) { return agg.fieldName === "type"; })[0];
        if (!typeAggs)
            return { collection: {} };
        return typeAggs.fieldValues.reduce(function (formattedAggs, fieldVal) {
            var category = hubCommon.getCategory(fieldVal.value);
            var collectionType;
            if (category) {
                // upper case first letter and return as element in array for backwards compatibility
                collectionType = category
                    .toLowerCase()
                    .split(" ")
                    .map(function (word) { return word.charAt(0).toUpperCase() + word.slice(1); })
                    .join(" ");
            }
            else {
                collectionType = "Other";
            }
            formattedAggs.collection[collectionType] = fieldVal.count;
            return formattedAggs;
        }, { collection: {} });
    }

    // format raw counts for an agg field which has format like
    // { hasApi: { 'true': 2, 'false': 4 } } or { downloadable: { 'true': 7, 'false': 0 } }
    // into v3 like { hasApi: [{ key: 'false', docCount: 4 }, { key: 'true', docCount: 2 }] }
    function format(rawCounts) {
        return Object.keys(rawCounts).reduce(function (formattedAggs, field) {
            formattedAggs[field] = Object.keys(rawCounts[field])
                .reduce(function (formatted, key) {
                formatted.push({ key: key, docCount: rawCounts[field][key] });
                return formatted;
            }, [])
                .sort(compareReverse);
            return formattedAggs;
        }, {});
    }
    function compareReverse(a, b) {
        return b.docCount > a.docCount ? 1 : -1;
    }

    var agoSupportedAggs = ["tags", "type", "access", "categories"];
    var aggsAlias = {
        collection: "type"
    };
    /**
     * Get aggreations query object that AGO understands i.e. countFields and countSize
     * only on fields supported by AGO
     * @param facets comma separated list of aggregation fields
     */
    function createAggs(facets) {
        // return aggs that are supported by AGO - tags, type, access
        var agoFacets = facets
            .split(",")
            .filter(function (facet) { return agoSupportedAggs.indexOf(facet) > -1; });
        var aliases = facets
            .split(",")
            .filter(function (facet) { return Object.keys(aggsAlias).indexOf(facet) > -1; });
        // if there is `collection` in facets, then check if its alias has already been added
        Object.keys(aggsAlias).forEach(function (key) {
            if (aliases.indexOf(key) > -1 && !(aggsAlias[key] in agoFacets)) {
                agoFacets.push(aggsAlias[key]);
            }
        });
        return {
            countFields: agoFacets.join(","),
            countSize: 200 // max supported by AGO
        };
    }

    /**
     * Flatten categories as expected by Hub
     *
     * @param {any} categoriesAggs categories aggs array as [{ key, docCount }]
     * @returns {any}
     *
     * Input example:
     * [{ key: '/categories/economy', docCount: 4 }, { key: 'categories/economy/business', docCount: 5 }]
     * Output: [{ key: 'economy', docCount: 9 }, { key: 'business', docCount: 5 }]
     */
    function flattenCategories(categoriesAggs) {
        if (categoriesAggs === void 0) { categoriesAggs = []; }
        var set = new Set();
        var exclude = ["", "categories"];
        // 1. get a flattened unique set of categories
        categoriesAggs.forEach(function (agg) {
            var candidates = agg.key
                .split("/")
                .filter(function (k) { return exclude.indexOf(k) === -1; });
            candidates.forEach(function (k) {
                set.add(k);
            });
        });
        // 2. sum docCount for unique keys
        var flattenedCategoriesAggs = Array.from(set).reduce(function (flattenedAggs, uniqueKey) {
            var docCount = categoriesAggs
                .filter(function (agg) { return agg.key.includes(uniqueKey); })
                .map(function (agg) { return agg.docCount; })
                .reduce(function (x, y) { return x + y; });
            flattenedAggs.push({
                key: uniqueKey,
                docCount: docCount
            });
            return flattenedAggs;
        }, []);
        return flattenedCategoriesAggs;
    }

    var legalSortFields = [
        "title",
        "created",
        "type",
        "owner",
        "modified",
        "avgrating",
        "numratings",
        "numcomments",
        "numviews"
    ];
    var hubSortFieldToAGOSortFieldMap = {
        name: "title"
    };
    function getSortField(field) {
        if (legalSortFields.indexOf(field) >= 0) {
            return field;
        }
        else if (field in hubSortFieldToAGOSortFieldMap) {
            return hubSortFieldToAGOSortFieldMap[field];
        }
    }

    var filterSchema = {
        orgId: {
            type: "filter",
            dataType: "string",
            defaultOp: "any",
            catalogDefinition: true
        },
        q: { type: "simple" },
        page: { type: "simple" },
        tags: {
            type: "filter",
            dataType: "string",
            defaultOp: "any"
        },
        source: {
            type: "filter",
            dataType: "string",
            defaultOp: "any"
        },
        bbox: { type: "simple" },
        location_name: { type: "simple" },
        sort: { type: "simple" },
        groupIds: {
            type: "filter",
            dataType: "string",
            defaultOp: "any",
            catalogDefinition: true
        },
        catalog: { type: "simple" },
        owner: {
            type: "filter",
            dataType: "string",
            defaultOp: "any"
        },
        access: {
            type: "filter",
            dataType: "string",
            defaultOp: "any"
        },
        type: {
            type: "filter",
            dataType: "string",
            defaultOp: "any"
        },
        hubType: {
            type: "filter",
            dataType: "string",
            defaultOp: "any"
        },
        downloadable: {
            type: "filter",
            dataType: "boolean"
        },
        hasApi: {
            type: "filter",
            dataType: "boolean"
        },
        openData: {
            type: "filter",
            dataType: "boolean"
        },
        id: {
            type: "filter",
            dataType: "string",
            defaultOp: "any",
            catalogDefinition: true
        },
        collection: {
            type: "filter",
            dataType: "string",
            defaultOp: "any"
        },
        sector: {
            type: "filter",
            dataType: "string",
            defaultOp: "any"
        },
        region: {
            type: "filter",
            dataType: "string",
            defaultOp: "any"
        },
        initiativeId: {
            type: "filter",
            dataType: "string",
            defaultOp: "any",
            catalogDefinition: true
        },
        categories: {
            type: "filter",
            dataType: "string",
            defaultOp: "any"
        },
        license: {
            type: "filter",
            dataType: "string",
            defaultOp: "any"
        },
        modified: {
            type: "filter",
            dataType: "string",
            defaultOp: "between"
        }
    };

    /**
     * Create filters object based on raw params like tags=a,b or tags=any(a,b)
     *
     * @param {ISearchParams} params
     * @returns {any}
     */
    // return a standard filter object
    // given a query string that looks like this:
    //
    // ?tags=tag1,tag2&source=source1,source2
    //
    // This function will return a filter like:
    //
    // {
    //   filter: {
    //     tags: {
    //       fn: 'all',
    //       terms: [ 'tag1', 'tag2' ]
    //     },
    //     source: {
    //       fn: 'any',
    //       terms: [ 'source1', 'source2' ]
    //     }
    //   }
    // }
    function createFilters(params) {
        if (!params) {
            return {};
        }
        var filter = Object.keys(params).reduce(function (filters, key) {
            var filterDefinition = filterSchema[key] || {};
            if (params[key] &&
                filterDefinition.type === "filter" &&
                filterDefinition.dataType) {
                var values = params[key];
                filters[key] = generateFilter(values, filterDefinition);
            }
            return filters;
        }, {});
        return filter;
    }
    function generateFilter(values, filterDefinition) {
        var match = values.match(/(any|all|between)\((.+)\)/);
        if (match) {
            return {
                fn: match[1],
                terms: match[2].split(","),
                catalogDefinition: filterDefinition.catalogDefinition
            };
        }
        else {
            return {
                fn: filterDefinition.defaultOp || null,
                terms: values.split(","),
                catalogDefinition: filterDefinition.catalogDefinition
            };
        }
    }

    function encodeFilters(filters) {
        if (filters === void 0) { filters = {}; }
        return Object.keys(filters)
            .map(function (name) {
            var attribute = filters[name];
            var fn = attribute.fn, terms = attribute.terms;
            // filters that are part of the catalog definition are OR'd together then and-ed to the query
            var type = attribute.catalogDefinition ? "catalog" : "filter";
            var key = encodeURIComponent(type + "[" + name + "]");
            var values = terms.map(encodeURIComponent).join(",");
            return fn ? key + "=" + fn + "(" + values + ")" : key + "=" + values;
        })
            .join("&");
    }

    function buildFilter(queryFilters, key) {
        var terms = hubCommon.getProp(queryFilters, key + ".terms") || [];
        var joinType = hubCommon.getProp(queryFilters, key + ".fn");
        // all params to AGO queries MUST be lower case, so we're going to force
        // lowerCase here because we use `orgId` for Hub index, and need it as `orgid`
        // for AGO. This will allow us to use whatever casing for Hub and still
        // adhere to AGO requirements
        var filter;
        if (joinType === "between") {
            var startDate = terms[0];
            var endDate = terms[1];
            if (startDate === endDate) {
                // add 1 day
                endDate = hubCommon.addDays(startDate, 1);
            }
            var timestamps = [startDate, endDate].map(function (term) {
                return new Date(term).getTime();
            });
            filter = key.toLowerCase() + ": [" + timestamps.join(agoJoin(joinType)) + "]";
        }
        else {
            filter = terms
                .map(function (term) { return key.toLowerCase() + ":\"" + term + "\""; })
                .join(agoJoin(joinType));
        }
        if (joinType === "not") {
            // "not" filter means everything but not those given terms
            filter = "NOT " + filter;
        }
        return "(" + filter + ")";
    }
    // This function returns the AGO-translation for the query types
    // 'any' -> ' OR '
    // 'all' => ' AND '
    // 'not' => ' NOT '
    // ... more filters to come, like the ones below
    // 'gt' => ...
    // 'lt' => ...
    // 'gte' => ...
    // 'lte' => ...
    // 'range' => ...
    function agoJoin(joinType) {
        var key = joinType || "any";
        var joinMap = {
            any: " OR ",
            all: " AND ",
            not: " NOT ",
            between: " TO "
        };
        return joinMap[key];
    }

    // builds the filter for the 'downloadable' facet
    function downloadableFilter(queryFilters) {
        var download = (hubCommon.getProp(queryFilters, "downloadable.terms") || [])[0];
        var downloadFilter;
        var typeKeywordFilter;
        if (download === "true") {
            downloadFilter = hubCommon.categories.downloadableTypes.map(function (type) {
                return "type:\"" + type + "\"";
            });
            typeKeywordFilter = hubCommon.categories.downloadableTypeKeywords.map(function (type) {
                return "typekeywords:\"" + type + "\"";
            });
        }
        else {
            downloadFilter = hubCommon.categories.downloadableTypes.map(function (type) {
                return "-type:\"" + type + "\"";
            });
            typeKeywordFilter = hubCommon.categories.downloadableTypeKeywords.map(function (type) {
                return "-typekeywords:\"" + type + "\"";
            });
        }
        return "(" + downloadFilter.concat(typeKeywordFilter).join(" OR ") + ")";
    }

    function hasApiFilter(queryFilters) {
        var hasApiTrue = (hubCommon.getProp(queryFilters, "hasApi.terms") || [])[0];
        var apiFilter;
        if (hasApiTrue) {
            apiFilter = hubCommon.categories.apiTypes
                .map(function (type) {
                return "type:\"" + type + "\"";
            })
                .join(" OR ");
        }
        else {
            apiFilter = hubCommon.categories.apiTypes
                .map(function (type) {
                return "-type:\"" + type + "\"";
            })
                .join(" OR ");
        }
        return "(" + apiFilter + ")";
    }

    // builds the groupIds filter
    function groupIds(queryFilters) {
        var groups = hubCommon.getProp(queryFilters, "groupIds.terms") || [];
        var groupsFilter = groups
            .map(function (id) {
            return "group:\"" + id + "\"";
        })
            .join(" OR ");
        return "(" + groupsFilter + ")";
    }

    function collectionFilter(queryFilters) {
        var categories = hubCommon.getProp(queryFilters, "collection.terms") || [];
        var typesArr = categories.map(function (c) { return hubCommon.getTypes(c); });
        // flatten typesArr
        var filter = typesArr
            .filter(function (types) { return !!types; })
            .reduce(function (singleArr, types) {
            types.forEach(function (type) {
                singleArr.push("type:\"" + type + "\"");
            });
            return singleArr;
        }, [])
            .join(" OR ");
        return "(" + filter + ")";
    }

    // custom filter functions
    var customFilters = {
        downloadable: downloadableFilter,
        hasApi: hasApiFilter,
        groupIds: groupIds,
        collection: collectionFilter
    };
    function isCustomFilter(filter) {
        return !!customFilters[filter];
    }
    /**
     * Convert filter object into AGO filter string
     * @param queryFilters filter object created by create-filters like { tags: { fn: 'all', terms: ['a'] } }
     */
    function handleFilter(queryFilters) {
        var catalogDefinition = [];
        var otherFilters = [];
        Object.keys(queryFilters).forEach(function (key) {
            var clause;
            if (isCustomFilter(key)) {
                clause = customFilters[key](queryFilters, key);
            }
            else {
                clause = buildFilter(queryFilters, key);
            }
            if (queryFilters[key].catalogDefinition) {
                catalogDefinition.push(clause);
            }
            else {
                otherFilters.push(clause);
            }
        });
        if (catalogDefinition.length) {
            var catalogClause = "(" + catalogDefinition.join(" OR ") + ")";
            if (otherFilters.length) {
                return catalogClause + " AND (" + otherFilters.join(" AND ") + ")";
            }
            else {
                return catalogClause;
            }
        }
        else if (otherFilters.length) {
            return otherFilters.join(" AND ");
        }
        else {
            return "";
        }
    }

    /**
     * Url-encoding of search params. This function is generic enough to encode a deeply nested object
     * ```
     * Example:
     * Input: { a: { b: 2 }, c: 3 }
     * Output: 'a[b]=2&c=3'
     * ```
     * @param {Any} params (query params from hub indexer)
     * @returns {String}
     */
    function encodeParams(params) {
        if (params === void 0) { params = {}; }
        // get raw paths
        var paths = getPaths(params);
        var flatPaths = paths.filter(function (path) {
            return typeof hubCommon.getProp(params, path.join(".")) !== "object";
        });
        var parts = [];
        // for each nested path, we want to surround it with `[]`
        // i.e. if a path is like ['a', 'b'], we want encoding as 'a[b]=2' given the input object { a: { b: 2 }, c: 3 }
        flatPaths.forEach(function (path) {
            var str = "";
            for (var i = 0; i < path.length; i++) {
                if (i === 0) {
                    str += path[i];
                }
                else {
                    str += "[" + path[i] + "]";
                }
            }
            var right = encodeURIComponent(hubCommon.getProp(params, path.join(".")) || "");
            var left = encodeURIComponent(str);
            if (right) {
                parts.push(left + "=" + right);
            }
            return str;
        });
        var serialized = parts.join("&");
        return serialized;
    }
    /**
     * Get all paths to properties of an object as an array of arrays
     * where each array is a path to a property in the nested object
     * ```
     * Example:
     * Input: { a: { b: 2 }, c: 3 }
     * Output: [['a'], ['a', 'b'], ['c']]
     * ```
     * @param {Any} root the input object
     * @returns {String}
     */
    function getPaths(root) {
        if (root === void 0) { root = {}; }
        var paths = [];
        var nodes = [
            {
                obj: root,
                path: []
            }
        ];
        var _loop_1 = function () {
            var n = nodes.pop();
            Object.keys(n.obj).forEach(function (k) {
                if (typeof n.obj[k] === "object") {
                    var path = n.path.concat(k);
                    paths.push(path);
                    nodes.unshift({
                        obj: n.obj[k],
                        path: path
                    });
                }
                else {
                    paths.push(n.path.concat(k));
                }
            });
        };
        while (nodes.length > 0) {
            _loop_1();
        }
        return paths;
    }

    /**
     * Construct a query object with filters, and queryParams sent by hub indexer
     * @param queryObject any
     */
    function encodeAgoQuery(queryParams) {
        if (queryParams === void 0) { queryParams = {}; }
        var query = {
            q: null,
            start: hubCommon.getProp(queryParams, "page.start") || 1,
            num: hubCommon.getProp(queryParams, "page.size") || 10
        };
        // start with 'implicit' query filters
        var queryParts = ['-type:"code attachment"'];
        if (queryParams.restricted) {
            queryParts.push("-access:public");
        }
        // Build the potentially enourmous 'q' parameter. In future use SearchQueryBuilder from arcgis-rest-js
        if (queryParams.q) {
            queryParts.push(queryParams.q);
        }
        if (queryParams.catalog) {
            var filter = createFilters(queryParams.catalog);
            queryParts.push(handleFilter(filter));
        }
        var implicitFilters = createFilters(queryParams);
        // queryParams filter is an obj with key<string>: value<string> where value is serialized as 'all(a,b)'
        // so parse each filter string into fn and terms
        var explicitFilters = createFilters(queryParams.filter);
        var filters = __assign(__assign({}, implicitFilters), explicitFilters);
        if (Object.keys(filters).length) {
            // add each parsed filter object into ago query
            queryParts.push(handleFilter(filters));
        }
        // cleanse queryParts by removing blank strings
        queryParts = queryParts.filter(function (qp) { return !!qp; });
        query.q = queryParts.join(" AND ");
        if (queryParams.bbox) {
            query.bbox = queryParams.bbox;
        }
        if (queryParams.sort) {
            var sortOrder = queryParams.sort[0] === "-" ? "desc" : "asc";
            // AGO supports sorting on only 1 field at a time
            var sortField = sortOrder === "desc"
                ? queryParams.sort.substring(1).split(",")[0]
                : queryParams.sort.split(",")[0];
            sortField = getSortField(sortField);
            if (sortField) {
                query.sortField = sortField;
                query.sortOrder = sortOrder;
            }
        }
        if (queryParams.agg && queryParams.agg.fields) {
            // fields may be passed as array of fields, rather than comma-separated string
            // if so join fields to string, else leave as is
            var fields = void 0;
            if (Array.isArray(queryParams.agg.fields)) {
                fields = queryParams.agg.fields.join(",");
            }
            else {
                fields = queryParams.agg.fields;
            }
            var _a = createAggs(fields), countFields = _a.countFields, countSize = _a.countSize;
            query.countFields = countFields;
            query.countSize = countSize;
        }
        return query;
    }

    var MAX_COUNTFIELDS = 3;
    // Search for Items in ArcGIS and return raw ago response
    function getItems(params, token, portal, authentication) {
        return __awaiter(this, void 0, void 0, function () {
            var agoParams, chunkedCountFields, promises, responses, allCounts, _i, responses_1, response, counts;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        agoParams = encodeAgoQuery(params);
                        if (!agoParams.countFields) return [3 /*break*/, 2];
                        chunkedCountFields = hubCommon.chunkArray(agoParams.countFields.split(","), MAX_COUNTFIELDS).map(function (fieldArrayChunk) { return fieldArrayChunk.join(","); });
                        promises = chunkedCountFields.map(function (chunk) {
                            var countFields = chunk;
                            return searchItems(__assign(__assign({}, agoParams), { params: {
                                    // NOTE: we shouldn't need this since we pass in authentication below
                                    token: token,
                                    countFields: countFields,
                                    countSize: agoParams.countSize,
                                }, countFields: countFields,
                                portal: portal,
                                authentication: authentication, httpMethod: "POST" }));
                        });
                        return [4 /*yield*/, Promise.all(promises)];
                    case 1:
                        responses = _a.sent();
                        allCounts = [];
                        for (_i = 0, responses_1 = responses; _i < responses_1.length; _i++) {
                            response = responses_1[_i];
                            counts = hubCommon.getProp(response, "aggregations.counts") || [];
                            allCounts = allCounts.concat(counts);
                        }
                        responses[0].aggregations = {
                            counts: allCounts,
                        };
                        return [2 /*return*/, responses[0]];
                    case 2: return [2 /*return*/, searchItems(__assign(__assign({}, agoParams), { params: {
                                // NOTE: we shouldn't need this since we pass in authentication below
                                token: token,
                            }, portal: portal, httpMethod: "POST", authentication: authentication }))];
                }
            });
        });
    }

    // these custom aggs are based on a field that are not supported by AGO aggregations
    var customAggsNotSupportedByAgo = ["downloadable"];
    // these custom aggs are based on a field that are supported by AGO aggregations
    var customAggsSupportedByAgo = ["hasApi", "collection"];
    var customAggsFunctions = {
        downloadable: downloadableAgg,
        hasApi: hasApiAgg,
        collection: collectionAgg
    };
    /**
     * Calculate item facets based on ago aggregations and/or compute custom aggregations not supported by AGO
     *
     * @param {any} agoAggregations aggregations from AGO
     * @param {ISearchParams} params search params
     * @param {String} token AGO token to make a search if calculating custom aggs like downloadable
     * @param {String} portal AGO portal against which search is being done
     * @param {UserSession} authentication UserSession object
     * @returns {Promise<any>}
     */
    function computeItemsFacets(agoAggregations, // aggregations from ago search that ago supports by default
    params, // query params are needed to another search for custom facets
    token, portal, authentication) {
        if (agoAggregations === void 0) { agoAggregations = { counts: Array() }; }
        return __awaiter(this, void 0, void 0, function () {
            var aggFields, aggs, customAggs, facets1, paramsCopy, response_1, facets2, facets3, computedFacets;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        aggFields = hubCommon.getProp(params, "agg.fields");
                        aggs = aggFields ? aggFields.split(",") : [];
                        customAggs = intersection(aggs, customAggsNotSupportedByAgo);
                        facets1 = {};
                        if (!(customAggs.length > 0)) return [3 /*break*/, 2];
                        paramsCopy = __assign(__assign({}, params), { start: 1, num: 100 });
                        paramsCopy.agg = {};
                        return [4 /*yield*/, getItems(paramsCopy, token, portal, authentication)];
                    case 1:
                        response_1 = _a.sent();
                        customAggs.forEach(function (customAgg) {
                            var rawCounts = customAggsFunctions[customAgg](response_1);
                            facets1 = __assign(__assign({}, facets1), format(rawCounts));
                        });
                        _a.label = 2;
                    case 2:
                        facets2 = agoAggregations.counts.reduce(function (formattedAggs, agg) {
                            formattedAggs[agg.fieldName] = agg.fieldValues.map(function (fieldVal) {
                                return {
                                    key: fieldVal.value,
                                    docCount: fieldVal.count
                                };
                            });
                            return formattedAggs;
                        }, {});
                        // 3. for custom aggs that are based on some field included in ago aggs
                        customAggs = intersection(aggs, customAggsSupportedByAgo);
                        facets3 = {};
                        if (customAggs.length > 0) {
                            customAggs.forEach(function (customAgg) {
                                var rawCounts = __assign({}, customAggsFunctions[customAgg](agoAggregations));
                                facets3 = __assign(__assign({}, facets3), format(rawCounts));
                            });
                        }
                        computedFacets = __assign(__assign(__assign({}, facets1), facets2), facets3);
                        // 4. format categories facet
                        if (computedFacets.categories) {
                            computedFacets.categories = flattenCategories(computedFacets.categories);
                        }
                        return [2 /*return*/, computedFacets];
                }
            });
        });
    }
    function intersection(arr1, arr2) {
        return arr1.filter(function (val) { return arr2.indexOf(val) !== -1; });
    }

    function calcHighlights(input, query, property) {
        // 1. identify all the matches case insensitively
        // 2. Replace the original match(es) with mark tags
        // We want to match case insensitively but highlight case sensitively the original term
        // E.g. input string: `Capital bike share... blah blah capital.... CAPITAL`
        // We would like to highlight: `Capital`, `capital`, `CAPITAL`
        if (!input)
            return undefined;
        try {
            var matches = input.match(new RegExp(query, "ig")); // search globally and case insensitively
            if (!matches)
                return undefined;
            return matches.reduce(injectHighlightMarkdown(property), input);
        }
        catch (err) {
            // the most likely error is that the RegExp could not be compiled, eg: query=*
            // this is not catastrophic failure
            return undefined;
        }
    }
    function injectHighlightMarkdown(property) {
        return function (highlights, match) {
            // match is what appears as is in the input string
            var replacement = "<mark class=\"hub-search-highlight " + property + "-highlight\">" + match + "</mark>";
            // replace the case sensitive match with mark tags
            return highlights.replace(new RegExp(match, "g"), replacement);
        };
    }

    function formatItem(item, query) {
        var formattedItem = {
            id: item.id,
            type: "item",
            attributes: formatItemAttributes(item)
        };
        if (query) {
            // create highlights since AGO does not return them
            formattedItem.meta = {};
            formattedItem.meta.highlights = highlights(item, query);
        }
        return formattedItem;
    }
    function formatItemAttributes(item) {
        var hubType = hubCommon.getCategory(item.type);
        var additionalAttrs = {
            // computed or null attributes so items & datasets look the same
            name: item.title,
            searchDescription: item.description,
            hubType: hubType || "Other",
            collection: hubCommon.getTypeCategories(item),
            extent: formatExtent(item.extent)
        };
        return __assign(__assign({}, item), additionalAttrs);
    }
    function formatExtent(extent) {
        return {
            coordinates: extent,
            type: "envelope"
        };
    }
    function highlights(item, query) {
        // calculate highlights based on AGO restricted item, hence use description field but return as `searchDescription`
        // because the search-result/component expects searchDescription
        return {
            name: calcHighlights(item.title, query, "name"),
            searchDescription: calcHighlights(item.description, query, "description")
        };
    }

    // This function is responsible for formatting results from the AGO API into the JSONAPI collection format
    function agoFormatItemCollection(searchResults, facets, params) {
        if (facets === void 0) { facets = {}; }
        var queryParams = __assign({}, params);
        return {
            data: searchResults.results.map(function (result) {
                return formatItem(result, queryParams.q);
            }),
            meta: {
                query: searchResults.query,
                queryParameters: queryParams,
                stats: {
                    aggs: facets,
                    count: searchResults.results.length,
                    totalCount: searchResults.total
                },
                page: {
                    start: searchResults.start,
                    size: searchResults.num,
                    nextStart: searchResults.nextStart
                }
            }
        };
    }

    /* Copyright (c) 2018 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * Search for Items in ArcGIS, compute facets and format the response into V3 like datasets
     *
     * @export
     * @param {ISearchParams} params (query params from hub indexer)
     * @param {UserSession} authentication
     * @returns {Promise<ISearchResult>}
     */
    function agoSearch(params, token, portal, authentication) {
        return __awaiter(this, void 0, void 0, function () {
            var agoResponse, facets, model;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, getItems(params, token, portal, authentication)];
                    case 1:
                        agoResponse = _a.sent();
                        return [4 /*yield*/, computeItemsFacets(agoResponse.aggregations, params, token, portal)];
                    case 2:
                        facets = _a.sent();
                        model = agoFormatItemCollection(agoResponse, facets, params);
                        return [2 /*return*/, model];
                }
            });
        });
    }

    /**
     * ```
     * serialize raw query parameters into hub specific URI encoding
     * Example:
     * Input: { q: 'crime', tags: 'a,b,c', sort: 'name' }
     * Output: 'q=crime&tags=all(a,b,c)&sort=name'
     * ```
     * @export
     * @param {ISearchParams} searchParams
     * @returns {string}
     */
    function serialize(searchParams) {
        // 1. handle filterable params like tags, source, hasApi, groupIds since they follow custom logic
        var filters = createFilters(searchParams);
        var encodedFilters = encodeFilters(filters);
        // 2. handle non-filters like q, sort etc which have <string: string> type and also nested types like page, agg.
        // extract non-filterable fields from search params
        var nonFilterKeys = Object.keys(searchParams).filter(function (param) { return !isFilterable(param); });
        var nonFilterSearchParams = {};
        nonFilterKeys.forEach(function (key) {
            nonFilterSearchParams[key] = searchParams[key];
        });
        var encodedNonFilters = encodeParams(nonFilterSearchParams);
        var parts = [];
        // don't include blank strings in the URI encoding
        if (encodedNonFilters)
            parts.push(encodedNonFilters);
        if (encodedFilters)
            parts.push(encodedFilters);
        return parts.join("&");
    }
    function isFilterable(field) {
        return filterSchema[field] && filterSchema[field].type === "filter";
    }

    /**
     * k-way merge implementation that merges (and potentially sorts) k individually sorted arrays
     * based on the k-way merge algorithm (https://en.wikipedia.org/wiki/K-way_merge_algorithm)
     *
     * If a comparator function used to compare data is provided, a k-way merge sort is performed using
     * a Binary Heap implementation. Otherwise data from each input array is merged incrementally
     *
     * The returned object contains merged (and potentially sorted) data, as well as key-value
     * pairs that represent the index of a result set in the "data" parameter (the key) tied to how
     * many results (the value) of that result set were added to the final merged data array.
     * For example, if "data" represents an array of two result sets, with 3 and 5 results added to the final
     * result set, respectively, the returned object would be { data: [...], "0": 3, "1": 5 }
     *
     * @param data An array of result sets, each an array of type T
     * @param resultLimit the maximum number of merged results to return, defaults to 10
     * @param cmptr comparator function that takes in two instances of type T and returns a negative number if a is less than b, a positive if a is greater than b, 0 if equal
     * @param direction specifies whether data should be ordered ascending or descending
     * @returns list of results and key-value pairs indicating how many from each were added to returned data
     */
    function kMerge(data, resultLimit, cmptr, direction) {
        if (resultLimit === void 0) { resultLimit = 10; }
        var results = cmptr
            ? kMergeSort(data, cmptr, direction, resultLimit)
            : kMergeDefault(data, resultLimit);
        // Zero-fill any result set that did not have any results added to final
        for (var i = 0; i < data.length; i++) {
            if (!results[i.toString()]) {
                results[i.toString()] = 0;
            }
        }
        return results;
    }
    function kMergeDefault(data, resultLimit) {
        var results = {
            data: []
        };
        var totalDataRemaining = _getRemainingResults(data);
        var _loop_1 = function () {
            var _a;
            var dataToAdd = [];
            data.forEach(function (dataArr, index) {
                if (dataArr.length > 0 &&
                    _canDataBeAdded(dataToAdd, results.data, resultLimit)) {
                    results[index.toString()] = results[index.toString()]
                        ? results[index.toString()] + 1
                        : 1;
                    dataToAdd.push(dataArr.splice(0, 1)[0]);
                }
            });
            (_a = results.data).push.apply(_a, dataToAdd);
            totalDataRemaining = _getRemainingResults(data);
        };
        while (!_hasReachedLimit(results.data.length, resultLimit) &&
            totalDataRemaining > 0) {
            _loop_1();
        }
        return results;
    }
    function kMergeSort(data, cmptr, direction, resultLimit) {
        var nodes = data.map(function (datum, index) { return ({ data: datum, label: index.toString() }); });
        var heap = new BinaryHeap(nodes, cmptr, direction);
        var results = {
            data: []
        };
        while (results.data.length < resultLimit && heap.length() > 0) {
            var node = heap.remove();
            if (node.data.length > 0) {
                results[node.label] = results[node.label] ? results[node.label] + 1 : 1;
                results.data.push(node.data.splice(0, 1)[0]);
                heap.insert(node);
            }
        }
        return results;
    }
    function _getRemainingResults(data) {
        return data.reduce(function (length, arr) {
            return length + arr.length;
        }, 0);
    }
    function _hasReachedLimit(results, resultLimit) {
        return results - resultLimit >= 0;
    }
    function _canDataBeAdded(dataToAdd, resultsAdded, resultLimit) {
        return resultsAdded.length + dataToAdd.length < resultLimit;
    }
    /**
     * Binary Heap Implementation that implements the 'insert' and 'remove' methods
     * of the IBinaryHeap interface. Example use is for k-way merge sorting of k sorted arrays.
     * Performance is O(n log n) for initialization (could be further optimized), O(log n) for insertion and O(log n) for deletion
     *
     * @param nodes An array of INode objects of type T. If undefined or null are explicitly provided it defaults to empty array
     * @param cmptr comparator function that takes in two instances of type T and returns a number to determine sorting order
     * @param direction A HeapDirection that determines if heap should be min ("ASC") or max ("DESC") implementation
     */
    var BinaryHeap = /** @class */ (function () {
        function BinaryHeap(nodes, cmptr, direction) {
            if (direction === void 0) { direction = "ASC"; }
            this._validate({ cmptr: cmptr, direction: direction });
            this._comparator = cmptr;
            this._direction = direction;
            this._initialize(nodes);
        }
        /**
         * Inserts node into binary heap
         * @param node
         */
        BinaryHeap.prototype.insert = function (node) {
            if (!this._hasData(node)) {
                return;
            }
            this._nodes.push(node);
            var currIndex = this.length() - 1;
            var parentIndex = this._getParentIndex(currIndex);
            while (this._shouldSwap(parentIndex, currIndex)) {
                this._swap(parentIndex, currIndex);
                currIndex = parentIndex;
                parentIndex = this._getParentIndex(currIndex);
            }
        };
        /**
         * Removes either the minimum or the maximum node, depending on heap implementation
         * @returns the min/max node or null if heap is empty.
         */
        BinaryHeap.prototype.remove = function () {
            if (this.length() === 0)
                return null;
            this._swap(0, this.length() - 1);
            var node = this._nodes.pop();
            this._siftDown(0);
            return node;
        };
        /**
         * Returns number of nodes in heap
         * @returns number of nodes
         */
        BinaryHeap.prototype.length = function () {
            return this._nodes.length;
        };
        /**
         * Returns a readonly version of the heap as an array
         * @returns Readonly array representation of the heap
         */
        BinaryHeap.prototype.heap = function () {
            return this._nodes;
        };
        BinaryHeap.prototype._initialize = function (nodes) {
            this._nodes = [];
            if (!nodes || nodes.length === 0) {
                return;
            }
            for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
                var node = nodes_1[_i];
                this.insert(node);
            }
        };
        BinaryHeap.prototype._siftDown = function (index) {
            var _a;
            var _b = this._getChildIndices(index), childOne = _b[0], childTwo = _b[1];
            var childIndexToSwap = this._shouldSwap(childOne, childTwo)
                ? childTwo
                : childOne;
            while (!this._isInvalidIndex(childIndexToSwap) &&
                this._shouldSwap(index, childIndexToSwap)) {
                this._swap(index, childIndexToSwap);
                index = childIndexToSwap;
                _a = this._getChildIndices(index), childOne = _a[0], childTwo = _a[1];
                childIndexToSwap = this._shouldSwap(childOne, childTwo)
                    ? childTwo
                    : childOne;
            }
        };
        BinaryHeap.prototype._getParentIndex = function (index) {
            return Math.trunc((index - 1) / 2);
        };
        BinaryHeap.prototype._getChildIndices = function (index) {
            return [index * 2 + 1, index * 2 + 2];
        };
        BinaryHeap.prototype._shouldSwap = function (lowerIndex, higherIndex) {
            if (this._isInvalidIndex(lowerIndex) || this._isInvalidIndex(higherIndex)) {
                return false;
            }
            return ((this._greaterThan(lowerIndex, higherIndex) &&
                this._direction === "ASC") ||
                (this._lessThan(lowerIndex, higherIndex) && this._direction === "DESC"));
        };
        BinaryHeap.prototype._isInvalidIndex = function (index) {
            return index < 0 || index >= this.length();
        };
        BinaryHeap.prototype._lessThan = function (lowerIndex, higherIndex) {
            return (this._comparator(this._nodes[lowerIndex].data, this._nodes[higherIndex].data) < 0);
        };
        BinaryHeap.prototype._greaterThan = function (lowerIndex, higherIndex) {
            return (this._comparator(this._nodes[lowerIndex].data, this._nodes[higherIndex].data) > 0);
        };
        BinaryHeap.prototype._hasData = function (node) {
            return node && node.data !== undefined && node.data !== null;
        };
        BinaryHeap.prototype._swap = function (one, two) {
            if (one === two)
                return;
            var oneCopy = this._nodes[one];
            this._nodes[one] = this._nodes[two];
            this._nodes[two] = oneCopy;
        };
        BinaryHeap.prototype._validate = function (args) {
            if (!args.cmptr) {
                throw new Error("Comparator function must be defined");
            }
            if (!args.direction) {
                throw new Error("Provided heap direction is invalid");
            }
        };
        return BinaryHeap;
    }());

    /**
     * The default merge function for merging aggregations. Simply sums the aggregations
     * @param valueOne the value of one aggregatiom
     * @param valueTwo the value of the second aggregation
     * @returns the sum of the two values
     */
    var sumAggregations = function (valueOne, valueTwo) {
        return valueOne + valueTwo;
    };
    /**
     * Function to merge multiple aggregations results from different result sets. Explicitly assumed
     * that sets can contain overlapping aggregations that should be merged. Also explicitly assumed
     * that they can contain aggregation values that are undefined or null (0 is valid),
     * and/or contain entire aggregation result sets that are empty or falsey
     *
     * @param aggs a list of aggregation result sets from different requests/sources
     * @param mergeFunction a merge function used to merge aggregation values across result sets
     * @returns a list of merged aggregations
     */
    function mergeAggregations(aggs, mergeFunction) {
        if (aggs === void 0) { aggs = []; }
        if (mergeFunction === void 0) { mergeFunction = sumAggregations; }
        if (!Array.isArray(aggs) || aggs.length === 0) {
            return [];
        }
        var aggResultMapList = aggs.map(function (aggResultList) {
            return _combineAggResultsToMap(aggResultList);
        });
        var mergedMap = _createMergedMap(aggResultMapList, mergeFunction);
        return _convertMapToResult(mergedMap);
    }
    function _combineAggResultsToMap(aggResultList) {
        return aggResultList.reduce(function (aggResultMap, aggResult) {
            var aggMap = _createAggMap(aggResult);
            if (Object.keys(aggMap).length > 0) {
                var lowercasedFieldName = aggResult.fieldName.toLowerCase();
                aggResultMap[lowercasedFieldName] = aggMap;
            }
            return aggResultMap;
        }, {});
    }
    function _createAggMap(aggResult) {
        var aggregations = aggResult.aggregations || [];
        return aggregations.reduce(function (map, agg) {
            if (agg.value !== undefined && agg.value !== null) {
                var lowercasedLabel = agg.label.toLowerCase();
                map[lowercasedLabel] = agg.value;
            }
            return map;
        }, {});
    }
    function _createMergedMap(aggResultMapList, mergeFunction) {
        return aggResultMapList.reduce(function (mergedMap, map) {
            Object.keys(map).forEach(function (fieldName) {
                if (!mergedMap[fieldName]) {
                    mergedMap[fieldName] = map[fieldName];
                }
                else {
                    mergedMap[fieldName] = _mergeMaps(mergedMap[fieldName], map[fieldName], mergeFunction);
                }
            });
            return mergedMap;
        }, {});
    }
    function _mergeMaps(existingMap, newMap, mergeFunction) {
        var mergedMap = Object.assign(existingMap);
        Object.keys(newMap).forEach(function (label) {
            if (!mergedMap[label]) {
                mergedMap[label] = newMap[label];
            }
            else {
                mergedMap[label] = mergeFunction(existingMap[label], newMap[label]);
            }
        });
        return mergedMap;
    }
    function _convertMapToResult(mergedMap) {
        return Object.keys(mergedMap).map(function (fieldName) {
            var aggregations = Object.keys(mergedMap[fieldName]).map(function (name) {
                return {
                    label: name,
                    value: mergedMap[fieldName][name]
                };
            });
            return {
                fieldName: fieldName,
                aggregations: aggregations
            };
        });
    }

    var InvalidPaginationInputError = /** @class */ (function (_super) {
        __extends(InvalidPaginationInputError, _super);
        function InvalidPaginationInputError(message, input) {
            var _this = _super.call(this, message) || this;
            _this.input = input;
            return _this;
        }
        return InvalidPaginationInputError;
    }(Error));

    /**
     * When multiple data sources underly a paginated search, the search implementation should be able to
     * search at the appropriate starting point for each source for a given paged set of results. This
     * function merges an array of page states for each source, denoted by their label, into a base64-
     * encoded cursor string that the implementation can use for the next set of results.
     *
     * @param pages an array of page states denoted by their label and the starting point for the next page
     * @returns a base64-encoded cursor string to use when obtaining next page of results.
     *
     */
    function mergePages(pages) {
        if (!pages || !Array.isArray(pages)) {
            throw new InvalidPaginationInputError("Invalid Input Error. Must be array of IDataPageNextStart, received: " + typeof pages, pages);
        }
        var mergedPages = pages.reduce(function (pageObj, page) {
            pageObj[page.label] = page.nextPageStart || 1;
            return pageObj;
        }, {});
        return hubCommon.btoa(JSON.stringify(mergedPages));
    }

    /**
     * Defines an enum SortDirection
     */
    exports.SortDirection = void 0;
    (function (SortDirection) {
        SortDirection["asc"] = "asc";
        SortDirection["desc"] = "desc";
    })(exports.SortDirection || (exports.SortDirection = {}));

    exports.ContentSearchService = ContentSearchService;
    exports.agoFormatItemCollection = agoFormatItemCollection;
    exports.agoSearch = agoSearch;
    exports.computeItemsFacets = computeItemsFacets;
    exports.kMerge = kMerge;
    exports.mergeAggregations = mergeAggregations;
    exports.mergePages = mergePages;
    exports.searchContent = searchContent;
    exports.searchDatasets = searchDatasets;
    exports.serialize = serialize;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=search.umd.js.map
