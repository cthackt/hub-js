interface INode<T> {
    data: T;
    label: string;
}
interface IBinaryHeap<T> {
    insert(node: INode<T>): void;
    remove(): INode<T> | null;
}
declare type comparator<T> = (one: T, two: T) => number;
declare type HeapDirection = "ASC" | "DESC";
/**
 * k-way merge implementation that merges (and potentially sorts) k individually sorted arrays
 * based on the k-way merge algorithm (https://en.wikipedia.org/wiki/K-way_merge_algorithm)
 *
 * If a comparator function used to compare data is provided, a k-way merge sort is performed using
 * a Binary Heap implementation. Otherwise data from each input array is merged incrementally
 *
 * The returned object contains merged (and potentially sorted) data, as well as key-value
 * pairs that represent the index of a result set in the "data" parameter (the key) tied to how
 * many results (the value) of that result set were added to the final merged data array.
 * For example, if "data" represents an array of two result sets, with 3 and 5 results added to the final
 * result set, respectively, the returned object would be { data: [...], "0": 3, "1": 5 }
 *
 * @param data An array of result sets, each an array of type T
 * @param resultLimit the maximum number of merged results to return, defaults to 10
 * @param cmptr comparator function that takes in two instances of type T and returns a negative number if a is less than b, a positive if a is greater than b, 0 if equal
 * @param direction specifies whether data should be ordered ascending or descending
 * @returns list of results and key-value pairs indicating how many from each were added to returned data
 */
export declare function kMerge<T>(data: T[][], resultLimit?: number, cmptr?: comparator<T[]>, direction?: HeapDirection): {
    data: T[];
    [key: string]: any;
};
/**
 * Binary Heap Implementation that implements the 'insert' and 'remove' methods
 * of the IBinaryHeap interface. Example use is for k-way merge sorting of k sorted arrays.
 * Performance is O(n log n) for initialization (could be further optimized), O(log n) for insertion and O(log n) for deletion
 *
 * @param nodes An array of INode objects of type T. If undefined or null are explicitly provided it defaults to empty array
 * @param cmptr comparator function that takes in two instances of type T and returns a number to determine sorting order
 * @param direction A HeapDirection that determines if heap should be min ("ASC") or max ("DESC") implementation
 */
export declare class BinaryHeap<T> implements IBinaryHeap<T> {
    private _nodes;
    private readonly _comparator;
    private readonly _direction;
    constructor(nodes: Array<INode<T>>, cmptr: comparator<T>, direction?: HeapDirection);
    /**
     * Inserts node into binary heap
     * @param node
     */
    insert(node: INode<T>): void;
    /**
     * Removes either the minimum or the maximum node, depending on heap implementation
     * @returns the min/max node or null if heap is empty.
     */
    remove(): INode<T> | null;
    /**
     * Returns number of nodes in heap
     * @returns number of nodes
     */
    length(): number;
    /**
     * Returns a readonly version of the heap as an array
     * @returns Readonly array representation of the heap
     */
    heap(): ReadonlyArray<INode<T>>;
    private _initialize;
    private _siftDown;
    private _getParentIndex;
    private _getChildIndices;
    private _shouldSwap;
    private _isInvalidIndex;
    private _lessThan;
    private _greaterThan;
    private _hasData;
    private _swap;
    private _validate;
}
export {};
