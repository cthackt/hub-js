/* Copyright (c) 2018 Environmental Systems Research Institute, Inc.
 * Apache-2.0 */
import { __assign } from "tslib";
import { createGroup, protectGroup, searchGroups, removeGroup, unprotectGroup, } from "@esri/arcgis-rest-portal";
/**
 * Create an initiative collaboration or open data group
 * Note: This does not ensure a group with the proposed name does not exist. Please use
 * `checkGroupExists
 *
 * @export
 * @param {string} name
 * @param {string} description
 * @param {*} options {isOpenData: boolean, isSharedEditing: boolean}
 * @param {IRequestOptions} requestOptions
 * @returns {Promise<IInitiativeModel>}
 */
export function createInitiativeGroup(name, description, options, requestOptions) {
    var group = {
        title: name,
        description: description,
        access: "org",
        sortField: "title",
        sortOrder: "asc",
    };
    if (options.isOpenData) {
        group.isOpenData = true;
        group.tags = ["Hub Initiative Group", "Open Data"];
        group.access = "public";
    }
    if (options.isSharedEditing) {
        group.capabilities = "updateitemcontrol";
        group._edit_privacy = "on";
        group._edit_contributors = "on";
        group.tags = ["Hub Initiative Group", "initiativeCollaborationGroup"];
    }
    var createOpts = __assign({ group: group }, requestOptions);
    // The protect call does not return the groupId, but we need to return it
    // from this function, so we create a var in this scope to hold it...
    var groupId;
    // create the group
    return createGroup(createOpts)
        .then(function (result) {
        groupId = result.group.id;
        // protect it
        var protectOpts = __assign({ id: groupId }, requestOptions);
        return protectGroup(protectOpts);
    })
        .then(function () {
        return groupId;
    });
}
/**
 * Remove an Initiative group.
 * This assumes the group is protected
 *
 * @export
 * @param {string} id
 * @param {IRequestOptions} requestOptions
 * @returns {Promise<any>}
 */
export function removeInitiativeGroup(id, requestOptions) {
    var opts = __assign({ id: id }, requestOptions);
    return unprotectGroup(opts).then(function () {
        return removeGroup(opts);
    }, function (ex) {
        // check if the failure is b/c the group does not exist...
        if (ex.messageCode === "COM_0003" && ex.code === 400) {
            return Promise.resolve({ success: true });
        }
        else {
            throw ex;
        }
    });
}
/**
 * Check if a group with a specific title exists in an org
 * If it does exist, and has the correct properties, we return the
 * @export
 * @param {string} title
 * @param {string} orgId
 * @param {IRequestOptions} requestOptions
 * @returns {Promise<boolean>}
 */
export function checkGroupExists(title, orgId, requestOptions) {
    var options = __assign({ q: "(orgid: " + orgId, filter: "title:\"" + title + "\"" }, requestOptions);
    return searchGroups(options).then(function (response) {
        var result = {
            exists: false,
        };
        if (response.total > 0) {
            result.exists = true;
            result.group = response.results[0];
        }
        return result;
    });
}
/**
 * Group names must be unique within an organization
 *
 * @export
 * @param {string} title
 * @param {string} orgId
 * @param {number} [step=0]
 * @param {IRequestOptions} requestOptions
 * @returns {Promise<string>}
 */
export function getUniqueGroupName(title, orgId, step, requestOptions) {
    var proposedName = title;
    if (step) {
        proposedName = title + " - " + step;
    }
    return checkGroupExists(proposedName, orgId, requestOptions).then(function (result) {
        if (result.exists) {
            // increment the step...
            step = step + 1;
            return getUniqueGroupName(title, orgId, step, requestOptions);
        }
        else {
            return proposedName;
        }
    });
}
export function isSharedEditingGroup(group) {
    return !!(group.capabilities.indexOf("updateitemcontrol") > -1);
}
//# sourceMappingURL=groups.js.map