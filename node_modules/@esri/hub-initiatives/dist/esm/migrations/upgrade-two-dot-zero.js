import { __spreadArrays } from "tslib";
/* Copyright (c) 2018 Environmental Systems Research Institute, Inc.
 * Apache-2.0 */
import { getProp, cloneObject } from "@esri/hub-common";
/**
 * Given an object, conduct checks to see if it is an indicator
 * @protected
 */
export var isIndicator = function (obj) {
    var result = false;
    if (Array.isArray(obj.fields) && obj.fields.length > 0) {
        result = true;
    }
    return result;
};
/**
 * Convert the CAS formatted "field" into the new schema
 * @protected
 */
export var convertIndicatorField = function (field) {
    return {
        id: field.fieldName,
        name: field.label,
        optional: field.optional || false,
        description: field.tooltip,
        supportedTypes: __spreadArrays(field.supportedTypes)
    };
};
/**
 * Convert a CAS formatted indicator to the .definition in the new schama
 * @protected
 */
export var convertIndicatorToDefinition = function (ind) {
    var def = {
        id: ind.fieldName,
        type: "Data",
        name: ind.label || ind.fieldName,
        optional: ind.optional || false,
        definition: {
            description: ind.label || ind.fieldName,
            supportedTypes: __spreadArrays(ind.layerOptions.supportedTypes),
            geometryTypes: __spreadArrays(ind.layerOptions.geometryTypes),
            fields: ind.fields.map(convertIndicatorField)
        }
    };
    return def;
};
/**
 * Given the Indicators entry from a CAS configurationSettings array,
 * convert to an indicators object in the new schema
 * @protected
 */
export function convertIndicatorsToDefinitions(indicatorsHash) {
    // the incoming structure should have a .fields property, and what we want will be in there...
    if (!indicatorsHash.fields || !Array.isArray(indicatorsHash.fields)) {
        indicatorsHash.fields = [];
    }
    var defs = indicatorsHash.fields.map(convertIndicatorToDefinition);
    // now we need to create an object which has props for each def
    return defs;
}
/**
 * Given the values hash, locate the properties that are Indicators
 * and return an array of cloned objects
 * @protected
 */
export var extractIndicators = function (values) {
    return Object.keys(values).reduce(function (acc, prop) {
        var obj = values[prop];
        if (isIndicator(obj)) {
            var clone = cloneObject(obj);
            // we want to keep the prop name as the id
            clone.id = prop;
            acc.push(clone);
        }
        return acc;
    }, []);
};
/**
 * CAS format had the field properties nested but
 * the new format is flattened
 * @protected
 */
export var flattenField = function (field) {
    return {
        id: field.id,
        name: field.field.name,
        alias: field.field.alias,
        type: field.field.type
    };
};
/**
 * Given the indicator value object (from the Initiative), extract
 * the properties to create the .source hash
 * @protected
 */
export var convertIndicatorValueToSource = function (indicator) {
    return {
        type: "Feature Layer",
        url: indicator.url,
        itemId: indicator.itemId,
        layerId: indicator.layerId,
        name: indicator.name || indicator.id,
        mappings: indicator.fields.map(flattenField)
    };
};
/**
 * Convert the "source" information
 * @protected
 */
export var convertIndicator = function (indicator) {
    var result = {
        id: indicator.id,
        type: "Data",
        name: indicator.name || indicator.id,
        definition: {
            description: indicator.name || indicator.id
        },
        source: convertIndicatorValueToSource(indicator)
    };
    return result;
};
/**
 * Given the values hash that contains indicators, extract them
 * convert them, and return the indicators hash
 * @protected
 */
export var convertInitiativeIndicators = function (values) {
    return extractIndicators(values).map(convertIndicator);
};
/**
 * Given a Step object, return a new object with the
 * updated schema
 * @protected
 */
export var convertStep = function (step) {
    // can't use object spread b/c there are props we don't want to carry forward
    var templates = step.templates || [];
    var items = step.items || [];
    return {
        title: step.title,
        description: step.description,
        id: step.id,
        templateIds: templates.map(byId),
        itemIds: items.map(byId)
    };
};
/**
 * given the array of steps (prop names), construct an array
 * of the actual step objects while also falttening templates
 * and items arrays to just ids
 * @protected
 */
export var convertSteps = function (steps, values) {
    if (steps && Array.isArray(steps)) {
        return steps.map(function (stepName) {
            return convertStep(values[stepName]);
        });
    }
    else {
        return [];
    }
};
/**
 * Extract the id property from an entry
 *
 * @protected
 * @param {*} entry
 * @returns
 */
export function byId(entry) {
    return entry.id;
}
/**
 * Apply the 1.1 --> 2.0 Migration to an Initiative Model
 *
 * @protected
 * @param {IInitiativeModel} model
 * @param {string} [portalUrl]
 * @returns {IInitiativeModel}
 */
export function upgradeToTwoDotZero(model, portalUrl) {
    var curVersion = getProp(model, "item.properties.schemaVersion");
    if (curVersion < 2) {
        var clone_1 = cloneObject(model);
        // store the schemaVersion
        clone_1.item.properties.schemaVersion = 2.0;
        // convert the values and values.steps into data.steps
        clone_1.data.steps = convertSteps(clone_1.data.values.steps, clone_1.data.values);
        if (clone_1.data.values.steps) {
            // remove the data.values.steps properties
            clone_1.data.values.steps.forEach(function (propName) {
                delete clone_1.data.values[propName];
            });
            delete clone_1.data.values.steps;
        }
        // convert the indicators
        clone_1.data.indicators = convertInitiativeIndicators(clone_1.data.values);
        return clone_1;
    }
    else {
        return model;
    }
}
//# sourceMappingURL=upgrade-two-dot-zero.js.map