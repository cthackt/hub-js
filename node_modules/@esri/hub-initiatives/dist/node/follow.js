"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.unfollowInitiative = exports.followInitiative = exports.isUserFollowing = exports.currentlyFollowedInitiatives = void 0;
const arcgis_rest_request_1 = require("@esri/arcgis-rest-request");
const arcgis_rest_portal_1 = require("@esri/arcgis-rest-portal");
const hub_common_1 = require("@esri/hub-common");
const get_1 = require("./get");
const getUserTag = (initiativeId) => `hubInitiativeId|${initiativeId}`;
const initiativeIdFromUserTag = (tag) => tag.replace(/^hubInitiativeId\|/, "");
const initiativeIdFromGroupTag = (tag) => tag.replace(/^hubInitiativeFollowers\|/, "");
const getUpdateUrl = (session) => `${arcgis_rest_portal_1.getUserUrl(session)}/update`;
const currentlyFollowedInitiativesByUserTag = (user) => user.tags.map(initiativeIdFromUserTag);
const currentlyFollowedInitiativesByGroupMembership = (user) => {
    return user.groups
        .map(group => group.tags)
        .reduce((acc, item) => acc.concat(item), [])
        .filter(tags => tags.indexOf("hubInitiativeFollowers|") === 0)
        .map(initiativeIdFromGroupTag);
};
exports.currentlyFollowedInitiatives = (user) => {
    const byUserTags = currentlyFollowedInitiativesByUserTag(user);
    const byGroupMembership = currentlyFollowedInitiativesByGroupMembership(user);
    return [...byUserTags, ...byGroupMembership].filter(hub_common_1.unique);
};
exports.isUserFollowing = (user, initiativeId) => exports.currentlyFollowedInitiatives(user).indexOf(initiativeId) > -1;
/**
 * ```js
 * import { followInitiative } from "@esri/hub-initiatives";
 * //
 * followInitiative({
 *   initiativeId,
 *   authentication
 * })
 *   .then(response)
 * ```
 * Follow an initiative.
 */
function followInitiative(requestOptions) {
    // we dont call getUser() because the tags are cached and will be mutating
    return arcgis_rest_request_1.request(arcgis_rest_portal_1.getUserUrl(requestOptions.authentication), {
        authentication: requestOptions.authentication
    })
        .then(user => {
        // don't update if already following
        if (exports.isUserFollowing(user, requestOptions.initiativeId)) {
            return Promise.reject(`user is already following this initiative.`);
        }
        // if not already following, pass the user on
        return user;
    })
        .then(user => {
        return get_1.getInitiative(requestOptions.initiativeId, requestOptions).then((initiative) => ({
            user,
            initiative,
            hasFollowersGroup: false
        }));
    })
        .then(obj => {
        // if the initiative has a followersGroupId
        const groupId = hub_common_1.getProp(obj, "initiative.item.properties.followersGroupId");
        if (groupId) {
            // attempt to join it
            return arcgis_rest_portal_1.joinGroup({
                id: groupId,
                authentication: requestOptions.authentication
            }).then(groupJoinResponse => {
                obj.hasFollowersGroup = groupJoinResponse.success;
                return obj;
            });
        }
        return obj;
    })
        .then(obj => {
        if (!obj.hasFollowersGroup) {
            // else add the tag to the user
            const tag = getUserTag(requestOptions.initiativeId);
            const tags = JSON.parse(JSON.stringify(obj.user.tags));
            tags.push(tag);
            return arcgis_rest_request_1.request(getUpdateUrl(requestOptions.authentication), {
                params: { tags },
                authentication: requestOptions.authentication
            });
        }
        // the initiative has a followers group and we successfully joined it
        return { success: true, username: obj.user.username };
    });
}
exports.followInitiative = followInitiative;
/**
 * ```js
 * import { unfollowInitiative } from "@esri/hub-initiatives";
 * //
 * unfollowInitiative({
 *   initiativeId,
 *   authentication
 * })
 *   .then(response)
 * ```
 * Un-follow an initiative.
 */
function unfollowInitiative(requestOptions) {
    // we dont call getUser() because the tags are cached and will be mutating
    return arcgis_rest_request_1.request(arcgis_rest_portal_1.getUserUrl(requestOptions.authentication), {
        authentication: requestOptions.authentication
    })
        .then(user => {
        // don't update if not already following
        if (!exports.isUserFollowing(user, requestOptions.initiativeId)) {
            return Promise.reject(`user is not following this initiative.`);
        }
        // if already following, pass the user on
        return user;
    })
        .then(user => {
        const tag = getUserTag(requestOptions.initiativeId);
        const tags = JSON.parse(JSON.stringify(user.tags));
        if (tags.indexOf(tag) > -1) {
            // https://stackoverflow.com/questions/9792927/javascript-array-search-and-remove-string
            const index = tags.indexOf(tag);
            tags.splice(index, 1);
            // clear the last tag by passing ",".
            if (tags.length === 0) {
                tags.push(",");
            }
            return arcgis_rest_request_1.request(getUpdateUrl(requestOptions.authentication), {
                params: { tags },
                authentication: requestOptions.authentication
            }).then(_ => user);
        }
        return user;
    })
        .then(user => {
        return get_1.getInitiative(requestOptions.initiativeId, requestOptions).then((initiative) => ({ user, initiative }));
    })
        .then(obj => {
        // if there is an initiative followers group and the user is a member, attempt to leave it
        const groupId = hub_common_1.getProp(obj, "initiative.item.properties.followersGroupId");
        if (groupId &&
            currentlyFollowedInitiativesByGroupMembership(obj.user).indexOf(requestOptions.initiativeId) > -1) {
            return arcgis_rest_portal_1.leaveGroup({
                id: groupId,
                authentication: requestOptions.authentication
            }).then(groupLeaveResponse => {
                return { success: true, username: obj.user.username };
            });
        }
        return { success: true, username: obj.user.username };
    });
}
exports.unfollowInitiative = unfollowInitiative;
//# sourceMappingURL=follow.js.map