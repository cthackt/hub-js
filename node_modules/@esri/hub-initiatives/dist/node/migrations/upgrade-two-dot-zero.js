"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.upgradeToTwoDotZero = exports.byId = exports.convertSteps = exports.convertStep = exports.convertInitiativeIndicators = exports.convertIndicator = exports.convertIndicatorValueToSource = exports.flattenField = exports.extractIndicators = exports.convertIndicatorsToDefinitions = exports.convertIndicatorToDefinition = exports.convertIndicatorField = exports.isIndicator = void 0;
/* Copyright (c) 2018 Environmental Systems Research Institute, Inc.
 * Apache-2.0 */
const hub_common_1 = require("@esri/hub-common");
/**
 * Given an object, conduct checks to see if it is an indicator
 * @protected
 */
exports.isIndicator = function (obj) {
    let result = false;
    if (Array.isArray(obj.fields) && obj.fields.length > 0) {
        result = true;
    }
    return result;
};
/**
 * Convert the CAS formatted "field" into the new schema
 * @protected
 */
exports.convertIndicatorField = function (field) {
    return {
        id: field.fieldName,
        name: field.label,
        optional: field.optional || false,
        description: field.tooltip,
        supportedTypes: [...field.supportedTypes]
    };
};
/**
 * Convert a CAS formatted indicator to the .definition in the new schama
 * @protected
 */
exports.convertIndicatorToDefinition = function (ind) {
    const def = {
        id: ind.fieldName,
        type: "Data",
        name: ind.label || ind.fieldName,
        optional: ind.optional || false,
        definition: {
            description: ind.label || ind.fieldName,
            supportedTypes: [...ind.layerOptions.supportedTypes],
            geometryTypes: [...ind.layerOptions.geometryTypes],
            fields: ind.fields.map(exports.convertIndicatorField)
        }
    };
    return def;
};
/**
 * Given the Indicators entry from a CAS configurationSettings array,
 * convert to an indicators object in the new schema
 * @protected
 */
function convertIndicatorsToDefinitions(indicatorsHash) {
    // the incoming structure should have a .fields property, and what we want will be in there...
    if (!indicatorsHash.fields || !Array.isArray(indicatorsHash.fields)) {
        indicatorsHash.fields = [];
    }
    const defs = indicatorsHash.fields.map(exports.convertIndicatorToDefinition);
    // now we need to create an object which has props for each def
    return defs;
}
exports.convertIndicatorsToDefinitions = convertIndicatorsToDefinitions;
/**
 * Given the values hash, locate the properties that are Indicators
 * and return an array of cloned objects
 * @protected
 */
exports.extractIndicators = function (values) {
    return Object.keys(values).reduce((acc, prop) => {
        const obj = values[prop];
        if (exports.isIndicator(obj)) {
            const clone = hub_common_1.cloneObject(obj);
            // we want to keep the prop name as the id
            clone.id = prop;
            acc.push(clone);
        }
        return acc;
    }, []);
};
/**
 * CAS format had the field properties nested but
 * the new format is flattened
 * @protected
 */
exports.flattenField = function (field) {
    return {
        id: field.id,
        name: field.field.name,
        alias: field.field.alias,
        type: field.field.type
    };
};
/**
 * Given the indicator value object (from the Initiative), extract
 * the properties to create the .source hash
 * @protected
 */
exports.convertIndicatorValueToSource = function (indicator) {
    return {
        type: "Feature Layer",
        url: indicator.url,
        itemId: indicator.itemId,
        layerId: indicator.layerId,
        name: indicator.name || indicator.id,
        mappings: indicator.fields.map(exports.flattenField)
    };
};
/**
 * Convert the "source" information
 * @protected
 */
exports.convertIndicator = function (indicator) {
    const result = {
        id: indicator.id,
        type: "Data",
        name: indicator.name || indicator.id,
        definition: {
            description: indicator.name || indicator.id
        },
        source: exports.convertIndicatorValueToSource(indicator)
    };
    return result;
};
/**
 * Given the values hash that contains indicators, extract them
 * convert them, and return the indicators hash
 * @protected
 */
exports.convertInitiativeIndicators = function (values) {
    return exports.extractIndicators(values).map(exports.convertIndicator);
};
/**
 * Given a Step object, return a new object with the
 * updated schema
 * @protected
 */
exports.convertStep = function (step) {
    // can't use object spread b/c there are props we don't want to carry forward
    const templates = step.templates || [];
    const items = step.items || [];
    return {
        title: step.title,
        description: step.description,
        id: step.id,
        templateIds: templates.map(byId),
        itemIds: items.map(byId)
    };
};
/**
 * given the array of steps (prop names), construct an array
 * of the actual step objects while also falttening templates
 * and items arrays to just ids
 * @protected
 */
exports.convertSteps = function (steps, values) {
    if (steps && Array.isArray(steps)) {
        return steps.map(stepName => {
            return exports.convertStep(values[stepName]);
        });
    }
    else {
        return [];
    }
};
/**
 * Extract the id property from an entry
 *
 * @protected
 * @param {*} entry
 * @returns
 */
function byId(entry) {
    return entry.id;
}
exports.byId = byId;
/**
 * Apply the 1.1 --> 2.0 Migration to an Initiative Model
 *
 * @protected
 * @param {IInitiativeModel} model
 * @param {string} [portalUrl]
 * @returns {IInitiativeModel}
 */
function upgradeToTwoDotZero(model, portalUrl) {
    const curVersion = hub_common_1.getProp(model, "item.properties.schemaVersion");
    if (curVersion < 2) {
        const clone = hub_common_1.cloneObject(model);
        // store the schemaVersion
        clone.item.properties.schemaVersion = 2.0;
        // convert the values and values.steps into data.steps
        clone.data.steps = exports.convertSteps(clone.data.values.steps, clone.data.values);
        if (clone.data.values.steps) {
            // remove the data.values.steps properties
            clone.data.values.steps.forEach((propName) => {
                delete clone.data.values[propName];
            });
            delete clone.data.values.steps;
        }
        // convert the indicators
        clone.data.indicators = exports.convertInitiativeIndicators(clone.data.values);
        return clone;
    }
    else {
        return model;
    }
}
exports.upgradeToTwoDotZero = upgradeToTwoDotZero;
//# sourceMappingURL=upgrade-two-dot-zero.js.map