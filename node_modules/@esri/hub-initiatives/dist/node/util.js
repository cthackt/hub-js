"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addImageAsResource = exports.copyEmbeddedImageResources = exports.copyImageResources = void 0;
const arcgis_rest_portal_1 = require("@esri/arcgis-rest-portal");
const hub_common_1 = require("@esri/hub-common");
/**
 *  Copy an set of image resources from one item to another
 *
 * @export
 * @param {string} sourceItemId
 * @param {string} targetItemId
 * @param {string} owner
 * @param {[string]} assets
 * @param {IRequestOptions} requestOptions
 * @returns {Promise<boolean>}
 */
function copyImageResources(sourceItemId, targetItemId, owner, assets, requestOptions) {
    const itemResourceUrl = `${hub_common_1.getPortalApiUrl(requestOptions)}/content/items/${sourceItemId}/resources`;
    /* istanbul ignore next blob responses are difficult to make cross platform we will just have to trust the isomorphic fetch will do its job */
    return requestOptions.authentication
        .getToken(itemResourceUrl)
        .then(token => {
        const assetPromises = assets.map(assetName => {
            const sourceUrl = `${itemResourceUrl}/${assetName}?token=${token}`;
            return addImageAsResource(targetItemId, owner, assetName, sourceUrl, requestOptions);
        });
        // This is really more of a fire-and-forget thing, as the Portal API
        // adds these requests into a queue for processing
        return Promise.all(assetPromises);
    })
        .then(() => {
        return true;
    });
}
exports.copyImageResources = copyImageResources;
/**
 *  Copy an set of embedded resources to an item
 *
 * @export
 * @param {string} targetItemId destination item id
 * @param {string} owner destination item owner
 * @param {any[]} assets list of assets to copy
 * @param {IRequestOptions} requestOptions
 * @returns {Promise<boolean>}
 */
function copyEmbeddedImageResources(targetItemId, owner, assets, requestOptions) {
    // need to move resources from embedded template into AGO
    const promises = assets.map((asset) => {
        return addImageAsResource(targetItemId, owner, asset.name, asset.url, requestOptions)
            .then(() => {
            return true;
        })
            .catch(() => {
            return true; // swallow the error
        });
    });
    return Promise.all(promises).then(() => {
        return true;
    });
}
exports.copyEmbeddedImageResources = copyEmbeddedImageResources;
/**
 * Load an image from a url, and store it as a resource on an existing item
 *
 * @export
 * @param {string} itemId
 * @param {string} owner
 * @param {string} filename
 * @param {string} url
 * @param {IRequestOptions} requestOptions
 * @returns {Promise<boolean>}
 */
function addImageAsResource(id, owner, name, url, requestOptions) {
    // We must use fetch directly here because AGSjs request determines how to parse
    // the response based on the `?f=<type>` param. But sending f=<anything-other-than-json>
    // to a resource end-point, throws an error. Rock, meet Hard-Place.
    const fetchOptions = {
        method: "GET",
        // ensures behavior mimics XMLHttpRequest. needed to support sending IWA cookies
        credentials: "same-origin"
    };
    return (
    // -------------------------------------------------
    // request(url, opts)
    // -------------------------------------------------
    fetch(url, fetchOptions)
        .then(x => {
        return x.blob();
    })
        .then(blob => {
        return arcgis_rest_portal_1.addItemResource({
            id,
            owner,
            name,
            resource: blob,
            authentication: requestOptions.authentication
        }).then((response) => {
            return response.success;
        });
    }));
}
exports.addImageAsResource = addImageAsResource;
//# sourceMappingURL=util.js.map