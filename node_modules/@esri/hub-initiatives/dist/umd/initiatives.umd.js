/* @preserve
 * @esri/hub-initiatives - v9.32.1 - Wed May 18 2022 18:25:48 GMT+0000 (Coordinated Universal Time)
 * Copyright (c) 2022 Environmental Systems Research Institute, Inc.
 * Apache-2.0
 */

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@esri/hub-common')) :
    typeof define === 'function' && define.amd ? define(['exports', '@esri/hub-common'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.arcgisHub = global.arcgisHub || {}, global.arcgisHub));
})(this, (function (exports, hubCommon) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }

    /* Copyright (c) 2017 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * Checks parameters to see if we should use FormData to send the request
     * @param params The object whose keys will be encoded.
     * @return A boolean indicating if FormData will be required.
     */
    function requiresFormData(params) {
        return Object.keys(params).some(function (key) {
            var value = params[key];
            if (!value) {
                return false;
            }
            if (value && value.toParam) {
                value = value.toParam();
            }
            var type = value.constructor.name;
            switch (type) {
                case "Array":
                    return false;
                case "Object":
                    return false;
                case "Date":
                    return false;
                case "Function":
                    return false;
                case "Boolean":
                    return false;
                case "String":
                    return false;
                case "Number":
                    return false;
                default:
                    return true;
            }
        });
    }
    /**
     * Converts parameters to the proper representation to send to the ArcGIS REST API.
     * @param params The object whose keys will be encoded.
     * @return A new object with properly encoded values.
     */
    function processParams(params) {
        var newParams = {};
        Object.keys(params).forEach(function (key) {
            var _a, _b;
            var param = params[key];
            if (param && param.toParam) {
                param = param.toParam();
            }
            if (!param &&
                param !== 0 &&
                typeof param !== "boolean" &&
                typeof param !== "string") {
                return;
            }
            var type = param.constructor.name;
            var value;
            // properly encodes objects, arrays and dates for arcgis.com and other services.
            // ported from https://github.com/Esri/esri-leaflet/blob/master/src/Request.js#L22-L30
            // also see https://github.com/Esri/arcgis-rest-js/issues/18:
            // null, undefined, function are excluded. If you want to send an empty key you need to send an empty string "".
            switch (type) {
                case "Array":
                    // Based on the first element of the array, classify array as an array of arrays, an array of objects
                    // to be stringified, or an array of non-objects to be comma-separated
                    // eslint-disable-next-line no-case-declarations
                    var firstElementType = (_b = (_a = param[0]) === null || _a === void 0 ? void 0 : _a.constructor) === null || _b === void 0 ? void 0 : _b.name;
                    value =
                        firstElementType === "Array" ? param : // pass thru array of arrays
                            firstElementType === "Object" ? JSON.stringify(param) : // stringify array of objects
                                param.join(","); // join other types of array elements
                    break;
                case "Object":
                    value = JSON.stringify(param);
                    break;
                case "Date":
                    value = param.valueOf();
                    break;
                case "Function":
                    value = null;
                    break;
                case "Boolean":
                    value = param + "";
                    break;
                default:
                    value = param;
                    break;
            }
            if (value || value === 0 || typeof value === "string" || Array.isArray(value)) {
                newParams[key] = value;
            }
        });
        return newParams;
    }

    /* Copyright (c) 2017 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * Encodes keys and parameters for use in a URL's query string.
     *
     * @param key Parameter's key
     * @param value Parameter's value
     * @returns Query string with key and value pairs separated by "&"
     */
    function encodeParam(key, value) {
        // For array of arrays, repeat key=value for each element of containing array
        if (Array.isArray(value) && value[0] && Array.isArray(value[0])) {
            return value.map(function (arrayElem) { return encodeParam(key, arrayElem); }).join("&");
        }
        return encodeURIComponent(key) + "=" + encodeURIComponent(value);
    }
    /**
     * Encodes the passed object as a query string.
     *
     * @param params An object to be encoded.
     * @returns An encoded query string.
     */
    function encodeQueryString(params) {
        var newParams = processParams(params);
        return Object.keys(newParams)
            .map(function (key) {
            return encodeParam(key, newParams[key]);
        })
            .join("&");
    }

    /* Copyright (c) 2017 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * Encodes parameters in a [FormData](https://developer.mozilla.org/en-US/docs/Web/API/FormData) object in browsers or in a [FormData](https://github.com/form-data/form-data) in Node.js
     *
     * @param params An object to be encoded.
     * @returns The complete [FormData](https://developer.mozilla.org/en-US/docs/Web/API/FormData) object.
     */
    function encodeFormData(params, forceFormData) {
        // see https://github.com/Esri/arcgis-rest-js/issues/499 for more info.
        var useFormData = requiresFormData(params) || forceFormData;
        var newParams = processParams(params);
        if (useFormData) {
            var formData_1 = new FormData();
            Object.keys(newParams).forEach(function (key) {
                if (typeof Blob !== "undefined" && newParams[key] instanceof Blob) {
                    /* To name the Blob:
                     1. look to an alternate request parameter called 'fileName'
                     2. see if 'name' has been tacked onto the Blob manually
                     3. if all else fails, use the request parameter
                    */
                    var filename = newParams["fileName"] || newParams[key].name || key;
                    formData_1.append(key, newParams[key], filename);
                }
                else {
                    formData_1.append(key, newParams[key]);
                }
            });
            return formData_1;
        }
        else {
            return encodeQueryString(params);
        }
    }

    /* Copyright (c) 2017 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    // TypeScript 2.1 no longer allows you to extend built in types. See https://github.com/Microsoft/TypeScript/issues/12790#issuecomment-265981442
    // and https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work
    //
    // This code is from MDN https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Custom_Error_Types.
    var ArcGISRequestError = /** @class */ (function () {
        /**
         * Create a new `ArcGISRequestError`  object.
         *
         * @param message - The error message from the API
         * @param code - The error code from the API
         * @param response - The original response from the API that caused the error
         * @param url - The original url of the request
         * @param options - The original options and parameters of the request
         */
        function ArcGISRequestError(message, code, response, url, options) {
            message = message || "UNKNOWN_ERROR";
            code = code || "UNKNOWN_ERROR_CODE";
            this.name = "ArcGISRequestError";
            this.message =
                code === "UNKNOWN_ERROR_CODE" ? message : code + ": " + message;
            this.originalMessage = message;
            this.code = code;
            this.response = response;
            this.url = url;
            this.options = options;
        }
        return ArcGISRequestError;
    }());
    ArcGISRequestError.prototype = Object.create(Error.prototype);
    ArcGISRequestError.prototype.constructor = ArcGISRequestError;

    /* Copyright (c) 2017-2018 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * Method used internally to surface messages to developers.
     */
    function warn(message) {
        if (console && console.warn) {
            console.warn.apply(console, [message]);
        }
    }

    /* Copyright (c) 2017-2018 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    var NODEJS_DEFAULT_REFERER_HEADER = "@esri/arcgis-rest-js";
    var DEFAULT_ARCGIS_REQUEST_OPTIONS = {
        httpMethod: "POST",
        params: {
            f: "json",
        },
    };
    var ArcGISAuthError = /** @class */ (function (_super) {
        __extends(ArcGISAuthError, _super);
        /**
         * Create a new `ArcGISAuthError`  object.
         *
         * @param message - The error message from the API
         * @param code - The error code from the API
         * @param response - The original response from the API that caused the error
         * @param url - The original url of the request
         * @param options - The original options of the request
         */
        function ArcGISAuthError(message, code, response, url, options) {
            if (message === void 0) { message = "AUTHENTICATION_ERROR"; }
            if (code === void 0) { code = "AUTHENTICATION_ERROR_CODE"; }
            var _this = _super.call(this, message, code, response, url, options) || this;
            _this.name = "ArcGISAuthError";
            _this.message =
                code === "AUTHENTICATION_ERROR_CODE" ? message : code + ": " + message;
            return _this;
        }
        ArcGISAuthError.prototype.retry = function (getSession, retryLimit) {
            var _this = this;
            if (retryLimit === void 0) { retryLimit = 3; }
            var tries = 0;
            var retryRequest = function (resolve, reject) {
                getSession(_this.url, _this.options)
                    .then(function (session) {
                    var newOptions = __assign(__assign({}, _this.options), { authentication: session });
                    tries = tries + 1;
                    return request(_this.url, newOptions);
                })
                    .then(function (response) {
                    resolve(response);
                })
                    .catch(function (e) {
                    if (e.name === "ArcGISAuthError" && tries < retryLimit) {
                        retryRequest(resolve, reject);
                    }
                    else if (e.name === "ArcGISAuthError" && tries >= retryLimit) {
                        reject(_this);
                    }
                    else {
                        reject(e);
                    }
                });
            };
            return new Promise(function (resolve, reject) {
                retryRequest(resolve, reject);
            });
        };
        return ArcGISAuthError;
    }(ArcGISRequestError));
    /**
     * Checks for errors in a JSON response from the ArcGIS REST API. If there are no errors, it will return the `data` passed in. If there is an error, it will throw an `ArcGISRequestError` or `ArcGISAuthError`.
     *
     * @param data The response JSON to check for errors.
     * @param url The url of the original request
     * @param params The parameters of the original request
     * @param options The options of the original request
     * @returns The data that was passed in the `data` parameter
     */
    function checkForErrors(response, url, params, options, originalAuthError) {
        // this is an error message from billing.arcgis.com backend
        if (response.code >= 400) {
            var message = response.message, code = response.code;
            throw new ArcGISRequestError(message, code, response, url, options);
        }
        // error from ArcGIS Online or an ArcGIS Portal or server instance.
        if (response.error) {
            var _a = response.error, message = _a.message, code = _a.code, messageCode = _a.messageCode;
            var errorCode = messageCode || code || "UNKNOWN_ERROR_CODE";
            if (code === 498 ||
                code === 499 ||
                messageCode === "GWM_0003" ||
                (code === 400 && message === "Unable to generate token.")) {
                if (originalAuthError) {
                    throw originalAuthError;
                }
                else {
                    throw new ArcGISAuthError(message, errorCode, response, url, options);
                }
            }
            throw new ArcGISRequestError(message, errorCode, response, url, options);
        }
        // error from a status check
        if (response.status === "failed" || response.status === "failure") {
            var message = void 0;
            var code = "UNKNOWN_ERROR_CODE";
            try {
                message = JSON.parse(response.statusMessage).message;
                code = JSON.parse(response.statusMessage).code;
            }
            catch (e) {
                message = response.statusMessage || response.message;
            }
            throw new ArcGISRequestError(message, code, response, url, options);
        }
        return response;
    }
    /**
     * ```js
     * import { request } from '@esri/arcgis-rest-request';
     * //
     * request('https://www.arcgis.com/sharing/rest')
     *   .then(response) // response.currentVersion === 5.2
     * //
     * request('https://www.arcgis.com/sharing/rest', {
     *   httpMethod: "GET"
     * })
     * //
     * request('https://www.arcgis.com/sharing/rest/search', {
     *   params: { q: 'parks' }
     * })
     *   .then(response) // response.total => 78379
     * ```
     * Generic method for making HTTP requests to ArcGIS REST API endpoints.
     *
     * @param url - The URL of the ArcGIS REST API endpoint.
     * @param requestOptions - Options for the request, including parameters relevant to the endpoint.
     * @returns A Promise that will resolve with the data from the response.
     */
    function request(url, requestOptions) {
        if (requestOptions === void 0) { requestOptions = { params: { f: "json" } }; }
        var options = __assign(__assign(__assign({ httpMethod: "POST" }, DEFAULT_ARCGIS_REQUEST_OPTIONS), requestOptions), {
            params: __assign(__assign({}, DEFAULT_ARCGIS_REQUEST_OPTIONS.params), requestOptions.params),
            headers: __assign(__assign({}, DEFAULT_ARCGIS_REQUEST_OPTIONS.headers), requestOptions.headers),
        });
        var missingGlobals = [];
        var recommendedPackages = [];
        // don't check for a global fetch if a custom implementation was passed through
        if (!options.fetch && typeof fetch !== "undefined") {
            options.fetch = fetch.bind(Function("return this")());
        }
        else {
            missingGlobals.push("`fetch`");
            recommendedPackages.push("`node-fetch`");
        }
        if (typeof Promise === "undefined") {
            missingGlobals.push("`Promise`");
            recommendedPackages.push("`es6-promise`");
        }
        if (typeof FormData === "undefined") {
            missingGlobals.push("`FormData`");
            recommendedPackages.push("`isomorphic-form-data`");
        }
        if (!options.fetch ||
            typeof Promise === "undefined" ||
            typeof FormData === "undefined") {
            throw new Error("`arcgis-rest-request` requires a `fetch` implementation and global variables for `Promise` and `FormData` to be present in the global scope. You are missing " + missingGlobals.join(", ") + ". We recommend installing the " + recommendedPackages.join(", ") + " modules at the root of your application to add these to the global scope. See https://bit.ly/2KNwWaJ for more info.");
        }
        var httpMethod = options.httpMethod, authentication = options.authentication, rawResponse = options.rawResponse;
        var params = __assign({ f: "json" }, options.params);
        var originalAuthError = null;
        var fetchOptions = {
            method: httpMethod,
            /* ensures behavior mimics XMLHttpRequest.
            needed to support sending IWA cookies */
            credentials: options.credentials || "same-origin",
        };
        // the /oauth2/platformSelf route will add X-Esri-Auth-Client-Id header
        // and that request needs to send cookies cross domain
        // so we need to set the credentials to "include"
        if (options.headers &&
            options.headers["X-Esri-Auth-Client-Id"] &&
            url.indexOf("/oauth2/platformSelf") > -1) {
            fetchOptions.credentials = "include";
        }
        return (authentication
            ? authentication.getToken(url, { fetch: options.fetch }).catch(function (err) {
                /**
                 * append original request url and requestOptions
                 * to the error thrown by getToken()
                 * to assist with retrying
                 */
                err.url = url;
                err.options = options;
                /**
                 * if an attempt is made to talk to an unfederated server
                 * first try the request anonymously. if a 'token required'
                 * error is thrown, throw the UNFEDERATED error then.
                 */
                originalAuthError = err;
                return Promise.resolve("");
            })
            : Promise.resolve(""))
            .then(function (token) {
            if (token.length) {
                params.token = token;
            }
            if (authentication && authentication.getDomainCredentials) {
                fetchOptions.credentials = authentication.getDomainCredentials(url);
            }
            // Custom headers to add to request. IRequestOptions.headers with merge over requestHeaders.
            var requestHeaders = {};
            if (fetchOptions.method === "GET") {
                // Prevents token from being passed in query params when hideToken option is used.
                /* istanbul ignore if - window is always defined in a browser. Test case is covered by Jasmine in node test */
                if (params.token &&
                    options.hideToken &&
                    // Sharing API does not support preflight check required by modern browsers https://developer.mozilla.org/en-US/docs/Glossary/Preflight_request
                    typeof window === "undefined") {
                    requestHeaders["X-Esri-Authorization"] = "Bearer " + params.token;
                    delete params.token;
                }
                // encode the parameters into the query string
                var queryParams = encodeQueryString(params);
                // dont append a '?' unless parameters are actually present
                var urlWithQueryString = queryParams === "" ? url : url + "?" + encodeQueryString(params);
                if (
                // This would exceed the maximum length for URLs specified by the consumer and requires POST
                (options.maxUrlLength &&
                    urlWithQueryString.length > options.maxUrlLength) ||
                    // Or if the customer requires the token to be hidden and it has not already been hidden in the header (for browsers)
                    (params.token && options.hideToken)) {
                    // the consumer specified a maximum length for URLs
                    // and this would exceed it, so use post instead
                    fetchOptions.method = "POST";
                    // If the token was already added as a Auth header, add the token back to body with other params instead of header
                    if (token.length && options.hideToken) {
                        params.token = token;
                        // Remove existing header that was added before url query length was checked
                        delete requestHeaders["X-Esri-Authorization"];
                    }
                }
                else {
                    // just use GET
                    url = urlWithQueryString;
                }
            }
            /* updateResources currently requires FormData even when the input parameters dont warrant it.
        https://developers.arcgis.com/rest/users-groups-and-items/update-resources.htm
            see https://github.com/Esri/arcgis-rest-js/pull/500 for more info. */
            var forceFormData = new RegExp("/items/.+/updateResources").test(url);
            if (fetchOptions.method === "POST") {
                fetchOptions.body = encodeFormData(params, forceFormData);
            }
            // Mixin headers from request options
            fetchOptions.headers = __assign(__assign({}, requestHeaders), options.headers);
            /* istanbul ignore next - karma reports coverage on browser tests only */
            if (typeof window === "undefined" && !fetchOptions.headers.referer) {
                fetchOptions.headers.referer = NODEJS_DEFAULT_REFERER_HEADER;
            }
            /* istanbul ignore else blob responses are difficult to make cross platform we will just have to trust the isomorphic fetch will do its job */
            if (!requiresFormData(params) && !forceFormData) {
                fetchOptions.headers["Content-Type"] =
                    "application/x-www-form-urlencoded";
            }
            return options.fetch(url, fetchOptions);
        })
            .then(function (response) {
            if (!response.ok) {
                // server responded w/ an actual error (404, 500, etc)
                var status_1 = response.status, statusText = response.statusText;
                throw new ArcGISRequestError(statusText, "HTTP " + status_1, response, url, options);
            }
            if (rawResponse) {
                return response;
            }
            switch (params.f) {
                case "json":
                    return response.json();
                case "geojson":
                    return response.json();
                case "html":
                    return response.text();
                case "text":
                    return response.text();
                /* istanbul ignore next blob responses are difficult to make cross platform we will just have to trust that isomorphic fetch will do its job */
                default:
                    return response.blob();
            }
        })
            .then(function (data) {
            if ((params.f === "json" || params.f === "geojson") && !rawResponse) {
                var response = checkForErrors(data, url, params, options, originalAuthError);
                if (originalAuthError) {
                    /* If the request was made to an unfederated service that
                    didn't require authentication, add the base url and a dummy token
                    to the list of trusted servers to avoid another federation check
                    in the event of a repeat request */
                    var truncatedUrl = url
                        .toLowerCase()
                        .split(/\/rest(\/admin)?\/services\//)[0];
                    options.authentication.federatedServers[truncatedUrl] = {
                        token: [],
                        // default to 24 hours
                        expires: new Date(Date.now() + 86400 * 1000),
                    };
                    originalAuthError = null;
                }
                return response;
            }
            else {
                return data;
            }
        });
    }

    /* Copyright (c) 2017-2018 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * Helper for methods with lots of first order request options to pass through as request parameters.
     */
    function appendCustomParams(customOptions, keys, baseOptions) {
        var requestOptionsKeys = [
            "params",
            "httpMethod",
            "rawResponse",
            "authentication",
            "portal",
            "fetch",
            "maxUrlLength",
            "headers"
        ];
        var options = __assign(__assign({ params: {} }, baseOptions), customOptions);
        // merge all keys in customOptions into options.params
        options.params = keys.reduce(function (value, key) {
            if (customOptions[key] || typeof customOptions[key] === "boolean") {
                value[key] = customOptions[key];
            }
            return value;
        }, options.params);
        // now remove all properties in options that don't exist in IRequestOptions
        return requestOptionsKeys.reduce(function (value, key) {
            if (options[key]) {
                value[key] = options[key];
            }
            return value;
        }, {});
    }

    /* Copyright (c) 2018 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * Helper method to ensure that user supplied urls don't include whitespace or a trailing slash.
     */
    function cleanUrl(url) {
        // Guard so we don't try to trim something that's not a string
        if (typeof url !== "string") {
            return url;
        }
        // trim leading and trailing spaces, but not spaces inside the url
        url = url.trim();
        // remove the trailing slash to the url if one was included
        if (url[url.length - 1] === "/") {
            url = url.slice(0, -1);
        }
        return url;
    }

    /* Copyright (c) 2018 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * Wrapper for geometry service functions
     */
    var geometryService = {
        // default geometry service url
        AGO_GEOMETRY_SERVICE: "https://utility.arcgisonline.com/arcgis/rest/services/Geometry/GeometryServer",
        /**
         * Get the geometry service url.
         * If a portal object is passed, it will extract the portal's geometry server
         * otherwise, it will return the public AGO geometry service
         *
         * @param portal
         */
        getUrl: function (portal) {
            var url = this.AGO_GEOMETRY_SERVICE;
            if (portal) {
                var portalService = hubCommon.getProp(portal, "helperServices.geometry.url");
                if (portalService) {
                    url = portalService;
                }
            }
            return url;
        },
        /**
         * Should we add a token to the call - basically we never want to send
         * tokens to the public arcgisonline service.
         *
         * @param {string} url
         * @returns {boolean}
         */
        shouldAddTokenToCall: function (url) {
            var result = true;
            if (url.indexOf("arcgisonline") > -1) {
                result = false;
            }
            return result;
        },
        /**
         * Project a geometry using a specific geometry server
         *
         * @param {string} serviceUrl
         * @param {*} inSR input spatial reference - wkid or object
         * @param {*} outSR output spatial reference - wkid or object
         * @param {string} geometryType the type of the input geometries
         * @param {[any]} geometries array of geometryes
         * @param {IRequestOptions} requestOptions
         * @returns {Promise<any>}
         */
        project: function (serviceUrl, inSR, outSR, geometryType, geometries, requestOptions) {
            var url = serviceUrl + "/project";
            // we may be mutating this, so make a copy...
            var opts = __assign({}, requestOptions);
            opts.params = {
                geometries: {
                    geometryType: geometryType,
                    geometries: geometries
                },
                transformForward: false,
                transformation: "",
                inSR: inSR,
                outSR: outSR,
                f: "json"
            };
            if (!this.shouldAddTokenToCall(url) && opts.authentication) {
                // remove the authentication...
                // if the same rO is used thru multiple calls...
                delete opts.authentication;
            }
            return request(url, opts);
        }
    };
    var geometryService$1 = geometryService;

    /* Copyright (c) 2017 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * Helper that returns the appropriate portal url for a given request. `requestOptions.portal` is given
     * precedence over `authentication.portal`. If neither `portal` nor `authentication` is present,
     * `www.arcgis.com/sharing/rest` is returned.
     *
     * @param requestOptions - Request options that may have authentication manager
     * @returns Portal url to be used in API requests
     */
    function getPortalUrl(requestOptions) {
        if (requestOptions === void 0) { requestOptions = {}; }
        // use portal in options if specified
        if (requestOptions.portal) {
            return cleanUrl(requestOptions.portal);
        }
        // if auth was passed, use that portal
        if (requestOptions.authentication) {
            // the portal url is already scrubbed in the auth package
            return requestOptions.authentication.portal;
        }
        // default to arcgis.com
        return "https://www.arcgis.com/sharing/rest";
    }

    /* Copyright (c) 2017-2018 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * Serialize an item and its data into a json format accepted by the Portal API for create and update operations
     *
     * @param item Item to be serialized
     * @returns a formatted json object to be sent to Portal
     */
    function serializeItem(item) {
        // create a clone so we're not messing with the original
        var clone = JSON.parse(JSON.stringify(item));
        // binary data needs POSTed as a `file`
        // JSON object literals should be passed as `text`.
        if (clone.data) {
            (typeof Blob !== "undefined" && item.data instanceof Blob) ||
                // Node.js doesn't implement Blob
                item.data.constructor.name === "ReadStream"
                ? (clone.file = item.data)
                : (clone.text = item.data);
            delete clone.data;
        }
        return clone;
    }
    /**
     * `requestOptions.owner` is given priority, `requestOptions.item.owner` will be checked next. If neither are present, `authentication.getUserName()` will be used instead.
     */
    function determineOwner(requestOptions) {
        if (requestOptions.owner) {
            return Promise.resolve(requestOptions.owner);
        }
        else if (requestOptions.item && requestOptions.item.owner) {
            return Promise.resolve(requestOptions.item.owner);
        }
        else if (requestOptions.authentication &&
            requestOptions.authentication.getUsername) {
            return requestOptions.authentication.getUsername();
        }
        else {
            return Promise.reject(new Error("Could not determine the owner of this item. Pass the `owner`, `item.owner`, or `authentication` option."));
        }
    }

    /* Copyright (c) 2018 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * ```js
     * import { updateItem } from "@esri/arcgis-rest-portal";
     * //
     * updateItem({
     *   item: {
     *     id: "3ef",
     *     description: "A three hour tour"
     *   },
     *   authentication
     * })
     *   .then(response)
     * ```
     * Update an Item. See the [REST Documentation](https://developers.arcgis.com/rest/users-groups-and-items/update-item.htm) for more information.
     *
     * @param requestOptions - Options for the request.
     * @returns A Promise that updates an item.
     */
    function updateItem(requestOptions) {
        return determineOwner(requestOptions).then(function (owner) {
            var url = requestOptions.folderId
                ? getPortalUrl(requestOptions) + "/content/users/" + owner + "/" + requestOptions.folderId + "/items/" + requestOptions.item.id + "/update"
                : getPortalUrl(requestOptions) + "/content/users/" + owner + "/items/" + requestOptions.item.id + "/update";
            // serialize the item into something Portal will accept
            requestOptions.params = __assign(__assign({}, requestOptions.params), serializeItem(requestOptions.item));
            return request(url, requestOptions);
        });
    }

    /* Copyright (c) 2018 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * ```js
     * import { addItemResource } from "@esri/arcgis-rest-portal";
     * //
     * // Add a file resource
     * addItemResource({
     *   id: '3ef',
     *   resource: file,
     *   name: 'bigkahuna.jpg',
     *   authentication
     * })
     *   .then(response)
     * //
     * // Add a text resource
     * addItemResource({
     *   id: '4fg',
     *   content: "Text content",
     *   name: 'bigkahuna.txt',
     *   authentication
     * })
     *   .then(response)
     * ```
     * Add a resource associated with an item. See the [REST Documentation](https://developers.arcgis.com/rest/users-groups-and-items/add-resources.htm) for more information.
     *
     * @param requestOptions - Options for the request
     * @returns A Promise to add item resources.
     */
    function addItemResource(requestOptions) {
        return determineOwner(requestOptions).then(function (owner) {
            var url = getPortalUrl(requestOptions) + "/content/users/" + owner + "/items/" + requestOptions.id + "/addResources";
            requestOptions.params = __assign({ file: requestOptions.resource, fileName: requestOptions.name, resourcesPrefix: requestOptions.prefix, text: requestOptions.content, access: requestOptions.private ? "private" : "inherit" }, requestOptions.params);
            return request(url, requestOptions);
        });
    }

    /* Copyright (c) 2018 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * ```js
     * import { createItemInFolder } from "@esri/arcgis-rest-portal";
     * //
     * createItemInFolder({
     *   item: {
     *     title: "The Amazing Voyage",
     *     type: "Web Map"
     *   },
     *   folderId: 'fe8',
     *   authentication
     * })
     * ```
     * Create an item in a folder. See the [REST Documentation](https://developers.arcgis.com/rest/users-groups-and-items/add-item.htm) for more information.
     *
     * @param requestOptions = Options for the request
     */
    function createItemInFolder(requestOptions) {
        if (requestOptions.multipart && !requestOptions.filename) {
            return Promise.reject(new Error("The filename is required for a multipart request."));
        }
        return determineOwner(requestOptions).then(function (owner) {
            var baseUrl = getPortalUrl(requestOptions) + "/content/users/" + owner;
            var url = baseUrl + "/addItem";
            if (requestOptions.folderId) {
                url = baseUrl + "/" + requestOptions.folderId + "/addItem";
            }
            requestOptions.params = __assign(__assign({}, requestOptions.params), serializeItem(requestOptions.item));
            // serialize the item into something Portal will accept
            var options = appendCustomParams(requestOptions, [
                "owner",
                "folderId",
                "file",
                "dataUrl",
                "text",
                "async",
                "multipart",
                "filename",
                "overwrite"
            ], {
                params: __assign({}, requestOptions.params)
            });
            return request(url, options);
        });
    }
    /**
     * ```js
     * import { createItem } from "@esri/arcgis-rest-portal";
     * //
     * createItem({
     *   item: {
     *     title: "The Amazing Voyage",
     *     type: "Web Map"
     *   },
     *   authentication
     * })
     * ```
     * Create an Item in the user's root folder. See the [REST Documentation](https://developers.arcgis.com/rest/users-groups-and-items/add-item.htm) for more information.
     *
     * @param requestOptions - Options for the request
     * @returns A Promise that creates an item.
     */
    function createItem(requestOptions) {
        // delegate to createItemInFolder placing in the root of the filestore
        var options = __assign({ folderId: null }, requestOptions);
        return createItemInFolder(options);
    }

    /* Copyright (c) 2018 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * ```
     * import { getItem } from "@esri/arcgis-rest-portal";
     * //
     * getItem("ae7")
     *   .then(response);
     * // or
     * getItem("ae7", { authentication })
     *   .then(response)
     * ```
     * Get an item by id. See the [REST Documentation](https://developers.arcgis.com/rest/users-groups-and-items/item.htm) for more information.
     *
     * @param id - Item Id
     * @param requestOptions - Options for the request
     * @returns A Promise that will resolve with the data from the response.
     */
    function getItem(id, requestOptions) {
        var url = getItemBaseUrl(id, requestOptions);
        // default to a GET request
        var options = __assign({ httpMethod: "GET" }, requestOptions);
        return request(url, options);
    }
    /**
     * Get the fully qualified base URL to the REST end point for an item.
     * @param id Item Id
     * @param portalUrlOrRequestOptions a portal URL or request options
     * @returns URL to the item's REST end point, defaults to `https://www.arcgis.com/sharing/rest/content/items/{id}`
     */
    var getItemBaseUrl = function (id, portalUrlOrRequestOptions) {
        var portalUrl = typeof portalUrlOrRequestOptions === "string"
            ? portalUrlOrRequestOptions
            : getPortalUrl(portalUrlOrRequestOptions);
        return portalUrl + "/content/items/" + id;
    };
    /**
     * ```
     * import { getItemData } from "@esri/arcgis-rest-portal";
     * //
     * getItemData("ae7")
     *   .then(response)
     * // or
     * getItemData("ae7", { authentication })
     *   .then(response)
     * ```
     * Get the /data for an item. If no data exists, returns `undefined`. See the [REST Documentation](https://developers.arcgis.com/rest/users-groups-and-items/item-data.htm) for more information.
     * @param id - Item Id
     * @param requestOptions - Options for the request
     * @returns A Promise that will resolve with the json data for the item.
     */
    function getItemData(id, requestOptions) {
        var url = getItemBaseUrl(id, requestOptions) + "/data";
        // default to a GET request
        var options = __assign({ httpMethod: "GET", params: {} }, requestOptions);
        if (options.file) {
            options.params.f = null;
        }
        return request(url, options).catch(function (err) {
            /* if the item doesn't include data, the response will be empty
               and the internal call to response.json() will fail */
            var emptyResponseErr = RegExp(/The string did not match the expected pattern|(Unexpected end of (JSON input|data at line 1 column 1))/i);
            /* istanbul ignore else */
            if (emptyResponseErr.test(err.message)) {
                return;
            }
            else
                throw err;
        });
    }
    /**
     * Get the resources associated with an item
     *
     * @param requestOptions - Options for the request
     * @returns A Promise to get some item resources.
     */
    function getItemResources(id, requestOptions) {
        var url = getItemBaseUrl(id, requestOptions) + "/resources";
        // Mix in num:1000 with any user supplied params
        // Key thing - we don't want to mutate the passed in requestOptions
        // as that may be used in other (subsequent) calls in the course
        // of a long promise chains
        var options = __assign({}, requestOptions);
        options.params = __assign({ num: 1000 }, options.params);
        return request(url, options);
    }

    /* Copyright (c) 2018 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * Unprotect an item. See the [REST Documentation](https://developers.arcgis.com/rest/users-groups-and-items/unprotect.htm) for more information.
     *
     * @param requestOptions - Options for the request
     * @returns A Promise to unprotect an item.
     */
    function unprotectItem(requestOptions) {
        return determineOwner(requestOptions).then(function (owner) {
            var url = getPortalUrl(requestOptions) + "/content/users/" + owner + "/items/" + requestOptions.id + "/unprotect";
            return request(url, requestOptions);
        });
    }

    /* Copyright (c) 2017-2018 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * ```js
     * import { getGroup } from "@esri/arcgis-rest-portal";
     * //
     * getGroup("fxb988") // id
     *   .then(response)
     * ```
     * Fetch a group using its id. See the [REST Documentation](https://developers.arcgis.com/rest/users-groups-and-items/group.htm) for more information.
     *
     * @param id - Group Id
     * @param requestOptions  - Options for the request
     * @returns  A Promise that will resolve with the data from the response.
     */
    function getGroup(id, requestOptions) {
        var url = getPortalUrl(requestOptions) + "/community/groups/" + id;
        // default to a GET request
        var options = __assign({ httpMethod: "GET" }, requestOptions);
        return request(url, options);
    }

    /* Copyright (c) 2018 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * Get the User Membership for a particular group. Use this if all you have is the groupId.
     * If you have the group object, check the `userMembership.memberType` property instead of calling this method.
     *
     * @param requestOptions
     * @returns A Promise that resolves with "owner" | "admin" | "member" | "nonmember"
     */
    function getUserMembership(requestOptions) {
        // fetch the group...
        return getGroup(requestOptions.groupId, requestOptions)
            .then(function (group) {
            return group.userMembership.memberType;
        })
            .catch(function () {
            return "none";
        });
    }

    /* Copyright (c) 2018 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * ```js
     * import { removeItem } from "@esri/arcgis-rest-portal";
     * //
     * removeItem({
     *   id: "3ef",
     *   authentication
     * })
     * ```
     * Delete an item from the portal. See the [REST Documentation](https://developers.arcgis.com/rest/users-groups-and-items/delete-item.htm) for more information.
     *
     * @param requestOptions - Options for the request
     * @returns A Promise that deletes an item.
     */
    function removeItem(requestOptions) {
        return determineOwner(requestOptions).then(function (owner) {
            var url = getPortalUrl(requestOptions) + "/content/users/" + owner + "/items/" + requestOptions.id + "/delete";
            return request(url, requestOptions);
        });
    }

    /* Copyright (c) 2018-2021 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * `SearchQueryBuilder` can be used to construct the `q` param for
     * [`searchItems`](/arcgis-rest-js/api/portal/searchItems#searchItems-search) or
     * [`searchGroups`](/arcgis-rest-js/api/portal/searchGroups#searchGroups-search).
     * By chaining methods, it helps build complex search queries.
     *
     * ```js
     * const startDate = new Date("2020-01-01");
     * const endDate = new Date("2020-09-01");
     * const query = new SearchQueryBuilder()
     *  .match("Patrick")
     *  .in("owner")
     *  .and()
     *  .from(startDate)
     *  .to(endDate)
     *  .in("created")
     *  .and()
     *  .startGroup()
     *    .match("Web Mapping Application")
     *    .in("type")
     *    .or()
     *    .match("Mobile Application")
     *    .in("type")
     *    .or()
     *    .match("Application")
     *    .in("type")
     *  .endGroup()
     *  .and()
     *  .match("Demo App");
     *
     * searchItems(query).then((res) => {
     *   console.log(res.results);
     * });
     * ```
     *
     * Will search for items matching
     * ```
     * "owner: Patrick AND created:[1577836800000 TO 1598918400000] AND (type:"Web Mapping Application" OR type:"Mobile Application" OR type:Application) AND Demo App"
     * ```
     */
    var SearchQueryBuilder = /** @class */ (function () {
        /**
         * @param q An existing query string to start building from.
         */
        function SearchQueryBuilder(q) {
            if (q === void 0) { q = ""; }
            this.termStack = [];
            this.rangeStack = [];
            this.openGroups = 0;
            this.q = q;
        }
        /**
         * Defines strings to search for.
         *
         * ```js
         * const query = new SearchQueryBuilder()
         *   .match("My Layer")
         * ```
         *
         * @param terms strings to search for.
         */
        SearchQueryBuilder.prototype.match = function () {
            var terms = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                terms[_i] = arguments[_i];
            }
            this.termStack = this.termStack.concat(terms);
            return this;
        };
        /**
         * Defines fields to search in. You can pass `"*"` or call this method without arguments to search a default set of fields
         *
         * ```js
         * const query = new SearchQueryBuilder()
         *   .match("My Layer")
         *   .in("title")
         * ```
         *
         * @param field The field to search for the previous match in.
         */
        SearchQueryBuilder.prototype.in = function (field) {
            var fn = "`in(" + (field ? "\"" + field + "\"" : "") + ")`";
            if (!this.hasRange && !this.hasTerms) {
                warn(
                // apparently-p-rettier-ignore causes some
                fn + " was called with no call to `match(...)` or `from(...)`/`to(...)`. Your query was not modified.");
                return this;
            }
            if (field && field !== "*") {
                this.q += field + ":";
            }
            return this.commit();
        };
        /**
         * Starts a new search group.
         *
         * ```js
         * const query = new SearchQueryBuilder()
         *   .startGroup()
         *     .match("Lakes")
         *     .in("title")
         *   .endGroup()
         *   .or()
         *   .startGroup()
         *     .match("Rivers")
         *     .in("title")
         *   .endGroup()
         * ```
         */
        SearchQueryBuilder.prototype.startGroup = function () {
            this.commit();
            if (this.openGroups > 0) {
                this.q += " ";
            }
            this.openGroups++;
            this.q += "(";
            return this;
        };
        /**
         * Ends a search group.
         *
         * ```js
         * const query = new SearchQueryBuilder()
         *   .startGroup()
         *     .match("Lakes")
         *     .in("title")
         *   .endGroup()
         *   .or()
         *   .startGroup()
         *     .match("Rivers")
         *     .in("title")
         *   .endGroup()
         * ```
         */
        SearchQueryBuilder.prototype.endGroup = function () {
            if (this.openGroups <= 0) {
                warn("`endGroup(...)` was called without calling `startGroup(...)` first. Your query was not modified.");
                return this;
            }
            this.commit();
            this.openGroups--;
            this.q += ")";
            return this;
        };
        /**
         * Joins two sets of queries with an `AND` clause.
         *
         * ```js
         * const query = new SearchQueryBuilder()
         *   .match("Lakes")
         *   .in("title")
         *   .and()
         *   .match("Rivers")
         *   .in("title")
         * ```
         */
        SearchQueryBuilder.prototype.and = function () {
            return this.addModifier("and");
        };
        /**
         * Joins two sets of queries with an `OR` clause.
         *
         * ```js
         * const query = new SearchQueryBuilder()
         *   .match("Lakes")
         *   .in("title")
         *   .or()
         *   .match("Rivers")
         *   .in("title")
         * ```
         */
        SearchQueryBuilder.prototype.or = function () {
            return this.addModifier("or");
        };
        /**
         * Joins two sets of queries with a `NOT` clause. Another option for filtering results is the [prohibit operator '-'](https://developers.arcgis.com/rest/users-groups-and-items/search-reference.htm#ESRI_SECTION1_5C6C35DB9E4A4F4492C5B937BDA2BF67).
         *
         * ```js
         * // omit results with "Rivers" in their title
         * const query = new SearchQueryBuilder()
         *   .not()
         *   .match("Rivers")
         *   .in("title")
         *
         * // equivalent
         * const query = new SearchQueryBuilder()
         *   .match("Rivers")
         *   .in("-title")
         * ```
         */
        SearchQueryBuilder.prototype.not = function () {
            return this.addModifier("not");
        };
        /**
         * Begins a new range query.
         *
         * ```js
         *
         * const NEWYEARS = new Date("2020-01-01")
         * const TODAY = new Date()
         *
         * const query = new SearchQueryBuilder()
         *   .from(NEWYEARS)
         *   .to(TODAY)
         *   .in("created")
         * ```
         */
        SearchQueryBuilder.prototype.from = function (term) {
            if (this.hasTerms) {
                warn(
                // apparently-p*rettier-ignore causes prettier to strip *all* comments O_o
                "`from(...)` is not allowed after `match(...)` try using `.from(...).to(...).in(...)`. Optionally, you may see this because dates are incorrectly formatted. Dates should be a primative Date value, aka a number in milliseconds or Date object, ie new Date(\"2020-01-01\").  Your query was not modified.");
                return this;
            }
            this.rangeStack[0] = term;
            return this;
        };
        /**
         * Ends a range query.
         *
         * ```js
         * const query = new SearchQueryBuilder()
         *   .from(yesterdaysDate)
         *   .to(todaysDate)
         *   .in("created")
         * ```
         */
        SearchQueryBuilder.prototype.to = function (term) {
            if (this.hasTerms) {
                warn(
                // apparently-p*rettier-ignore causes prettier to strip *all* comments O_o
                "`to(...)` is not allowed after `match(...)` try using `.from(...).to(...).in(...)`. Optionally, you may see this because dates are incorrectly formatted. Dates should be a primative Date value, aka a number in milliseconds or Date object, ie new Date(\"2020-01-01\"). Your query was not modified.");
                return this;
            }
            this.rangeStack[1] = term;
            return this;
        };
        /**
         * Boosts the previous term to increase its rank in the results.
         *
         * ```js
         * const query = new SearchQueryBuilder()
         *   .match("Lakes")
         *   .in("title")
         *   .or()
         *   .match("Rivers")
         *   .in("title")
         *   .boost(3)
         * ```
         */
        SearchQueryBuilder.prototype.boost = function (num) {
            this.commit();
            this.q += "^" + num;
            return this;
        };
        /**
         * Returns the current query string. Called internally when the request is made.
         */
        SearchQueryBuilder.prototype.toParam = function () {
            this.commit();
            this.cleanup();
            return this.q;
        };
        /**
         * Returns a new instance of `SearchQueryBuilder` based on the current instance.
         */
        SearchQueryBuilder.prototype.clone = function () {
            this.commit();
            this.cleanup();
            return new SearchQueryBuilder(this.q + "");
        };
        SearchQueryBuilder.prototype.addModifier = function (modifier) {
            if (this.currentModifer) {
                warn(
                // apparently-p*rettier-ignore causes prettier to strip *all* comments O_o
                "You have called `" + this.currentModifer + "()` after `" + modifier + "()`. Your current query was not modified.");
                return this;
            }
            this.commit();
            if (this.q === "" && modifier !== "not") {
                warn("You have called `" + modifier + "()` without calling another method to modify your query first. Try calling `match()` first.");
                return this;
            }
            this.currentModifer = modifier;
            this.q += this.q === "" ? "" : " ";
            this.q += modifier.toUpperCase() + " ";
            return this;
        };
        SearchQueryBuilder.prototype.needsQuotes = function (s) {
            return /\s|:/g.test(s);
        };
        SearchQueryBuilder.prototype.formatTerm = function (term) {
            if (term instanceof Date) {
                return term.getTime();
            }
            if (typeof term === "string" && this.needsQuotes(term)) {
                return "\"" + term + "\"";
            }
            return term;
        };
        SearchQueryBuilder.prototype.commit = function () {
            var _this = this;
            this.currentModifer = undefined;
            if (this.hasRange) {
                this.q += "[" + this.formatTerm(this.rangeStack[0]) + " TO " + this.formatTerm(this.rangeStack[1]) + "]";
                this.rangeStack = [undefined, undefined];
            }
            if (this.hasTerms) {
                this.q += this.termStack
                    .map(function (term) {
                    return _this.formatTerm(term);
                })
                    .join(" ");
                this.termStack = [];
            }
            return this;
        };
        Object.defineProperty(SearchQueryBuilder.prototype, "hasTerms", {
            get: function () {
                return this.termStack.length > 0;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SearchQueryBuilder.prototype, "hasRange", {
            get: function () {
                return this.rangeStack.length && this.rangeStack[0] && this.rangeStack[1];
            },
            enumerable: false,
            configurable: true
        });
        SearchQueryBuilder.prototype.cleanup = function () {
            // end a group if we have started one
            if (this.openGroups > 0) {
                warn(
                // apparently-p*rettier-ignore causes prettier to strip *all* comments O_o
                "Automatically closing " + this.openGroups + " group(s). You can use `endGroup(...)` to remove this warning.");
                while (this.openGroups > 0) {
                    this.q += ")";
                    this.openGroups--;
                }
            }
            var oldQ = this.q;
            this.q = oldQ.replace(/( AND ?| NOT ?| OR ?)*$/, "");
            if (oldQ !== this.q) {
                warn("`startGroup(...)` was called without calling `endGroup(...)` first. Your query was not modified.");
            }
            // clear empty groups
            this.q = this.q.replace(/(\(\))*/, "");
        };
        return SearchQueryBuilder;
    }());

    /* Copyright (c) 2018 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    function genericSearch(search, searchType) {
        var options;
        if (typeof search === "string" || search instanceof SearchQueryBuilder) {
            options = {
                httpMethod: "GET",
                params: {
                    q: search,
                },
            };
        }
        else {
            // searchUserAccess has one (knonw) valid value: "groupMember"
            options = appendCustomParams(search, [
                "q",
                "num",
                "start",
                "sortField",
                "sortOrder",
                "searchUserAccess",
                "searchUserName",
                "filter",
                "countFields",
                "countSize",
                "categories",
                "categoryFilters",
            ], {
                httpMethod: "GET",
            });
        }
        var path;
        switch (searchType) {
            case "item":
                path = "/search";
                break;
            case "group":
                path = "/community/groups";
                break;
            case "groupContent":
                // Need to have groupId property to do group contents search,
                // cso filter out all but ISearchGroupContentOptions
                if (typeof search !== "string" &&
                    !(search instanceof SearchQueryBuilder) &&
                    search.groupId) {
                    path = "/content/groups/" + search.groupId + "/search";
                }
                else {
                    return Promise.reject(new Error("you must pass a `groupId` option to `searchGroupContent`"));
                }
                break;
            default:
                // "users"
                path = "/portals/self/users/search";
                break;
        }
        var url = getPortalUrl(options) + path;
        // send the request
        return request(url, options).then(function (r) {
            if (r.nextStart && r.nextStart !== -1) {
                r.nextPage = function () {
                    var newOptions;
                    if (typeof search === "string" ||
                        search instanceof SearchQueryBuilder) {
                        newOptions = {
                            q: search,
                            start: r.nextStart,
                        };
                    }
                    else {
                        newOptions = search;
                        newOptions.start = r.nextStart;
                    }
                    return genericSearch(newOptions, searchType);
                };
            }
            return r;
        });
    }

    /* Copyright (c) 2018-2019 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * ```js
     * import { searchItems } from "@esri/arcgis-rest-portal";
     * //
     * searchItems('water')
     *   .then(response) // response.total => 355
     * ```
     * Search a portal for items. See the [REST Documentation](https://developers.arcgis.com/rest/users-groups-and-items/search.htm) for more information.
     *
     * @param search - A string or RequestOptions object to pass through to the endpoint.
     * @returns A Promise that will resolve with the data from the response.
     */
    function searchItems(search) {
        return genericSearch(search, "item");
    }

    /* Copyright (c) 2019 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    function chunk(array, size) {
        if (array.length === 0) {
            return [];
        }
        var chunks = [];
        for (var i = 0; i < array.length; i += size) {
            chunks.push(array.slice(i, i + size));
        }
        return chunks;
    }

    /* Copyright (c) 2017-2018 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * ```js
     * import { addGroupUsers } from "@esri/arcgis-rest-portal";
     * //
     * addGroupUsers({
     *   id: groupId,
     *   users: ["username1", "username2"],
     *   admins: ["username3"],
     *   authentication
     * })
     * .then(response);
     * ```
     * Add users to a group. See the [REST Documentation](https://developers.arcgis.com/rest/users-groups-and-items/add-users-to-group.htm) for more information.
     *
     * @param requestOptions  - Options for the request
     * @returns A Promise
     */
    function addGroupUsers(requestOptions) {
        var id = requestOptions.id;
        var url = getPortalUrl(requestOptions) + "/community/groups/" + id + "/addUsers";
        var baseOptions = Object.assign({}, requestOptions, {
            admins: undefined,
            users: undefined
        });
        var batchRequestOptions = __spreadArrays(_prepareRequests("users", requestOptions.users, baseOptions), _prepareRequests("admins", requestOptions.admins, baseOptions));
        var promises = batchRequestOptions.map(function (options) {
            return _sendSafeRequest(url, options);
        });
        return Promise.all(promises).then(_consolidateRequestResults);
    }
    function _prepareRequests(type, usernames, baseOptions) {
        if (!usernames || usernames.length < 1) {
            return [];
        }
        // the ArcGIS REST API only allows to add no more than 25 users per request,
        // see https://developers.arcgis.com/rest/users-groups-and-items/add-users-to-group.htm
        var userChunks = chunk(usernames, 25);
        return userChunks.map(function (users) {
            return _generateRequestOptions(type, users, baseOptions);
        });
    }
    function _generateRequestOptions(type, usernames, baseOptions) {
        var _a, _b;
        return Object.assign({}, baseOptions, (_a = {},
            _a[type] = usernames,
            _a.params = __assign(__assign({}, baseOptions.params), (_b = {}, _b[type] = usernames, _b)),
            _a));
    }
    // this request is safe since the request error will be handled
    function _sendSafeRequest(url, requestOptions) {
        return request(url, requestOptions).catch(function (error) {
            return {
                errors: [error]
            };
        });
    }
    function _consolidateRequestResults(results) {
        var notAdded = results
            .filter(function (result) { return result.notAdded; })
            .reduce(function (collection, result) { return collection.concat(result.notAdded); }, []);
        var errors = results
            .filter(function (result) { return result.errors; })
            .reduce(function (collection, result) { return collection.concat(result.errors); }, []);
        var consolidated = { notAdded: notAdded };
        if (errors.length > 0) {
            consolidated.errors = errors;
        }
        return consolidated;
    }

    /* Copyright (c) 2017-2018 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * ```js
     * import { removeGroupUsers } from "@esri/arcgis-rest-portal";
     * //
     * removeGroupUsers({
     *   id: groupId,
     *   users: ["username1", "username2"],
     *   authentication
     * })
     * .then(response);
     * ```
     * Add users to a group. See the [REST Documentation](https://developers.arcgis.com/rest/users-groups-and-items/remove-users-from-group.htm) for more information.
     *
     * @param requestOptions  - Options for the request
     * @returns A Promise
     */
    function removeGroupUsers(requestOptions) {
        var id = requestOptions.id, usersToRemove = requestOptions.users;
        var url = getPortalUrl(requestOptions) + "/community/groups/" + id + "/removeUsers";
        var safeSend = function (users) {
            var options = __assign(__assign({}, requestOptions), { users: users, params: { users: users } });
            return request(url, options)
                .catch(function (error) { return ({ errors: [error] }); });
        };
        // the ArcGIS REST API only allows to add no more than 25 users per request,
        // see https://developers.arcgis.com/rest/users-groups-and-items/remove-users-from-group.htm
        var promises = chunk(usersToRemove, 25).map(function (usersChunk) { return safeSend(usersChunk); });
        return Promise.all(promises)
            .then(function (results) {
            var filtered = function (propName) { return results
                .filter(function (result) { return result[propName]; })
                .reduce(function (collection, result) { return collection.concat(result[propName]); }, []); };
            var errors = filtered('errors');
            var consolidated = { notRemoved: filtered('notRemoved') };
            return errors.length ? __assign(__assign({}, consolidated), { errors: errors }) : consolidated;
        });
    }

    /* Copyright (c) 2017-2018 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * ```js
     * import { createGroup } from "@esri/arcgis-rest-portal";
     * //
     * createGroup({
     *   group: {
     *     title: "No Homers",
     *     access: "public"
     *   },
     *   authentication
     * })
     *   .then(response)
     * ```
     * Create a new Group. See the [REST Documentation](https://developers.arcgis.com/rest/users-groups-and-items/create-group.htm) for more information.
     *
     * Note: The group name must be unique within the user's organization.
     * @param requestOptions  - Options for the request, including a group object
     * @returns A Promise that will resolve with the success/failure status of the request
     */
    function createGroup(requestOptions) {
        var url = getPortalUrl(requestOptions) + "/community/createGroup";
        requestOptions.params = __assign(__assign({}, requestOptions.params), requestOptions.group);
        return request(url, requestOptions);
    }

    /* Copyright (c) 2017-2018 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * ```js
     * import { protectGroup } from '@esri/arcgis-rest-portal';
     * //
     * protectGroup({
     *   id: groupId,
     *   authentication
     * })
     *   .then(response)
     * ```
     * Protect a group to avoid accidental deletion. See the [REST Documentation](https://developers.arcgis.com/rest/users-groups-and-items/protect-group.htm) for more information.
     *
     * @param requestOptions - Options for the request
     * @returns A Promise that will resolve with the success/failure status of the request
     */
    function protectGroup(requestOptions) {
        var url = getPortalUrl(requestOptions) + "/community/groups/" + requestOptions.id + "/protect";
        return request(url, requestOptions);
    }
    /**
     * ```js
     * import { unprotectGroup } from '@esri/arcgis-rest-portal';
     * //
     * unprotectGroup({
     *   id: groupId,
     *   authentication
     * })
     *   .then(response)
     * ```
     * Unprotect a Group. See the [REST Documentation](https://developers.arcgis.com/rest/users-groups-and-items/unprotect-group.htm) for more information.
     * @param requestOptions - Options for the request
     * @returns A Promise that will resolve with the success/failure status of the request
     */
    function unprotectGroup(requestOptions) {
        var url = getPortalUrl(requestOptions) + "/community/groups/" + requestOptions.id + "/unprotect";
        return request(url, requestOptions);
    }

    /* Copyright (c) 2017-2018 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * ```js
     * import { removeGroup } from '@esri/arcgis-rest-portal';
     * //
     * removeGroup({
     *   id: groupId,
     *   authentication
     * })
     *   .then(response)
     * ```
     * Delete a group. See the [REST Documentation](https://developers.arcgis.com/rest/users-groups-and-items/delete-group.htm) for more information.
     *
     * @param requestOptions - Options for the request
     * @returns A Promise that will resolve with the success/failure status of the request
     */
    function removeGroup(requestOptions) {
        var url = getPortalUrl(requestOptions) + "/community/groups/" + requestOptions.id + "/delete";
        var options = __assign({}, requestOptions);
        return request(url, options);
    }

    /* Copyright (c) 2018-2019 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * ```js
     * import { searchGroups } from "@esri/arcgis-rest-portal";
     * //
     * searchGroups('water')
     *   .then(response) // response.total => 355
     * ```
     * Search a portal for groups. See the [REST Documentation](https://developers.arcgis.com/rest/users-groups-and-items/group-search.htm) for more information.
     *
     * @param search - A string or RequestOptions object to pass through to the endpoint.
     * @returns A Promise that will resolve with the data from the response.
     */
    function searchGroups(search) {
        return genericSearch(search, "group");
    }

    /**
     * ```js
     * import { updateUserMemberships } from "@esri/arcgis-rest-portal";
     * //
     * updateUserMemberships({
     *   id: groupId,
     *   admins: ["username3"],
     *   authentication
     * })
     * .then(response);
     * ```
     * Change the user membership levels of existing users in a group
     *
     * @param requestOptions  - Options for the request
     * @returns A Promise
     */
    function updateUserMemberships(requestOptions) {
        var url = getPortalUrl(requestOptions) + "/community/groups/" + requestOptions.id + "/updateUsers";
        var opts = {
            authentication: requestOptions.authentication,
            params: {}
        };
        // add the correct params depending on the type of membership we are changing to
        if (requestOptions.newMemberType === "admin") {
            opts.params.admins = requestOptions.users;
        }
        else {
            opts.params.users = requestOptions.users;
        }
        // make the request
        return request(url, opts);
    }

    /* Copyright (c) 2017-2018 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * ```js
     * import { joinGroup } from '@esri/arcgis-rest-portal';
     * //
     * joinGroup({
     *   id: groupId,
     *   authentication
     * })
     *   .then(response)
     * ```
     * Make a request as the authenticated user to join a Group. See the [REST Documentation](https://developers.arcgis.com/rest/users-groups-and-items/join-group.htm) for more information.
     *
     * @param requestOptions - Options for the request
     * @returns A Promise that will resolve with the success/failure status of the request and the groupId.
     */
    function joinGroup(requestOptions) {
        var url = getPortalUrl(requestOptions) + "/community/groups/" + requestOptions.id + "/join";
        return request(url, requestOptions);
    }
    /**
     * ```js
     * import { leaveGroup } from '@esri/arcgis-rest-portal';
     * //
     * leaveGroup({
     *   id: groupId,
     *   authentication
     * })
     *   .then(response)
     * ```
     * Make a request as the authenticated user to leave a Group. See the [REST Documentation](https://developers.arcgis.com/rest/users-groups-and-items/leave-group.htm) for more information.
     *
     * @param requestOptions - Options for the request
     * @returns A Promise that will resolve with the success/failure status of the request and the groupId.
     */
    function leaveGroup(requestOptions) {
        var url = getPortalUrl(requestOptions) + "/community/groups/" + requestOptions.id + "/leave";
        return request(url, requestOptions);
    }

    /* Copyright (c) 2018 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * ```js
     * import { getUser } from '@esri/arcgis-rest-portal';
     * //
     * getUser("jsmith")
     *   .then(response)
     * // => { firstName: "John", lastName: "Smith",tags: ["GIS Analyst", "City of Redlands"] }
     * ```
     * Get information about a user. This method has proven so generically useful that you can also call [`UserSession.getUser()`](/arcgis-rest-js/api/auth/UserSession#getUser-summary).
     *
     * @param requestOptions - options to pass through in the request
     * @returns A Promise that will resolve with metadata about the user
     */
    function getUser(requestOptions) {
        var url;
        var options = { httpMethod: "GET" };
        // if a username is passed, assume ArcGIS Online
        if (typeof requestOptions === "string") {
            url = "https://www.arcgis.com/sharing/rest/community/users/" + requestOptions;
        }
        else {
            // if an authenticated session is passed, default to that user/portal unless another username is provided manually
            var username = requestOptions.username || requestOptions.authentication.username;
            url = getPortalUrl(requestOptions) + "/community/users/" + encodeURIComponent(username);
            options = __assign(__assign({}, requestOptions), options);
        }
        // send the request
        return request(url, options);
    }

    /* Copyright (c) 2019 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * Helper that returns the [user](https://developers.arcgis.com/rest/users-groups-and-items/user.htm) for a given portal.
     *
     * @param session
     * @returns User url to be used in API requests.
     */
    function getUserUrl(session) {
        return getPortalUrl(session) + "/community/users/" + encodeURIComponent(session.username);
    }

    /**
     * ```js
     * import { isItemSharedWithGroup } from "@esri/arcgis-rest-portal";
     * //
     * isItemSharedWithGroup({
     *   groupId: 'bc3,
     *   itemId: 'f56,
     *   authentication
     * })
     * .then(isShared => {})
     * ```
     * Find out whether or not an item is already shared with a group.
     *
     * @param requestOptions - Options for the request. NOTE: `rawResponse` is not supported by this operation.
     * @returns Promise that will resolve with true/false
     */
    function isItemSharedWithGroup(requestOptions) {
        var searchOpts = {
            q: "id: " + requestOptions.id + " AND group: " + requestOptions.groupId,
            start: 1,
            num: 10,
            sortField: "title",
            authentication: requestOptions.authentication,
            httpMethod: "POST"
        };
        return searchItems(searchOpts).then(function (searchResponse) {
            var result = false;
            if (searchResponse.total > 0) {
                result = searchResponse.results.some(function (itm) {
                    return itm.id === requestOptions.id;
                });
                return result;
            }
        });
    }

    /**
     * ```js
     * import { shareItemWithGroup } from '@esri/arcgis-rest-portal';
     * //
     * shareItemWithGroup({
     *   id: "abc123",
     *   groupId: "xyz987",
     *   owner: "some-owner",
     *   authentication
     * })
     * ```
     * Share an item with a group, either as an
     * [item owner](https://developers.arcgis.com/rest/users-groups-and-items/share-item-as-item-owner-.htm),
     * [group admin](https://developers.arcgis.com/rest/users-groups-and-items/share-item-as-group-admin-.htm) or
     * organization admin.
     *
     * Note: Sharing the item as an Admin will use the `/content/users/:ownername/items/:itemid/share` end-point
     *
     * @param requestOptions - Options for the request.
     * @returns A Promise that will resolve with the data from the response.
     */
    function shareItemWithGroup(requestOptions) {
        return isItemSharedWithGroup(requestOptions)
            .then(function (isShared) {
            if (isShared) {
                // already shared, exit early with success response
                return {
                    itemId: requestOptions.id,
                    shortcut: true,
                    notSharedWith: [],
                };
            }
            var username = requestOptions.authentication.username, owner = requestOptions.owner, confirmItemControl = requestOptions.confirmItemControl;
            var itemOwner = owner || username;
            // non-item owner
            if (itemOwner !== username) {
                // need to track if the user is an admin
                var isAdmin_1 = false;
                // track if the admin & owner are in the same org
                var isCrossOrgSharing_1 = false;
                // next perform any necessary membership adjustments for
                // current user and/or item owner
                return Promise.all([
                    getUser({
                        username: username,
                        authentication: requestOptions.authentication,
                    }),
                    getUser({
                        username: itemOwner,
                        authentication: requestOptions.authentication,
                    }),
                    getUserMembership(requestOptions),
                ])
                    .then(function (_a) {
                    var currentUser = _a[0], ownerUser = _a[1], membership = _a[2];
                    var isSharedEditingGroup = !!confirmItemControl;
                    isAdmin_1 = currentUser.role === "org_admin" && !currentUser.roleId;
                    isCrossOrgSharing_1 = currentUser.orgId !== ownerUser.orgId;
                    return getMembershipAdjustments(currentUser, isSharedEditingGroup, membership, isAdmin_1, ownerUser, requestOptions);
                })
                    .then(function (membershipAdjustments) {
                    var _a = membershipAdjustments[0], revert = (_a === void 0 ? {
                        promise: Promise.resolve({ notAdded: [] }),
                        revert: function (sharingResults) {
                            return Promise.resolve(sharingResults);
                        },
                    } : _a).revert;
                    // perform all membership adjustments
                    return Promise.all(membershipAdjustments.map(function (_a) {
                        var promise = _a.promise;
                        return promise;
                    }))
                        .then(function () {
                        // then attempt the share
                        return shareToGroup(requestOptions, isAdmin_1, isCrossOrgSharing_1);
                    })
                        .then(function (sharingResults) {
                        // lastly, if the admin user was added to the group,
                        // remove them from the group. this is a no-op that
                        // immediately resolves the sharingResults when no
                        // membership adjustment was needed
                        return revert(sharingResults);
                    });
                });
            }
            // item owner, let it call through
            return shareToGroup(requestOptions);
        })
            .then(function (sharingResponse) {
            if (sharingResponse.notSharedWith.length) {
                throw Error("Item " + requestOptions.id + " could not be shared to group " + requestOptions.groupId + ".");
            }
            else {
                // all is well
                return sharingResponse;
            }
        });
    }
    function getMembershipAdjustments(currentUser, isSharedEditingGroup, membership, isAdmin, ownerUser, requestOptions) {
        var membershipGuarantees = [];
        if (requestOptions.groupId !== currentUser.favGroupId) {
            if (isSharedEditingGroup) {
                if (!isAdmin) {
                    // abort and reject promise
                    throw Error("This item can not be shared to shared editing group " + requestOptions.groupId + " by " + currentUser.username + " as they not the item owner or org admin.");
                }
                membershipGuarantees.push(
                // admin user must be a group member to share, should be reverted afterwards
                ensureMembership(currentUser, currentUser, false, "Error adding " + currentUser.username + " as member to edit group " + requestOptions.groupId + ". Consequently item " + requestOptions.id + " was not shared to the group.", requestOptions), 
                // item owner must be a group admin
                ensureMembership(currentUser, ownerUser, true, membership === "none"
                    ? "Error adding user " + ownerUser.username + " to edit group " + requestOptions.groupId + ". Consequently item " + requestOptions.id + " was not shared to the group."
                    : "Error promoting user " + ownerUser.username + " to admin in edit group " + requestOptions.groupId + ". Consequently item " + requestOptions.id + " was not shared to the group.", requestOptions));
            }
            else if (isAdmin) {
                // admin user must be a group member to share, should be reverted afterwards
                membershipGuarantees.push(ensureMembership(currentUser, currentUser, false, "Error adding " + currentUser.username + " as member to view group " + requestOptions.groupId + ". Consequently item " + requestOptions.id + " was not shared to the group.", requestOptions));
            }
            else if (membership === "none") {
                // all other non-item owners must be a group member
                throw new Error("This item can not be shared by " + currentUser.username + " as they are not a member of the specified group " + requestOptions.groupId + ".");
            }
        }
        return membershipGuarantees;
    }
    function shareToGroup(requestOptions, isAdmin, isCrossOrgSharing) {
        if (isAdmin === void 0) { isAdmin = false; }
        if (isCrossOrgSharing === void 0) { isCrossOrgSharing = false; }
        var username = requestOptions.authentication.username;
        var itemOwner = requestOptions.owner || username;
        // decide what url to use
        // default to the non-owner url...
        var url = getPortalUrl(requestOptions) + "/content/items/" + requestOptions.id + "/share";
        // but if they are the owner, or org_admin, use this route
        // Note: When using this end-point as an admin, apparently the admin does not need to be a member of the group (the itemOwner does)
        // Note: Admin's can only use this route when the item is in the same org they are admin for
        if (itemOwner === username || (isAdmin && !isCrossOrgSharing)) {
            url = getPortalUrl(requestOptions) + "/content/users/" + itemOwner + "/items/" + requestOptions.id + "/share";
        }
        // now its finally time to do the sharing
        requestOptions.params = {
            groups: requestOptions.groupId,
            confirmItemControl: requestOptions.confirmItemControl,
        };
        return request(url, requestOptions);
    }
    function ensureMembership(currentUser, ownerUser, shouldPromote, errorMessage, requestOptions) {
        var _a;
        var ownerGroups = ownerUser.groups || [];
        var group = ownerGroups.find(function (g) {
            return g.id === requestOptions.groupId;
        });
        // if they are in different orgs, eject
        if (currentUser.orgId !== ownerUser.orgId) {
            throw Error("User " + ownerUser.username + " is not a member of the same org as " + currentUser.username + ". Consequently they can not be added added to group " + requestOptions.groupId + " nor can item " + requestOptions.id + " be shared to the group.");
        }
        // if owner is not a member, and has 512 groups
        if (!group && ownerGroups.length > 511) {
            throw Error("User " + ownerUser.username + " already has 512 groups, and can not be added to group " + requestOptions.groupId + ". Consequently item " + requestOptions.id + " can not be shared to the group.");
        }
        var promise;
        var revert;
        // decide if we need to add them or upgrade them
        if (group) {
            // they are in the group...
            // check member type
            if (shouldPromote && group.userMembership.memberType === "member") {
                // promote them
                promise = updateUserMemberships({
                    id: requestOptions.groupId,
                    users: [ownerUser.username],
                    newMemberType: "admin",
                    authentication: requestOptions.authentication,
                })
                    .then(function (results) {
                    // convert the result into the right type
                    var notAdded = results.results.reduce(function (acc, entry) {
                        if (!entry.success) {
                            acc.push(entry.username);
                        }
                        return acc;
                    }, []);
                    // and return it
                    return Promise.resolve({ notAdded: notAdded });
                })
                    .catch(function () { return ({ notAdded: [ownerUser.username] }); });
                revert = function (sharingResults) {
                    return updateUserMemberships({
                        id: requestOptions.groupId,
                        users: [ownerUser.username],
                        newMemberType: "member",
                        authentication: requestOptions.authentication,
                    })
                        .then(function () { return sharingResults; })
                        .catch(function () { return sharingResults; });
                };
            }
            else {
                // they are already an admin in the group
                // return the same response the API would if we added them
                promise = Promise.resolve({ notAdded: [] });
                revert = function (sharingResults) { return Promise.resolve(sharingResults); };
            }
        }
        else {
            // attempt to add user to group
            var userType = shouldPromote ? "admins" : "users";
            // can't currently determine if the group is within the admin's
            // org without performing a search, so attempt to add and handle
            // the api error
            promise = addGroupUsers((_a = {
                    id: requestOptions.groupId
                },
                _a[userType] = [ownerUser.username],
                _a.authentication = requestOptions.authentication,
                _a))
                .then(function (results) {
                // results.errors includes an ArcGISAuthError when the group
                // is in a different org, but notAdded is empty, throw here
                // to normalize the results in below catch
                if (results.errors && results.errors.length) {
                    throw results.errors[0];
                }
                return results;
            })
                .catch(function () { return ({ notAdded: [ownerUser.username] }); });
            revert = function (sharingResults) {
                return removeGroupUsers({
                    id: requestOptions.groupId,
                    users: [ownerUser.username],
                    authentication: requestOptions.authentication,
                }).then(function () {
                    // always resolves, suppress any resolved errors
                    return sharingResults;
                });
            };
        }
        return {
            promise: promise.then(function (membershipResponse) {
                if (membershipResponse.notAdded.length) {
                    throw new Error(errorMessage);
                }
                return membershipResponse;
            }),
            revert: revert,
        };
    }

    /* Copyright (c) 2017-2019 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * Get the portal
     * @param requestOptions
     */
    function getSelf(requestOptions) {
        // just delegate to getPortal w/o an id
        return getPortal(null, requestOptions);
    }
    /**
     * ```js
     * import { getPortal } from "@esri/arcgis-rest-request";
     * //
     * getPortal()
     * getPortal("fe8")
     * getPortal(null, { portal: "https://custom.maps.arcgis.com/sharing/rest/" })
     * ```
     * Fetch information about the specified portal by id. If no id is passed, portals/self will be called.
     * Note that if you intend to request a portal by id and it is different from the portal specified by options.authentication, you must also pass options.portal.
     * @param id
     * @param requestOptions
     */
    function getPortal(id, requestOptions) {
        // construct the search url
        var idOrSelf = id ? id : "self";
        var url = getPortalUrl(requestOptions) + "/portals/" + idOrSelf;
        // default to a GET request
        var options = __assign({ httpMethod: "GET" }, requestOptions);
        // send the request
        return request(url, options);
    }

    /**
     * Save an IModel. Generic function that will be used across all
     * type-specific save functions
     *
     * @export
     * @param {IModel} "model" object (i.e. `{item:{...}, data:{...}}`)
     * @param {IRequestOptions} requestOptions
     * @returns {Promise<IModel>}
     */
    function saveModel(model, requestOptions) {
        var clone = hubCommon.cloneObject(model);
        var opts = createRequestOptions(clone, requestOptions);
        return createItem(opts).then(function (response) {
            clone.item.id = response.id;
            return clone;
        });
    }
    /**
     * Update an IModel. Generic function that will be used across all
     * type-specific update functions
     *
     * @export
     * @param {IModel} "model" object (i.e. `{item:{...}, data:{...}}`)
     * @param {IRequestOptions} requestOptions
     * @returns {Promise<IModel>}
     */
    function updateModel(model, requestOptions) {
        var clone = hubCommon.cloneObject(model);
        var opts = createRequestOptions(clone, requestOptions);
        return updateItem(opts).then(function () {
            // return a new ref to the model that was passed in...
            return clone;
        });
    }
    /**
     * Centralize the serialization of an IModel into an object
     * that we can send to the Item methods
     *
     * @param {IModel} model
     * @param {IRequestOptions} requestOptions
     * @returns {*}
     */
    function createRequestOptions(model, requestOptions) {
        // construct an object to send to the API
        var item = hubCommon.cloneObject(model.item);
        item.data = hubCommon.cloneObject(model.data);
        // create the options...
        var opts = __assign({ item: item }, requestOptions);
        return opts;
    }

    /* Copyright (c) 2018 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    var INITIATIVE_TYPE_NAME = "Hub Initiative";
    /**
     * Save an Initiative model. If the model does not have an item.id
     * we will create a new item. Otherwise we update the existing item.
     * Returns the same model instance, with the item.id assigned;
     *
     * @export
     * @param {IInitiativeModel} model
     * @param {IRequestOptions} requestOptions
     * @returns {Promise<IInitiativeModel>}
     */
    function addInitiative(model, requestOptions) {
        // delegate to model to do the save...
        return saveModel(model, requestOptions);
    }
    /**
     * Generate the default url for an Initiative - which is the route to the
     * initiative in the admin app
     *
     * @export
     * @param {string} itemId
     * @param {IRequestOptions} requestOptions
     * @returns {string} Url to the initiative in the admin app
     */
    function getInitiativeUrl(itemId, requestOptions) {
        return hubCommon.getHubApiUrl(requestOptions) + "/admin/initiatives/" + itemId;
    }

    /* Copyright (c) 2018 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * Applies the initial version of the Initiaive schema to the model.
     * If `model.item.properties.schemaVersion >= 1` the original object
     * will be returned. Otherwise a new object with the updated schema
     * is returned.
     *
     * @protected
     * @param {IInitiativeModel} model Initiative Model
     * @param {string} [portalUrl] Url to the Portal. Defauls to `www.arcgis.com`
     * @returns {IInitiativeModel}
     */
    function applyInitialSchema(model, portalUrl) {
        var curVersion = hubCommon.getProp(model, "item.properties.schemaVersion");
        // if no current version or it's below 1
        if (!curVersion || curVersion < 1) {
            // clone the model because we play by immutable rules
            var clone_1 = hubCommon.cloneObject(model);
            // console.debug(`------- CLONE ---------`);
            // console.debug(JSON.stringify(clone, null, 2));
            // console.debug(`------- CLONE ---------`);
            // ensure some properties exist...
            if (!clone_1.data.values) {
                clone_1.data.values = {};
            }
            if (!clone_1.item.properties) {
                clone_1.item.properties = {};
            }
            // set the schema version...
            clone_1.item.properties.schemaVersion = 1.0;
            var isTemplate_1 = false;
            if (clone_1.item.typeKeywords) {
                isTemplate_1 =
                    clone_1.item.typeKeywords.indexOf("hubInitiativeTemplate") >= 0;
            }
            // ensure source is in item.properties if it has a parent...
            var hasParent = !!clone_1.data.source;
            if (hasParent && clone_1.item.properties.source !== clone_1.data.source) {
                clone_1.item.properties.source = clone_1.data.source;
            }
            // convert configuratinSettings to steps array...
            // NOTE: this is only for 'templates', or Custom Initiatives
            if (clone_1.data.configurationSettings) {
                var config = hubCommon.cloneObject(clone_1.data.configurationSettings);
                delete clone_1.data.configurationSettings;
                // get the steps entry...
                var stepCategory = config.find(function (el) {
                    return el.category === "Steps";
                });
                // hoist step names into an array
                clone_1.data.values.steps = stepCategory.fields.map(function (entry) {
                    return entry.fieldName;
                });
                // move the label and tooltip to title and description, in the values.<fieldName> prop
                stepCategory.fields.forEach(function (entry) {
                    // ensure values prop exists...
                    if (!clone_1.data.values[entry.fieldName]) {
                        clone_1.data.values[entry.fieldName] = {};
                    }
                    // assign in values
                    clone_1.data.values[entry.fieldName].title = entry.label;
                    clone_1.data.values[entry.fieldName].description = entry.tooltip;
                    clone_1.data.values[entry.fieldName].id = entry.fieldName;
                    // if a .items array exists, rename that to .templates
                    if (clone_1.data.values[entry.fieldName].items) {
                        // if this is a template, then move items to templates...
                        if (isTemplate_1) {
                            clone_1.data.values[entry.fieldName].templates =
                                clone_1.data.values[entry.fieldName].items;
                            delete clone_1.data.values[entry.fieldName].items;
                        }
                    }
                    else {
                        // ensure empty arrays
                        clone_1.data.values[entry.fieldName].items = [];
                        clone_1.data.values[entry.fieldName].templates = [];
                    }
                });
            }
            return clone_1;
        }
        else {
            return model;
        }
    }

    /* Copyright (c) 2018 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * Apply the 1.0 --> 1.1 Migration to an Initiative Model
     *
     * @param model
     * @param portalUrl
     * @protected
     */
    function upgradeToOneDotOne(model, portalUrl) {
        var curVersion = hubCommon.getProp(model, "item.properties.schemaVersion");
        if (curVersion < 1.1) {
            var clone = hubCommon.cloneObject(model);
            // store the schemaVersion
            clone.item.properties.schemaVersion = 1.1;
            // add the assets...
            addDefaultResources(clone, portalUrl);
            if (!clone.data.values.bannerImage) {
                clone.data.values.bannerImage = {
                    source: "bannerImage",
                    display: {
                        position: { x: "50%", y: "10%" }
                    }
                };
            }
            return clone;
        }
        else {
            // console.debug(`Not upgrading CurVersion: ${curVersion}`);
            return model;
        }
    }
    /**
     * As part of the 1.1 migration, we add a set of default image
     * resources into the hash.
     *
     * @protected
     * @param {IInitiativeModel} model
     * @param {string} [portalUrl]
     * @returns {IInitiativeModel}
     */
    function addDefaultResources(model, portalUrl) {
        if (!model.data.assets) {
            model.data.assets = [
                {
                    id: "bannerImage",
                    url: getResourceUrl(model.item.id, "detail-image.jpg", portalUrl),
                    properties: {
                        type: "resource",
                        fileName: "detail-image.jpg",
                        mimeType: "image/jepg"
                    },
                    license: {
                        type: "none"
                    }
                },
                {
                    id: "iconDark",
                    url: getResourceUrl(model.item.id, "icon-dark.png", portalUrl),
                    properties: {
                        type: "resource",
                        fileName: "icon-dark.png",
                        mimeType: "image/png"
                    },
                    license: {
                        type: "none"
                    }
                },
                {
                    id: "iconLight",
                    url: getResourceUrl(model.item.id, "icon-light.png", portalUrl),
                    properties: {
                        type: "resource",
                        fileName: "icon-light.png",
                        mimeType: "image/png"
                    },
                    license: {
                        type: "none"
                    }
                }
            ];
        }
        return model;
    }
    /**
     * Construct the url for a resource. This is specific to the migration otherwise
     * if would be hoised into a more generic module
     *
     * @protected
     * @param {string} itemId
     * @param {string} resourceName
     * @param {string} [portal]
     * @param {string} [folder]
     * @returns {string}
     */
    function getResourceUrl(itemId, resourceName, portal, folder) {
        // default to www.arcgis.com
        var portalUrl = portal || "https://www.arcgis.com/sharing/rest";
        var url = portalUrl + "/content/items/" + itemId + "/resources";
        if (folder) {
            url = url + "/" + folder + "/" + resourceName;
        }
        else {
            url = url + "/" + resourceName;
        }
        return url;
    }

    /**
     * Given an object, conduct checks to see if it is an indicator
     * @protected
     */
    var isIndicator = function (obj) {
        var result = false;
        if (Array.isArray(obj.fields) && obj.fields.length > 0) {
            result = true;
        }
        return result;
    };
    /**
     * Convert the CAS formatted "field" into the new schema
     * @protected
     */
    var convertIndicatorField = function (field) {
        return {
            id: field.fieldName,
            name: field.label,
            optional: field.optional || false,
            description: field.tooltip,
            supportedTypes: __spreadArrays(field.supportedTypes)
        };
    };
    /**
     * Convert a CAS formatted indicator to the .definition in the new schama
     * @protected
     */
    var convertIndicatorToDefinition = function (ind) {
        var def = {
            id: ind.fieldName,
            type: "Data",
            name: ind.label || ind.fieldName,
            optional: ind.optional || false,
            definition: {
                description: ind.label || ind.fieldName,
                supportedTypes: __spreadArrays(ind.layerOptions.supportedTypes),
                geometryTypes: __spreadArrays(ind.layerOptions.geometryTypes),
                fields: ind.fields.map(convertIndicatorField)
            }
        };
        return def;
    };
    /**
     * Given the Indicators entry from a CAS configurationSettings array,
     * convert to an indicators object in the new schema
     * @protected
     */
    function convertIndicatorsToDefinitions(indicatorsHash) {
        // the incoming structure should have a .fields property, and what we want will be in there...
        if (!indicatorsHash.fields || !Array.isArray(indicatorsHash.fields)) {
            indicatorsHash.fields = [];
        }
        var defs = indicatorsHash.fields.map(convertIndicatorToDefinition);
        // now we need to create an object which has props for each def
        return defs;
    }
    /**
     * Given the values hash, locate the properties that are Indicators
     * and return an array of cloned objects
     * @protected
     */
    var extractIndicators = function (values) {
        return Object.keys(values).reduce(function (acc, prop) {
            var obj = values[prop];
            if (isIndicator(obj)) {
                var clone = hubCommon.cloneObject(obj);
                // we want to keep the prop name as the id
                clone.id = prop;
                acc.push(clone);
            }
            return acc;
        }, []);
    };
    /**
     * CAS format had the field properties nested but
     * the new format is flattened
     * @protected
     */
    var flattenField = function (field) {
        return {
            id: field.id,
            name: field.field.name,
            alias: field.field.alias,
            type: field.field.type
        };
    };
    /**
     * Given the indicator value object (from the Initiative), extract
     * the properties to create the .source hash
     * @protected
     */
    var convertIndicatorValueToSource = function (indicator) {
        return {
            type: "Feature Layer",
            url: indicator.url,
            itemId: indicator.itemId,
            layerId: indicator.layerId,
            name: indicator.name || indicator.id,
            mappings: indicator.fields.map(flattenField)
        };
    };
    /**
     * Convert the "source" information
     * @protected
     */
    var convertIndicator = function (indicator) {
        var result = {
            id: indicator.id,
            type: "Data",
            name: indicator.name || indicator.id,
            definition: {
                description: indicator.name || indicator.id
            },
            source: convertIndicatorValueToSource(indicator)
        };
        return result;
    };
    /**
     * Given the values hash that contains indicators, extract them
     * convert them, and return the indicators hash
     * @protected
     */
    var convertInitiativeIndicators = function (values) {
        return extractIndicators(values).map(convertIndicator);
    };
    /**
     * Given a Step object, return a new object with the
     * updated schema
     * @protected
     */
    var convertStep = function (step) {
        // can't use object spread b/c there are props we don't want to carry forward
        var templates = step.templates || [];
        var items = step.items || [];
        return {
            title: step.title,
            description: step.description,
            id: step.id,
            templateIds: templates.map(byId),
            itemIds: items.map(byId)
        };
    };
    /**
     * given the array of steps (prop names), construct an array
     * of the actual step objects while also falttening templates
     * and items arrays to just ids
     * @protected
     */
    var convertSteps = function (steps, values) {
        if (steps && Array.isArray(steps)) {
            return steps.map(function (stepName) {
                return convertStep(values[stepName]);
            });
        }
        else {
            return [];
        }
    };
    /**
     * Extract the id property from an entry
     *
     * @protected
     * @param {*} entry
     * @returns
     */
    function byId(entry) {
        return entry.id;
    }
    /**
     * Apply the 1.1 --> 2.0 Migration to an Initiative Model
     *
     * @protected
     * @param {IInitiativeModel} model
     * @param {string} [portalUrl]
     * @returns {IInitiativeModel}
     */
    function upgradeToTwoDotZero(model, portalUrl) {
        var curVersion = hubCommon.getProp(model, "item.properties.schemaVersion");
        if (curVersion < 2) {
            var clone_1 = hubCommon.cloneObject(model);
            // store the schemaVersion
            clone_1.item.properties.schemaVersion = 2.0;
            // convert the values and values.steps into data.steps
            clone_1.data.steps = convertSteps(clone_1.data.values.steps, clone_1.data.values);
            if (clone_1.data.values.steps) {
                // remove the data.values.steps properties
                clone_1.data.values.steps.forEach(function (propName) {
                    delete clone_1.data.values[propName];
                });
                delete clone_1.data.values.steps;
            }
            // convert the indicators
            clone_1.data.indicators = convertInitiativeIndicators(clone_1.data.values);
            return clone_1;
        }
        else {
            return model;
        }
    }

    /* Copyright (c) 2019 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * Apply the 2.0 --> 2.1 Migration to an Initiative Model
     *
     * @param model
     * @protected
     */
    function upgradeToTwoDotOne(model) {
        var currVersion = hubCommon.getProp(model, "item.properties.schemaVersion");
        if (currVersion < 2.1) {
            var clone = hubCommon.cloneObject(model);
            // store the schemaVersion
            clone.item.properties.schemaVersion = 2.1;
            var collaborationGroupId = hubCommon.getProp(model, "item.properties.groupId");
            if (collaborationGroupId) {
                clone.item.properties.collaborationGroupId = collaborationGroupId;
                delete clone.item.properties.groupId;
            }
            return clone;
        }
        else {
            return model;
        }
    }

    /* Copyright (c) 2020 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * Apply the 2.1 --> 2.2 Migration to an Initiative Model
     * Note: we need this migration to run every time for now, so we
     * will always run it
     *
     * @param model
     * @protected
     */
    function upgradeToTwoDotTwo(model) {
        // const currVersion = getProp(model, "item.properties.schemaVersion");
        // if (currVersion < 2.2) {
        var clone = hubCommon.cloneObject(model);
        // store the schemaVersion
        // clone.item.properties.schemaVersion = 2.2;
        var steps = hubCommon.getProp(clone, "data.steps");
        var templateIdsFromSteps = getTemplateIdsFromSteps(steps);
        var recommendedTemplates = hubCommon.getProp(clone, "data.recommendedTemplates") || [];
        var allTemplateIds = templateIdsFromSteps.concat(recommendedTemplates);
        // strip out duplicates
        clone.data.recommendedTemplates = allTemplateIds.reduce(function (acc, id) {
            if (acc.indexOf(id) < 0) {
                acc.push(id);
            }
            return acc;
        }, []);
        return clone;
        // } else {
        //   return model;
        // }
    }
    /**
     * Reduce the solution template ids out of the steps array
     * @param steps is the steps array from an initiative item model.data
     */
    function getTemplateIdsFromSteps(steps) {
        var templateIds = [];
        if (Array.isArray(steps)) {
            templateIds = steps.reduce(function (acc, step) {
                if (hubCommon.getProp(step, "templateIds.length")) {
                    return acc.concat(step.templateIds);
                }
                return acc;
            }, []);
        }
        return templateIds;
    }

    /* Copyright (c) 2018 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * Current Schema Version
     * @protected
     */
    var CURRENT_SCHEMA_VERSION = 2.2;
    /**
     * Handle Initiative Schema Migrations.
     * If the model is on the current schema, the model object is returned.
     * If a schema migration is applied, a new object will be returned.
     *
     * @export
     * @param {IInitiativeModelFoo} model
     * @param {string} portalUrl
     * @returns {IInitiativeModel}
     */
    function migrateSchema(model, portalUrl) {
        // if the model is not on the current schema, we apply all of them
        // the individual migrations will early-exit if the item version
        // is at or above the migration
        if (hubCommon.getProp(model, "item.properties.schemaVersion") === CURRENT_SCHEMA_VERSION) {
            return model;
        }
        else {
            // apply upgrade functions in order...
            model = applyInitialSchema(model);
            model = upgradeToOneDotOne(model, portalUrl);
            model = upgradeToTwoDotZero(model);
            model = upgradeToTwoDotOne(model);
            model = upgradeToTwoDotTwo(model);
            // etc
            return model;
        }
    }

    /* Copyright (c) 2018 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * ```js
     * getInitiative('3ef...')
     *  .then(initiativeModel => {
     *    // work with the initiative model
     *  })
     * ```
     * Get the initiative item + data in one call. This will also apply schema upgrades
     *
     *
     * @param id - Initiative Item Id
     * @param requestOptions - Initiative request options that may have authentication manager
     * @returns A Promise that will resolve with the Initiative item and data
     * @export
     */
    function getInitiative(id, requestOptions) {
        // if we have specifically requested the data...
        return Promise.all([
            getItem(id, requestOptions),
            getItemData(id, requestOptions)
        ])
            .then(function (result) {
            // shape this into a model
            return {
                item: result[0],
                data: result[1]
            };
        })
            .then(function (model) {
            return migrateSchema(model, hubCommon.getPortalApiUrl(requestOptions));
        });
    }

    /* Copyright (c) 2018 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * Create an initiative collaboration or open data group
     * Note: This does not ensure a group with the proposed name does not exist. Please use
     * `checkGroupExists
     *
     * @export
     * @param {string} name
     * @param {string} description
     * @param {*} options {isOpenData: boolean, isSharedEditing: boolean}
     * @param {IRequestOptions} requestOptions
     * @returns {Promise<IInitiativeModel>}
     */
    function createInitiativeGroup(name, description, options, requestOptions) {
        var group = {
            title: name,
            description: description,
            access: "org",
            sortField: "title",
            sortOrder: "asc",
        };
        if (options.isOpenData) {
            group.isOpenData = true;
            group.tags = ["Hub Initiative Group", "Open Data"];
            group.access = "public";
        }
        if (options.isSharedEditing) {
            group.capabilities = "updateitemcontrol";
            group._edit_privacy = "on";
            group._edit_contributors = "on";
            group.tags = ["Hub Initiative Group", "initiativeCollaborationGroup"];
        }
        var createOpts = __assign({ group: group }, requestOptions);
        // The protect call does not return the groupId, but we need to return it
        // from this function, so we create a var in this scope to hold it...
        var groupId;
        // create the group
        return createGroup(createOpts)
            .then(function (result) {
            groupId = result.group.id;
            // protect it
            var protectOpts = __assign({ id: groupId }, requestOptions);
            return protectGroup(protectOpts);
        })
            .then(function () {
            return groupId;
        });
    }
    /**
     * Remove an Initiative group.
     * This assumes the group is protected
     *
     * @export
     * @param {string} id
     * @param {IRequestOptions} requestOptions
     * @returns {Promise<any>}
     */
    function removeInitiativeGroup(id, requestOptions) {
        var opts = __assign({ id: id }, requestOptions);
        return unprotectGroup(opts).then(function () {
            return removeGroup(opts);
        }, function (ex) {
            // check if the failure is b/c the group does not exist...
            if (ex.messageCode === "COM_0003" && ex.code === 400) {
                return Promise.resolve({ success: true });
            }
            else {
                throw ex;
            }
        });
    }
    /**
     * Check if a group with a specific title exists in an org
     * If it does exist, and has the correct properties, we return the
     * @export
     * @param {string} title
     * @param {string} orgId
     * @param {IRequestOptions} requestOptions
     * @returns {Promise<boolean>}
     */
    function checkGroupExists(title, orgId, requestOptions) {
        var options = __assign({ q: "(orgid: " + orgId, filter: "title:\"" + title + "\"" }, requestOptions);
        return searchGroups(options).then(function (response) {
            var result = {
                exists: false,
            };
            if (response.total > 0) {
                result.exists = true;
                result.group = response.results[0];
            }
            return result;
        });
    }
    /**
     * Group names must be unique within an organization
     *
     * @export
     * @param {string} title
     * @param {string} orgId
     * @param {number} [step=0]
     * @param {IRequestOptions} requestOptions
     * @returns {Promise<string>}
     */
    function getUniqueGroupName(title, orgId, step, requestOptions) {
        var proposedName = title;
        if (step) {
            proposedName = title + " - " + step;
        }
        return checkGroupExists(proposedName, orgId, requestOptions).then(function (result) {
            if (result.exists) {
                // increment the step...
                step = step + 1;
                return getUniqueGroupName(title, orgId, step, requestOptions);
            }
            else {
                return proposedName;
            }
        });
    }
    function isSharedEditingGroup(group) {
        return !!(group.capabilities.indexOf("updateitemcontrol") > -1);
    }

    /* Copyright (c) 2018 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * Given an Initiative Template model, create a new Initiative model
     * Note: this does not save the model. It just sets up the new model.
     *
     * @export
     * @param {IInitiativeModel} template
     * @param {*} options
     * @param {IRequestOptions} requestOptions
     * @returns {Promise<IInitiativeModel>}
     */
    function createInitiativeModelFromTemplate(template, options) {
        // start by making deep clone of the template...
        var model = {
            item: hubCommon.cloneObject(template.item),
            data: {}
        };
        model.item.title = options.title;
        model.item.tags = ["Hub Initiative"];
        // ensure we use the current type
        model.item.type = INITIATIVE_TYPE_NAME;
        // Assign the typeKeywords: remove hubInitiativeTemplate and add hubInitiative
        model.item.typeKeywords = hubCommon.without(model.item.typeKeywords, "hubInitiativeTemplate");
        model.item.typeKeywords.push("hubInitiative");
        // remove things that are irrelevant or are set server-side
        ["id", "owner", "created_at", "modified_at"].forEach(function (prop) { return delete model.item[prop]; });
        // we store a bunch of Ids in here so we can avoid fetching /data for common interactions
        model.item.properties = {
            source: template.item.id,
            schemaVersion: CURRENT_SCHEMA_VERSION,
            initialParent: template.item.id
        };
        Object.assign(model.item.properties, options.groupIds); // add the groupIds
        // we create a new .data node so we're cleaning rogue properties as we go
        model.data = {
            assets: hubCommon.cloneObject(template.data.assets),
            steps: hubCommon.cloneObject(template.data.steps),
            indicators: [],
            source: template.item.id,
            values: {
                initiativeKey: options.initiativeKey,
                bannerImage: hubCommon.cloneObject(template.data.values.bannerImage)
            }
        };
        // if recommended exists, copy it over
        if (hubCommon.getProp(template, "data.recommendedTemplates")) {
            model.data.recommendedTemplates = template.data.recommendedTemplates;
        }
        Object.assign(model.data.values, options.groupIds); // add the groupIds, TODO stop storing groupIds in data.values
        // just in case the template does not have a banner image defined...
        if (!model.data.values.bannerImage) {
            model.data.values.bannerImage = {
                source: "bannerImage",
                display: {
                    position: { x: "50%", y: "10%" }
                }
            };
        }
        return model;
    }

    /* Copyright (c) 2018 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * Update an existing Initiative Model
     * @param model
     * @param requestOptions
     * @returns {Promise<IInitiativeModel>}
     */
    function updateInitiative(model, requestOptions) {
        return updateModel(model, requestOptions);
    }

    /**
     *  Copy an set of image resources from one item to another
     *
     * @export
     * @param {string} sourceItemId
     * @param {string} targetItemId
     * @param {string} owner
     * @param {[string]} assets
     * @param {IRequestOptions} requestOptions
     * @returns {Promise<boolean>}
     */
    function copyImageResources(sourceItemId, targetItemId, owner, assets, requestOptions) {
        var itemResourceUrl = hubCommon.getPortalApiUrl(requestOptions) + "/content/items/" + sourceItemId + "/resources";
        /* istanbul ignore next blob responses are difficult to make cross platform we will just have to trust the isomorphic fetch will do its job */
        return requestOptions.authentication
            .getToken(itemResourceUrl)
            .then(function (token) {
            var assetPromises = assets.map(function (assetName) {
                var sourceUrl = itemResourceUrl + "/" + assetName + "?token=" + token;
                return addImageAsResource(targetItemId, owner, assetName, sourceUrl, requestOptions);
            });
            // This is really more of a fire-and-forget thing, as the Portal API
            // adds these requests into a queue for processing
            return Promise.all(assetPromises);
        })
            .then(function () {
            return true;
        });
    }
    /**
     *  Copy an set of embedded resources to an item
     *
     * @export
     * @param {string} targetItemId destination item id
     * @param {string} owner destination item owner
     * @param {any[]} assets list of assets to copy
     * @param {IRequestOptions} requestOptions
     * @returns {Promise<boolean>}
     */
    function copyEmbeddedImageResources(targetItemId, owner, assets, requestOptions) {
        // need to move resources from embedded template into AGO
        var promises = assets.map(function (asset) {
            return addImageAsResource(targetItemId, owner, asset.name, asset.url, requestOptions)
                .then(function () {
                return true;
            })
                .catch(function () {
                return true; // swallow the error
            });
        });
        return Promise.all(promises).then(function () {
            return true;
        });
    }
    /**
     * Load an image from a url, and store it as a resource on an existing item
     *
     * @export
     * @param {string} itemId
     * @param {string} owner
     * @param {string} filename
     * @param {string} url
     * @param {IRequestOptions} requestOptions
     * @returns {Promise<boolean>}
     */
    function addImageAsResource(id, owner, name, url, requestOptions) {
        // We must use fetch directly here because AGSjs request determines how to parse
        // the response based on the `?f=<type>` param. But sending f=<anything-other-than-json>
        // to a resource end-point, throws an error. Rock, meet Hard-Place.
        var fetchOptions = {
            method: "GET",
            // ensures behavior mimics XMLHttpRequest. needed to support sending IWA cookies
            credentials: "same-origin"
        };
        return (
        // -------------------------------------------------
        // request(url, opts)
        // -------------------------------------------------
        fetch(url, fetchOptions)
            .then(function (x) {
            return x.blob();
        })
            .then(function (blob) {
            return addItemResource({
                id: id,
                owner: owner,
                name: name,
                resource: blob,
                authentication: requestOptions.authentication
            }).then(function (response) {
                return response.success;
            });
        }));
    }

    /* Copyright (c) 2018 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * Activate an Initiative
     * Creates an instance of an Initiative, based on an Initiative Template.
     *
     * @export
     * @param {string | any} template Initiative Template item or Id
     * @param {string} title
     * @param {any} groupIds hash of group props and ids
     * @param {IRequestOptions} requestOptions
     * @returns {Promise<IInitiativeModel>}
     * @private
     */
    function activateInitiative(template, title, groupIds, requestOptions) {
        var _this = this;
        // make a copy of the request options so we can mutate things if needed...
        var ro = __assign({}, requestOptions);
        // create a state container to hold things we accumulate through the various promises
        var state = {
            initiativeKey: hubCommon.camelize(title)
        };
        var promise;
        if (typeof template === "string") {
            promise = getInitiative(template, ro);
        }
        else {
            promise = Promise.resolve(template);
        }
        return promise
            .then(function (templateItemModel) { return __awaiter(_this, void 0, void 0, function () {
            var options;
            return __generator(this, function (_a) {
                state.template = templateItemModel;
                options = {
                    title: title,
                    description: title,
                    initiativeKey: state.initiativeKey,
                    groupIds: groupIds
                };
                // cook the template...
                state.initiativeModel = createInitiativeModelFromTemplate(state.template, options);
                // now save it...
                return [2 /*return*/, addInitiative(state.initiativeModel, ro)];
            });
        }); })
            .then(function (newModel) {
            state.initiativeModel = newModel;
            var assets = hubCommon.getProp(state, "template.assets");
            if (assets) {
                return copyEmbeddedImageResources(newModel.item.id, newModel.item.owner, assets, ro);
            }
            else {
                var _a = newModel.item, id = _a.id, owner = _a.owner;
                var wellKnownAssets = [
                    "detail-image.jpg",
                    "icon-dark.png",
                    "icon-light.png"
                ];
                // now copy assets from the parent initiative...
                return copyImageResources(state.template.item.id, id, owner, wellKnownAssets, ro);
            }
        })
            .then(function () {
            var collaborationGroupId = hubCommon.getProp(state, "initiativeModel.item.properties.collaborationGroupId");
            if (collaborationGroupId) {
                // create sharing options and share to the core team
                var shareOptions = __assign({ id: state.initiativeModel.item.id, groupId: collaborationGroupId, confirmItemControl: true }, requestOptions);
                return shareItemWithGroup(shareOptions);
            }
            else {
                return Promise.resolve({ success: true });
            }
        })
            .then(function () {
            return state.initiativeModel;
        });
    }

    /**
     * Remove the linkage between a site and an Initiative
     * Share the site to the Org's default Collaboration Group
     *
     * @export
     * @param {string} siteId
     * @param {*} collaborationGroupId
     * @param {IRequestOptions} requestOptions
     * @returns {Promise<any>}
     */
    function detachSiteFromInitiative(siteId, collaborationGroupId, requestOptions) {
        // get the site item
        return getItem(siteId, requestOptions)
            .then(function (site) {
            // remove the properties.parentInitiativeId property
            delete site.properties.parentInitiativeId;
            if (collaborationGroupId) {
                // reset the collaborationGroupId to the org's Open Data Group
                site.properties.collaborationGroupId = collaborationGroupId;
            }
            // update the site item
            var opts = __assign({ item: site }, requestOptions);
            return updateItem(opts);
        })
            .then(function () {
            // share it with the group if we got a group...
            if (collaborationGroupId) {
                var opts = __assign({ id: siteId, groupId: collaborationGroupId }, requestOptions);
                return shareItemWithGroup(opts);
            }
            else {
                return Promise.resolve({ success: true });
            }
        });
    }

    /**
     * Remove an Initiative, and its associated groups.
     * If the initiative has a site, it will be shared to
     * the organization's main collaboration group
     * @export
     * @param {string} id
     * @param {IRequestOptions} requestOptions
     * @returns {Promise<any>}
     */
    function removeInitiative(id, requestOptions) {
        var _this = this;
        var state = {
            id: id
        };
        hubCommon.createId("remove-");
        new Date().getTime();
        // first get the item, because we need to also remove the
        // collaboration and open data groups...
        // and the Portal because w need the org's default
        // collaboration group id
        return Promise.all([
            getInitiative(id, requestOptions),
            getSelf(requestOptions)
        ])
            .then(function (results) { return __awaiter(_this, void 0, void 0, function () {
            var model, portal, siteId, prms, opts;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        model = results[0];
                        portal = results[1];
                        siteId = model.item.properties.siteId;
                        if (!siteId) return [3 /*break*/, 5];
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, getItem(siteId, requestOptions)];
                    case 2:
                        _a.sent();
                        state.hasSite = true;
                        state.siteId = siteId;
                        return [3 /*break*/, 4];
                    case 3:
                        _a.sent();
                        state.hasSite = false;
                        return [3 /*break*/, 4];
                    case 4: return [3 /*break*/, 6];
                    case 5:
                        state.hasSite = false;
                        _a.label = 6;
                    case 6:
                        state.initiativeOwner = model.item.owner;
                        state.collaborationGroupId = hubCommon.getProp(portal, "properties.openData.settings.groupId");
                        prms = [];
                        ["collaborationGroupId", "contentGroupId", "followersGroupId"].forEach(function (prop) {
                            if (model.item.properties[prop]) {
                                prms.push(removeInitiativeGroup(model.item.properties[prop], requestOptions).catch(function () { return Promise.resolve(true); }) // swallow group delete failures
                                );
                            }
                        });
                        // if the item is protected, un-protect it...
                        if (model.item.protected) {
                            opts = __assign({ id: id }, requestOptions);
                            prms.push(unprotectItem(opts));
                        }
                        return [2 /*return*/, Promise.all(prms)];
                }
            });
        }); })
            .then(function () {
            var prms = [];
            var opts = __assign({ id: id, owner: state.initiativeOwner }, requestOptions);
            prms.push(removeItem(opts));
            // if we have a site, let's detach it from the initiative
            if (state.hasSite) {
                prms.push(detachSiteFromInitiative(state.siteId, state.collaborationGroupId, requestOptions));
            }
            return Promise.all(prms);
        })
            .then(function () {
            return { success: true };
        });
    }

    /**
     * Convert an Initiative Model into a template
     * Includes a hash of resources
     * @param {object} model Initiative model
     * @param {IHubRequestOptions} hubRequestOptions
     */
    function convertInitiativeToTemplate(model, hubRequestOptions) {
        // clone this so we don't mess things up...
        var templateItem = model.item;
        var template = hubCommon.cloneObject(model);
        template.item = hubCommon.normalizeSolutionTemplateItem(templateItem);
        // clear url
        delete template.item.url;
        // clear the extent
        delete template.item.extent;
        // clear out item properties...
        delete template.item.properties.source;
        delete template.item.properties.collaborationGroupId;
        delete template.item.properties.contentGroupId;
        delete template.item.properties.followersGroupId;
        delete template.item.properties.groupId; // artifact of 2.0 initiatives
        // on the data side of things...
        delete template.data.values.collaborationGroupId;
        delete template.data.values.contentGroupId;
        delete template.data.values.followersGroupId;
        delete template.data.values.followerGroups;
        delete template.data.values.openDataGroupId;
        // Ensure some properties are set correctly
        template.type = "Hub Initiative Template";
        template.key = hubCommon.propifyString(model.item.title) + "_" + hubCommon.createId("i");
        template.itemId = model.item.id;
        // remove the initiative keyword
        template.item.typeKeywords = hubCommon.without(template.item.typeKeywords, "hubInitiative");
        // add the typeKeyword
        template.item.typeKeywords.push("hubInitiativeTemplate");
        // if we have steps, and not recommended, convert them
        // this may happen if the model is fetched via something other
        // than the getInitiative fn, which applies schema upgrades
        if (hubCommon.getProp(template, "data.steps") &&
            !hubCommon.getProp(template, "data.recommendedTemplates")) {
            // collect up the ids from all the steps into `recommendedTemplates`
            template.data.recommendedTemplates = template.data.steps.reduce(function (acc, step) {
                var stepTmpl = step.templateIds || [];
                return acc.concat(stepTmpl);
            }, []);
        }
        // get the resources...
        return getItemResources(template.itemId, hubRequestOptions).then(function (response) {
            // TODO: compute url to resource
            template.resources = response.resources.map(function (e) { return e.resource; });
            return template;
        });
    }

    /* Copyright (c) 2018 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * Search for Initiatives
     *
     * @export
     * @param {ISearchOptions} searchRequestOptions
     * @returns {Promise<ISearchResult>}
     */
    function searchInitiatives(searchRequestOptions) {
        // since we are mutating the q, make a copy first...
        var opts = __assign({}, searchRequestOptions);
        //  inject the type...
        if (opts.q) {
            opts.q = opts.q + " AND type: Hub Initiative";
        }
        else {
            opts.q = "type: Hub Initiative";
        }
        return searchItems(opts);
    }
    /**
     * Search for Initiative Templates
     *
     * @export
     * @param {ISearchOptions} searchRequestOptions
     * @returns {Promise<ISearchResult>}
     */
    function searchInitiativeTemplates(searchRequestOptions) {
        // since we are mutating the q, make a copy first...
        var opts = __assign({}, searchRequestOptions);
        // inject the type and typeKeywords
        if (opts.q) {
            opts.q = opts.q + " AND type: Hub Initiative AND typekeywords:hubInitiativeTemplate";
        }
        else {
            opts.q = "type: Hub Initiative AND typekeywords:hubInitiativeTemplate";
        }
        return searchItems(opts);
    }

    var getUserTag = function (initiativeId) { return "hubInitiativeId|" + initiativeId; };
    var initiativeIdFromUserTag = function (tag) {
        return tag.replace(/^hubInitiativeId\|/, "");
    };
    var initiativeIdFromGroupTag = function (tag) {
        return tag.replace(/^hubInitiativeFollowers\|/, "");
    };
    var getUpdateUrl = function (session) { return getUserUrl(session) + "/update"; };
    var currentlyFollowedInitiativesByUserTag = function (user) {
        return user.tags.map(initiativeIdFromUserTag);
    };
    var currentlyFollowedInitiativesByGroupMembership = function (user) {
        return user.groups
            .map(function (group) { return group.tags; })
            .reduce(function (acc, item) { return acc.concat(item); }, [])
            .filter(function (tags) { return tags.indexOf("hubInitiativeFollowers|") === 0; })
            .map(initiativeIdFromGroupTag);
    };
    var currentlyFollowedInitiatives = function (user) {
        var byUserTags = currentlyFollowedInitiativesByUserTag(user);
        var byGroupMembership = currentlyFollowedInitiativesByGroupMembership(user);
        return __spreadArrays(byUserTags, byGroupMembership).filter(hubCommon.unique);
    };
    var isUserFollowing = function (user, initiativeId) {
        return currentlyFollowedInitiatives(user).indexOf(initiativeId) > -1;
    };
    /**
     * ```js
     * import { followInitiative } from "@esri/hub-initiatives";
     * //
     * followInitiative({
     *   initiativeId,
     *   authentication
     * })
     *   .then(response)
     * ```
     * Follow an initiative.
     */
    function followInitiative(requestOptions) {
        // we dont call getUser() because the tags are cached and will be mutating
        return request(getUserUrl(requestOptions.authentication), {
            authentication: requestOptions.authentication
        })
            .then(function (user) {
            // don't update if already following
            if (isUserFollowing(user, requestOptions.initiativeId)) {
                return Promise.reject("user is already following this initiative.");
            }
            // if not already following, pass the user on
            return user;
        })
            .then(function (user) {
            return getInitiative(requestOptions.initiativeId, requestOptions).then(function (initiative) { return ({
                user: user,
                initiative: initiative,
                hasFollowersGroup: false
            }); });
        })
            .then(function (obj) {
            // if the initiative has a followersGroupId
            var groupId = hubCommon.getProp(obj, "initiative.item.properties.followersGroupId");
            if (groupId) {
                // attempt to join it
                return joinGroup({
                    id: groupId,
                    authentication: requestOptions.authentication
                }).then(function (groupJoinResponse) {
                    obj.hasFollowersGroup = groupJoinResponse.success;
                    return obj;
                });
            }
            return obj;
        })
            .then(function (obj) {
            if (!obj.hasFollowersGroup) {
                // else add the tag to the user
                var tag = getUserTag(requestOptions.initiativeId);
                var tags = JSON.parse(JSON.stringify(obj.user.tags));
                tags.push(tag);
                return request(getUpdateUrl(requestOptions.authentication), {
                    params: { tags: tags },
                    authentication: requestOptions.authentication
                });
            }
            // the initiative has a followers group and we successfully joined it
            return { success: true, username: obj.user.username };
        });
    }
    /**
     * ```js
     * import { unfollowInitiative } from "@esri/hub-initiatives";
     * //
     * unfollowInitiative({
     *   initiativeId,
     *   authentication
     * })
     *   .then(response)
     * ```
     * Un-follow an initiative.
     */
    function unfollowInitiative(requestOptions) {
        // we dont call getUser() because the tags are cached and will be mutating
        return request(getUserUrl(requestOptions.authentication), {
            authentication: requestOptions.authentication
        })
            .then(function (user) {
            // don't update if not already following
            if (!isUserFollowing(user, requestOptions.initiativeId)) {
                return Promise.reject("user is not following this initiative.");
            }
            // if already following, pass the user on
            return user;
        })
            .then(function (user) {
            var tag = getUserTag(requestOptions.initiativeId);
            var tags = JSON.parse(JSON.stringify(user.tags));
            if (tags.indexOf(tag) > -1) {
                // https://stackoverflow.com/questions/9792927/javascript-array-search-and-remove-string
                var index = tags.indexOf(tag);
                tags.splice(index, 1);
                // clear the last tag by passing ",".
                if (tags.length === 0) {
                    tags.push(",");
                }
                return request(getUpdateUrl(requestOptions.authentication), {
                    params: { tags: tags },
                    authentication: requestOptions.authentication
                }).then(function (_) { return user; });
            }
            return user;
        })
            .then(function (user) {
            return getInitiative(requestOptions.initiativeId, requestOptions).then(function (initiative) { return ({ user: user, initiative: initiative }); });
        })
            .then(function (obj) {
            // if there is an initiative followers group and the user is a member, attempt to leave it
            var groupId = hubCommon.getProp(obj, "initiative.item.properties.followersGroupId");
            if (groupId &&
                currentlyFollowedInitiativesByGroupMembership(obj.user).indexOf(requestOptions.initiativeId) > -1) {
                return leaveGroup({
                    id: groupId,
                    authentication: requestOptions.authentication
                }).then(function (groupLeaveResponse) {
                    return { success: true, username: obj.user.username };
                });
            }
            return { success: true, username: obj.user.username };
        });
    }

    var DEFAULT_INITIATIVE_TEMPLATE = {
        item: {
            title: "{{solution.title}}",
            snippet: "{{solution.snippet}}",
            description: "{{solution.snippet}}",
            type: "Hub Initiative",
            typeKeywords: ["Hub", "hubInitiative"],
            tags: [],
            extent: "{{organization.defaultExtentBBox}}",
            culture: "{{user.culture}}",
            properties: {},
            url: "",
        },
        data: {
            assets: [],
            indicators: [],
            recommendedTemplates: [],
        },
    };

    /**
     * Get the translated default initiative template
     * @param {IHubRequestOptions} hubRequestOptions
     */
    function getDefaultInitiativeTemplate(hubRequestOptions) {
        var culture = hubCommon.getCulture(hubRequestOptions);
        var locale = hubCommon.convertToWellKnownLocale(culture);
        return hubCommon.fetchHubTranslation(locale, hubRequestOptions.portalSelf).then(function (translation) {
            // now we can get the embedded initiative template
            var tmpl = hubCommon.cloneObject(DEFAULT_INITIATIVE_TEMPLATE);
            // pluck values off the translation, and inject into the tmpl
            tmpl.item.description = hubCommon.getProp(translation, "addons.services.templates.customInitiative.item.description");
            tmpl.item.snippet = hubCommon.getProp(translation, "addons.services.templates.customInitiative.item.snippet");
            tmpl.item.culture = locale;
            // TODO: HANDLE RESOURCES!
            return tmpl;
        });
    }

    /**
     * Given the id of an initiative, fetch it, and convert to a template
     * If the fetch fails, it will return the default initiative template
     * @param {string} id Initiative Item Id
     * @param {IHubRequestOptions} hubRequestOptions
     * @private
     */
    function _fetchAndConvertInitiativeToTemplate(id, hubRequestOptions) {
        return getInitiative(id, hubRequestOptions)
            .then(function (model) {
            return convertInitiativeToTemplate(model, hubRequestOptions);
        })
            .catch(function (_) {
            return getDefaultInitiativeTemplate(hubRequestOptions);
        });
    }

    // TODO: the initiative will be in the site hash OR we pass it in
    /**
     * Given a Site Template, do what we can to return an initiative template
     * In Hub, we expect the system to populate tmpl.properties.initiativeTemplate
     * In other apps, this may not be present, so we use the default template
     * (fetched from the Hub app)
     * @param {object} siteTemplate Site Template
     * @param {IHubRequestOptions} hubRequestOptions
     */
    function getInitiativeTemplate(siteTemplate, hubRequestOptions) {
        var tmplPromise;
        var template = hubCommon.getProp(siteTemplate, "properties.initiativeTemplate");
        if (template) {
            tmplPromise = Promise.resolve(template);
        }
        else {
            // return the default template
            tmplPromise = getDefaultInitiativeTemplate(hubRequestOptions);
        }
        return tmplPromise;
    }

    /**
     * Update the Site associated with an Initiative by setting the
     * `item.properties.siteId` to a new value
     *
     * Used during createSite(...) and any time we need to
     * connect a different Site to an Initiative
     *
     * @param initiativeItemId string | IItem | IModel
     * @param siteId string
     * @param hubRequestOptions IHubRequestOptions
     */
    function updateInitiativeSiteId(maybeModel, siteId, hubRequestOptions) {
        // assume it's an IItem
        var itemPromise = Promise.resolve(maybeModel);
        // if we got a string, treat it as an id
        if (typeof maybeModel === "string") {
            if (!hubCommon.isGuid(maybeModel)) {
                return Promise.reject(new Error("updateInitiativeSiteId was passed a string that is not a GUID."));
            }
            else {
                itemPromise = getItem(maybeModel, {
                    authentication: hubRequestOptions.authentication
                });
            }
        }
        else {
            // if it's an IModel it will have `.item.id` defined
            if (hubCommon.getProp(maybeModel, "item.id")) {
                var m = maybeModel;
                itemPromise = Promise.resolve(m.item);
            }
        }
        // kick off the promise that will return an IItem
        return itemPromise.then(function (item) {
            // oddly, IItem does not have .properties even as an optional O_o
            // regardless, ensure .properties exists
            if (!item.properties) {
                item.properties = {};
            }
            // set the siteId
            item.properties.siteId = siteId;
            // and... update the item
            return updateItem({
                item: item,
                authentication: hubRequestOptions.authentication
            });
        });
    }

    exports.INITIATIVE_TYPE_NAME = INITIATIVE_TYPE_NAME;
    exports._fetchAndConvertInitiativeToTemplate = _fetchAndConvertInitiativeToTemplate;
    exports.activateInitiative = activateInitiative;
    exports.addImageAsResource = addImageAsResource;
    exports.addInitiative = addInitiative;
    exports.checkGroupExists = checkGroupExists;
    exports.convertIndicatorsToDefinitions = convertIndicatorsToDefinitions;
    exports.convertInitiativeToTemplate = convertInitiativeToTemplate;
    exports.copyEmbeddedImageResources = copyEmbeddedImageResources;
    exports.copyImageResources = copyImageResources;
    exports.createInitiativeGroup = createInitiativeGroup;
    exports.createInitiativeModelFromTemplate = createInitiativeModelFromTemplate;
    exports.currentlyFollowedInitiatives = currentlyFollowedInitiatives;
    exports.detachSiteFromInitiative = detachSiteFromInitiative;
    exports.followInitiative = followInitiative;
    exports.geometryService = geometryService$1;
    exports.getDefaultInitiativeTemplate = getDefaultInitiativeTemplate;
    exports.getInitiative = getInitiative;
    exports.getInitiativeTemplate = getInitiativeTemplate;
    exports.getInitiativeUrl = getInitiativeUrl;
    exports.getUniqueGroupName = getUniqueGroupName;
    exports.isSharedEditingGroup = isSharedEditingGroup;
    exports.isUserFollowing = isUserFollowing;
    exports.removeInitiative = removeInitiative;
    exports.removeInitiativeGroup = removeInitiativeGroup;
    exports.searchInitiativeTemplates = searchInitiativeTemplates;
    exports.searchInitiatives = searchInitiatives;
    exports.unfollowInitiative = unfollowInitiative;
    exports.updateInitiative = updateInitiative;
    exports.updateInitiativeSiteId = updateInitiativeSiteId;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=initiatives.umd.js.map
